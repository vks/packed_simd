var searchIndex = JSON.parse('{\
"cfg_if":{"doc":"A macro for defining `#[cfg]` if-else statements.","i":[[14,"cfg_if","cfg_if","The main macro provided by this crate. See crate…",null,null]],"p":[]},\
"libm":{"doc":"libm in pure Rust","i":[[5,"acos","libm","Arccosine (f64)",null,[[]]],[5,"acosf","","Arccosine (f32)",null,[[]]],[5,"acosh","","Inverse hyperbolic cosine (f64)",null,[[]]],[5,"acoshf","","Inverse hyperbolic cosine (f32)",null,[[]]],[5,"asin","","Arcsine (f64)",null,[[]]],[5,"asinf","","Arcsine (f32)",null,[[]]],[5,"asinh","","Inverse hyperbolic sine (f64)",null,[[]]],[5,"asinhf","","Inverse hyperbolic sine (f32)",null,[[]]],[5,"atan","","Arctangent (f64)",null,[[]]],[5,"atan2","","Arctangent of y/x (f64)",null,[[]]],[5,"atan2f","","Arctangent of y/x (f32)",null,[[]]],[5,"atanf","","Arctangent (f32)",null,[[]]],[5,"atanh","","Inverse hyperbolic tangent (f64)",null,[[]]],[5,"atanhf","","Inverse hyperbolic tangent (f32)",null,[[]]],[5,"cbrt","","Computes the cube root of the argument.",null,[[]]],[5,"cbrtf","","Cube root (f32)",null,[[]]],[5,"ceil","","Ceil (f64)",null,[[]]],[5,"ceilf","","Ceil (f32)",null,[[]]],[5,"copysign","","Sign of Y, magnitude of X (f64)",null,[[]]],[5,"copysignf","","Sign of Y, magnitude of X (f32)",null,[[]]],[5,"cos","","",null,[[]]],[5,"cosf","","",null,[[]]],[5,"cosh","","Hyperbolic cosine (f64)",null,[[]]],[5,"coshf","","Hyperbolic cosine (f64)",null,[[]]],[5,"erf","","Error function (f64)",null,[[]]],[5,"erfc","","Error function (f64)",null,[[]]],[5,"erfcf","","Error function (f32)",null,[[]]],[5,"erff","","Error function (f32)",null,[[]]],[5,"exp","","Exponential, base e (f64)",null,[[]]],[5,"exp10","","",null,[[]]],[5,"exp10f","","",null,[[]]],[5,"exp2","","Exponential, base 2 (f64)",null,[[]]],[5,"exp2f","","Exponential, base 2 (f32)",null,[[]]],[5,"expf","","Exponential, base e (f32)",null,[[]]],[5,"expm1","","Exponential, base e, of x-1 (f64)",null,[[]]],[5,"expm1f","","Exponential, base e, of x-1 (f32)",null,[[]]],[5,"fabs","","Absolute value (magnitude) (f64) Calculates the absolute…",null,[[]]],[5,"fabsf","","Absolute value (magnitude) (f32) Calculates the absolute…",null,[[]]],[5,"fdim","","Positive difference (f64)",null,[[]]],[5,"fdimf","","Positive difference (f32)",null,[[]]],[5,"floor","","Floor (f64)",null,[[]]],[5,"floorf","","Floor (f64)",null,[[]]],[5,"fma","","Floating multiply add (f64)",null,[[]]],[5,"fmaf","","Floating multiply add (f32)",null,[[]]],[5,"fmax","","",null,[[]]],[5,"fmaxf","","",null,[[]]],[5,"fmin","","",null,[[]]],[5,"fminf","","",null,[[]]],[5,"fmod","","",null,[[]]],[5,"fmodf","","",null,[[]]],[5,"frexp","","",null,[[]]],[5,"frexpf","","",null,[[]]],[5,"hypot","","",null,[[]]],[5,"hypotf","","",null,[[]]],[5,"ilogb","","",null,[[]]],[5,"ilogbf","","",null,[[]]],[5,"j0","","",null,[[]]],[5,"y0","","",null,[[]]],[5,"j0f","","",null,[[]]],[5,"y0f","","",null,[[]]],[5,"j1","","",null,[[]]],[5,"y1","","",null,[[]]],[5,"j1f","","",null,[[]]],[5,"y1f","","",null,[[]]],[5,"jn","","",null,[[]]],[5,"yn","","",null,[[]]],[5,"jnf","","",null,[[]]],[5,"ynf","","",null,[[]]],[5,"ldexp","","",null,[[]]],[5,"ldexpf","","",null,[[]]],[5,"lgamma","","",null,[[]]],[5,"lgamma_r","","",null,[[]]],[5,"lgammaf","","",null,[[]]],[5,"lgammaf_r","","",null,[[]]],[5,"log","","",null,[[]]],[5,"log10","","",null,[[]]],[5,"log10f","","",null,[[]]],[5,"log1p","","",null,[[]]],[5,"log1pf","","",null,[[]]],[5,"log2","","",null,[[]]],[5,"log2f","","",null,[[]]],[5,"logf","","",null,[[]]],[5,"modf","","",null,[[]]],[5,"modff","","",null,[[]]],[5,"pow","","",null,[[]]],[5,"powf","","",null,[[]]],[5,"remquo","","",null,[[]]],[5,"remquof","","",null,[[]]],[5,"round","","",null,[[]]],[5,"roundf","","",null,[[]]],[5,"scalbn","","",null,[[]]],[5,"scalbnf","","",null,[[]]],[5,"sin","","",null,[[]]],[5,"sincos","","",null,[[]]],[5,"sincosf","","",null,[[]]],[5,"sinf","","",null,[[]]],[5,"sinh","","",null,[[]]],[5,"sinhf","","",null,[[]]],[5,"sqrt","","",null,[[]]],[5,"sqrtf","","",null,[[]]],[5,"tan","","",null,[[]]],[5,"tanf","","",null,[[]]],[5,"tanh","","",null,[[]]],[5,"tanhf","","",null,[[]]],[5,"tgamma","","",null,[[]]],[5,"tgammaf","","",null,[[]]],[5,"trunc","","",null,[[]]],[5,"truncf","","",null,[[]]],[8,"F32Ext","","Math support for `f32`",null,null],[10,"floor","","",0,[[]]],[10,"ceil","","",0,[[]]],[10,"round","","",0,[[]]],[10,"trunc","","",0,[[]]],[10,"fdim","","",0,[[]]],[10,"fract","","",0,[[]]],[10,"abs","","",0,[[]]],[10,"mul_add","","",0,[[]]],[10,"div_euc","","",0,[[]]],[10,"mod_euc","","",0,[[]]],[10,"powf","","",0,[[]]],[10,"sqrt","","",0,[[]]],[10,"exp","","",0,[[]]],[10,"exp2","","",0,[[]]],[10,"ln","","",0,[[]]],[10,"log","","",0,[[]]],[10,"log2","","",0,[[]]],[10,"log10","","",0,[[]]],[10,"cbrt","","",0,[[]]],[10,"hypot","","",0,[[]]],[10,"sin","","",0,[[]]],[10,"cos","","",0,[[]]],[10,"tan","","",0,[[]]],[10,"asin","","",0,[[]]],[10,"acos","","",0,[[]]],[10,"atan","","",0,[[]]],[10,"atan2","","",0,[[]]],[10,"sin_cos","","",0,[[]]],[10,"exp_m1","","",0,[[]]],[10,"ln_1p","","",0,[[]]],[10,"sinh","","",0,[[]]],[10,"cosh","","",0,[[]]],[10,"tanh","","",0,[[]]],[10,"asinh","","",0,[[]]],[10,"acosh","","",0,[[]]],[10,"atanh","","",0,[[]]],[10,"min","","",0,[[]]],[10,"max","","",0,[[]]],[8,"F64Ext","","Math support for `f64`",null,null],[10,"floor","","",1,[[]]],[10,"ceil","","",1,[[]]],[10,"round","","",1,[[]]],[10,"trunc","","",1,[[]]],[10,"fdim","","",1,[[]]],[10,"fract","","",1,[[]]],[10,"abs","","",1,[[]]],[10,"mul_add","","",1,[[]]],[10,"div_euc","","",1,[[]]],[10,"mod_euc","","",1,[[]]],[10,"powf","","",1,[[]]],[10,"sqrt","","",1,[[]]],[10,"exp","","",1,[[]]],[10,"exp2","","",1,[[]]],[10,"ln","","",1,[[]]],[10,"log","","",1,[[]]],[10,"log2","","",1,[[]]],[10,"log10","","",1,[[]]],[10,"cbrt","","",1,[[]]],[10,"hypot","","",1,[[]]],[10,"sin","","",1,[[]]],[10,"cos","","",1,[[]]],[10,"tan","","",1,[[]]],[10,"asin","","",1,[[]]],[10,"acos","","",1,[[]]],[10,"atan","","",1,[[]]],[10,"atan2","","",1,[[]]],[10,"sin_cos","","",1,[[]]],[10,"exp_m1","","",1,[[]]],[10,"ln_1p","","",1,[[]]],[10,"sinh","","",1,[[]]],[10,"cosh","","",1,[[]]],[10,"tanh","","",1,[[]]],[10,"asinh","","",1,[[]]],[10,"acosh","","",1,[[]]],[10,"atanh","","",1,[[]]],[10,"min","","",1,[[]]],[10,"max","","",1,[[]]]],"p":[[8,"F32Ext"],[8,"F64Ext"]]},\
"packed_simd_2":{"doc":"Portable packed SIMD vectorsThis crate is proposed for…","i":[[3,"Simd","packed_simd_2","Packed SIMD vector type.",null,null],[3,"LexicographicallyOrdered","","Wrapper over `T` implementing a lexicoraphical order via…",null,null],[3,"m8","","8-bit wide mask.",null,null],[3,"m16","","16-bit wide mask.",null,null],[3,"m32","","32-bit wide mask.",null,null],[3,"m64","","64-bit wide mask.",null,null],[3,"m128","","128-bit wide mask.",null,null],[3,"msize","","isize-wide mask.",null,null],[11,"new","","Instantiate a mask with `value`",0,[[]]],[11,"test","","Test if the mask is set",0,[[]]],[11,"new","","Instantiate a mask with `value`",1,[[]]],[11,"test","","Test if the mask is set",1,[[]]],[11,"new","","Instantiate a mask with `value`",2,[[]]],[11,"test","","Test if the mask is set",2,[[]]],[11,"new","","Instantiate a mask with `value`",3,[[]]],[11,"test","","Test if the mask is set",3,[[]]],[11,"new","","Instantiate a mask with `value`",4,[[]]],[11,"test","","Test if the mask is set",4,[[]]],[11,"new","","Instantiate a mask with `value`",5,[[]]],[11,"test","","Test if the mask is set",5,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x2",6]],["i8x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x2",6]],["i8x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["i8x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["i8x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x2",6]],["u8x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x2",6]],["u8x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u8x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u8x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["m8x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["m8x2",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x4",6]],["i8x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x4",6]],["i8x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["i8x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["i8x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x4",6]],["u8x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x4",6]],["u8x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u8x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u8x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m8x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m8x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x2",6]],["i16x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x2",6]],["i16x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["i16x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["i16x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x2",6]],["u16x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x2",6]],["u16x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u16x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u16x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m16x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m16x2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x8",6]],["i8x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x8",6]],["i8x8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i8x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i8x8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x8",6]],["u8x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x8",6]],["u8x8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u8x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u8x8",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["m8x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["m8x8",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x4",6]],["i16x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x4",6]],["i16x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i16x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i16x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x4",6]],["u16x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x4",6]],["u16x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u16x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u16x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m16x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m16x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i32x2",6]],["i32x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i32x2",6]],["i32x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i32x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i32x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u32x2",6]],["u32x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u32x2",6]],["u32x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u32x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u32x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m32x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m32x2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[]]],[11,"product","","Horizontal product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes\' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler\'s number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m32x2",6]]],[11,"is_infinite","","",6,[[],["m32x2",6]]],[11,"is_finite","","",6,[[],["m32x2",6]]],[11,"abs","","Absolute value.",6,[[]]],[11,"cos","","Cosine.",6,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[]]],[11,"sin","","Sine.",6,[[]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[]]],[11,"sqrte","","Square-root estimate.",6,[[]]],[11,"tanh","","Tanh.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x2",6]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x16",6]],["i8x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x16",6]],["i8x16",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i8x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i8x16",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x16",6]],["u8x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x16",6]],["u8x16",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u8x16",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u8x16",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x16",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m8x16",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m8x16",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x8",6]],["i16x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x8",6]],["i16x8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i16x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i16x8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x8",6]],["u16x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x8",6]],["u16x8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u16x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u16x8",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m16x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m16x8",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i32x4",6]],["i32x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i32x4",6]],["i32x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["i32x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["i32x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u32x4",6]],["u32x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u32x4",6]],["u32x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u32x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u32x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[]]],[11,"product","","Horizontal product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes\' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler\'s number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m32x4",6]]],[11,"is_infinite","","",6,[[],["m32x4",6]]],[11,"is_finite","","",6,[[],["m32x4",6]]],[11,"abs","","Absolute value.",6,[[]]],[11,"cos","","Cosine.",6,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[]]],[11,"sin","","Sine.",6,[[]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[]]],[11,"sqrte","","Square-root estimate.",6,[[]]],[11,"tanh","","Tanh.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x4",6]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m32x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m32x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i64x2",6]],["i64x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i64x2",6]],["i64x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["i64x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["i64x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u64x2",6]],["u64x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u64x2",6]],["u64x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u64x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u64x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[]]],[11,"product","","Horizontal product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes\' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler\'s number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m64x2",6]]],[11,"is_infinite","","",6,[[],["m64x2",6]]],[11,"is_finite","","",6,[[],["m64x2",6]]],[11,"abs","","Absolute value.",6,[[]]],[11,"cos","","Cosine.",6,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[]]],[11,"sin","","Sine.",6,[[]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[]]],[11,"sqrte","","Square-root estimate.",6,[[]]],[11,"tanh","","Tanh.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x2",6]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["m64x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["m64x2",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i128x1",6]],["i128x1",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i128x1",6]],["i128x1",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x1",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x1",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x1",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x1",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x1",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x1",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i128x1",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i128x1",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u128x1",6]],["u128x1",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u128x1",6]],["u128x1",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x1",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x1",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x1",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x1",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x1",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x1",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u128x1",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u128x1",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x1",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x1",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x1",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x1",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x1",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x1",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m128x1",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m128x1",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x32",6]],["i8x32",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x32",6]],["i8x32",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x32",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x32",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x32",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i8x32",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i8x32",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x32",6]],["u8x32",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x32",6]],["u8x32",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x32",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x32",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x32",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u8x32",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u8x32",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x32",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x32",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x32",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["m8x32",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["m8x32",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x16",6]],["i16x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x16",6]],["i16x16",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i16x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i16x16",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x16",6]],["u16x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x16",6]],["u16x16",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u16x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u16x16",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x16",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["m16x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["m16x16",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i32x8",6]],["i32x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i32x8",6]],["i32x8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["i32x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["i32x8",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u32x8",6]],["u32x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u32x8",6]],["u32x8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u32x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u32x8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[]]],[11,"product","","Horizontal product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes\' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler\'s number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m32x8",6]]],[11,"is_infinite","","",6,[[],["m32x8",6]]],[11,"is_finite","","",6,[[],["m32x8",6]]],[11,"abs","","Absolute value.",6,[[]]],[11,"cos","","Cosine.",6,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[]]],[11,"sin","","Sine.",6,[[]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[]]],[11,"sqrte","","Square-root estimate.",6,[[]]],[11,"tanh","","Tanh.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x8",6]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["m32x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["m32x8",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i64x4",6]],["i64x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i64x4",6]],["i64x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i64x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i64x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u64x4",6]],["u64x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u64x4",6]],["u64x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u64x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u64x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[]]],[11,"product","","Horizontal product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes\' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler\'s number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m64x4",6]]],[11,"is_infinite","","",6,[[],["m64x4",6]]],[11,"is_finite","","",6,[[],["m64x4",6]]],[11,"abs","","Absolute value.",6,[[]]],[11,"cos","","Cosine.",6,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[]]],[11,"sin","","Sine.",6,[[]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[]]],[11,"sqrte","","Square-root estimate.",6,[[]]],[11,"tanh","","Tanh.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x4",6]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m64x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m64x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i128x2",6]],["i128x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i128x2",6]],["i128x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["i128x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["i128x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u128x2",6]],["u128x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u128x2",6]],["u128x2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u128x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u128x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m128x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m128x2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x64",6]],["i8x64",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x64",6]],["i8x64",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x64",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x64",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x64",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x64",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x64",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x64",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i8x64",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i8x64",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x64",6]],["u8x64",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x64",6]],["u8x64",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x64",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x64",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x64",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x64",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x64",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x64",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u8x64",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u8x64",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x64",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x64",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x64",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x64",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x64",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x64",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["m8x64",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["m8x64",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x32",6]],["i16x32",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x32",6]],["i16x32",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x32",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x32",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x32",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i16x32",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i16x32",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x32",6]],["u16x32",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x32",6]],["u16x32",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x32",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x32",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x32",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u16x32",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u16x32",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x32",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x32",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x32",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m16x32",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m16x32",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i32x16",6]],["i32x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i32x16",6]],["i32x16",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i32x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i32x16",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u32x16",6]],["u32x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u32x16",6]],["u32x16",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u32x16",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u32x16",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[]]],[11,"product","","Horizontal product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes\' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler\'s number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m32x16",6]]],[11,"is_infinite","","",6,[[],["m32x16",6]]],[11,"is_finite","","",6,[[],["m32x16",6]]],[11,"abs","","Absolute value.",6,[[]]],[11,"cos","","Cosine.",6,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[]]],[11,"sin","","Sine.",6,[[]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[]]],[11,"sqrte","","Square-root estimate.",6,[[]]],[11,"tanh","","Tanh.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x16",6]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x16",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x16",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x16",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m32x16",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m32x16",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i64x8",6]],["i64x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i64x8",6]],["i64x8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["i64x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["i64x8",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u64x8",6]],["u64x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u64x8",6]],["u64x8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["u64x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["u64x8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[]]],[11,"product","","Horizontal product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes\' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler\'s number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m64x8",6]]],[11,"is_infinite","","",6,[[],["m64x8",6]]],[11,"is_finite","","",6,[[],["m64x8",6]]],[11,"abs","","Absolute value.",6,[[]]],[11,"cos","","Cosine.",6,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[]]],[11,"sin","","Sine.",6,[[]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[]]],[11,"sqrte","","Square-root estimate.",6,[[]]],[11,"tanh","","Tanh.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x8",6]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["m64x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["m64x8",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i128x4",6]],["i128x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i128x4",6]],["i128x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["i128x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["i128x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u128x4",6]],["u128x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u128x4",6]],["u128x4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["u128x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["u128x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["m128x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["m128x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["isizex2",6]],["isizex2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["isizex2",6]],["isizex2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["isizex2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["isizex2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["usizex2",6]],["usizex2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["usizex2",6]],["usizex2",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["usizex2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["usizex2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["msizex2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["msizex2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["isizex4",6]],["isizex4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["isizex4",6]],["isizex4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["isizex4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["isizex4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["usizex4",6]],["usizex4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["usizex4",6]],["usizex4",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["usizex4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["usizex4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["lexicographicallyordered",3],["msizex4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["lexicographicallyordered",3],["msizex4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["isizex8",6]],["isizex8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["isizex8",6]],["isizex8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["isizex8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["isizex8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["usizex8",6]],["usizex8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["usizex8",6]],["usizex8",6]]],[11,"min","","Minimum of two vectors.",6,[[]]],[11,"max","","Maximum of two vectors.",6,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[]]],[11,"max_element","","Largest vector element value.",6,[[]]],[11,"min_element","","Smallest vector element value.",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",6,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",6,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",6,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",6,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["usizex8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["usizex8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[]]],[11,"all","","Are `all` vector lanes `true`?",6,[[]]],[11,"any","","Is `any` vector lane `true`?",6,[[]]],[11,"none","","Are `all` vector lanes `false`?",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[],[["msizex8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[],[["msizex8",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex2",6]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex2",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex2",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex2",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex2",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex2",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex2",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex2",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd",3],["simd",3]],["simd",3]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex2",6]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex2",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex2",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex2",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex2",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex2",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex2",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex2",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd",3],["simd",3]],["simd",3]]],[11,"write","","Writes selected vector elements to memory.",6,[[["simd",3],["simd",3]]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex4",6]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex4",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex4",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex4",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex4",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex4",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex4",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex4",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd",3],["simd",3]],["simd",3]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex4",6]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex4",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex4",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex4",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex4",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex4",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex4",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex4",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd",3],["simd",3]],["simd",3]]],[11,"write","","Writes selected vector elements to memory.",6,[[["simd",3],["simd",3]]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex8",6]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex8",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex8",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex8",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex8",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex8",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex8",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex8",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex8",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd",3],["simd",3]],["simd",3]]],[11,"new","","Creates a new instance with each vector elements…",6,[[]]],[11,"lanes","","Returns the number of vector lanes.",6,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex8",6]]],[11,"extract","","Extracts the value at `index`.",6,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex8",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex8",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex8",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex8",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex8",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex8",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex8",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex8",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd",3],["simd",3]],["simd",3]]],[11,"write","","Writes selected vector elements to memory.",6,[[["simd",3],["simd",3]]]],[6,"i8x2","","A 16-bit vector with 2 `i8` lanes.",null,null],[6,"u8x2","","A 16-bit vector with 2 `u8` lanes.",null,null],[6,"m8x2","","A 16-bit vector mask with 2 `m8` lanes.",null,null],[6,"i8x4","","A 32-bit vector with 4 `i8` lanes.",null,null],[6,"u8x4","","A 32-bit vector with 4 `u8` lanes.",null,null],[6,"m8x4","","A 32-bit vector mask with 4 `m8` lanes.",null,null],[6,"i16x2","","A 32-bit vector with 2 `i16` lanes.",null,null],[6,"u16x2","","A 32-bit vector with 2 `u16` lanes.",null,null],[6,"m16x2","","A 32-bit vector mask with 2 `m16` lanes.",null,null],[6,"i8x8","","A 64-bit vector with 8 `i8` lanes.",null,null],[6,"u8x8","","A 64-bit vector with 8 `u8` lanes.",null,null],[6,"m8x8","","A 64-bit vector mask with 8 `m8` lanes.",null,null],[6,"i16x4","","A 64-bit vector with 4 `i16` lanes.",null,null],[6,"u16x4","","A 64-bit vector with 4 `u16` lanes.",null,null],[6,"m16x4","","A 64-bit vector mask with 4 `m16` lanes.",null,null],[6,"i32x2","","A 64-bit vector with 2 `i32` lanes.",null,null],[6,"u32x2","","A 64-bit vector with 2 `u32` lanes.",null,null],[6,"m32x2","","A 64-bit vector mask with 2 `m32` lanes.",null,null],[6,"f32x2","","A 64-bit vector with 2 `f32` lanes.",null,null],[6,"i8x16","","A 128-bit vector with 16 `i8` lanes.",null,null],[6,"u8x16","","A 128-bit vector with 16 `u8` lanes.",null,null],[6,"m8x16","","A 128-bit vector mask with 16 `m8` lanes.",null,null],[6,"i16x8","","A 128-bit vector with 8 `i16` lanes.",null,null],[6,"u16x8","","A 128-bit vector with 8 `u16` lanes.",null,null],[6,"m16x8","","A 128-bit vector mask with 8 `m16` lanes.",null,null],[6,"i32x4","","A 128-bit vector with 4 `i32` lanes.",null,null],[6,"u32x4","","A 128-bit vector with 4 `u32` lanes.",null,null],[6,"f32x4","","A 128-bit vector with 4 `f32` lanes.",null,null],[6,"m32x4","","A 128-bit vector mask with 4 `m32` lanes.",null,null],[6,"i64x2","","A 128-bit vector with 2 `i64` lanes.",null,null],[6,"u64x2","","A 128-bit vector with 2 `u64` lanes.",null,null],[6,"f64x2","","A 128-bit vector with 2 `f64` lanes.",null,null],[6,"m64x2","","A 128-bit vector mask with 2 `m64` lanes.",null,null],[6,"i128x1","","A 128-bit vector with 1 `i128` lane.",null,null],[6,"u128x1","","A 128-bit vector with 1 `u128` lane.",null,null],[6,"m128x1","","A 128-bit vector mask with 1 `m128` lane.",null,null],[6,"i8x32","","A 256-bit vector with 32 `i8` lanes.",null,null],[6,"u8x32","","A 256-bit vector with 32 `u8` lanes.",null,null],[6,"m8x32","","A 256-bit vector mask with 32 `m8` lanes.",null,null],[6,"i16x16","","A 256-bit vector with 16 `i16` lanes.",null,null],[6,"u16x16","","A 256-bit vector with 16 `u16` lanes.",null,null],[6,"m16x16","","A 256-bit vector mask with 16 `m16` lanes.",null,null],[6,"i32x8","","A 256-bit vector with 8 `i32` lanes.",null,null],[6,"u32x8","","A 256-bit vector with 8 `u32` lanes.",null,null],[6,"f32x8","","A 256-bit vector with 8 `f32` lanes.",null,null],[6,"m32x8","","A 256-bit vector mask with 8 `m32` lanes.",null,null],[6,"i64x4","","A 256-bit vector with 4 `i64` lanes.",null,null],[6,"u64x4","","A 256-bit vector with 4 `u64` lanes.",null,null],[6,"f64x4","","A 256-bit vector with 4 `f64` lanes.",null,null],[6,"m64x4","","A 256-bit vector mask with 4 `m64` lanes.",null,null],[6,"i128x2","","A 256-bit vector with 2 `i128` lanes.",null,null],[6,"u128x2","","A 256-bit vector with 2 `u128` lanes.",null,null],[6,"m128x2","","A 256-bit vector mask with 2 `m128` lanes.",null,null],[6,"i8x64","","A 512-bit vector with 64 `i8` lanes.",null,null],[6,"u8x64","","A 512-bit vector with 64 `u8` lanes.",null,null],[6,"m8x64","","A 512-bit vector mask with 64 `m8` lanes.",null,null],[6,"i16x32","","A 512-bit vector with 32 `i16` lanes.",null,null],[6,"u16x32","","A 512-bit vector with 32 `u16` lanes.",null,null],[6,"m16x32","","A 512-bit vector mask with 32 `m16` lanes.",null,null],[6,"i32x16","","A 512-bit vector with 16 `i32` lanes.",null,null],[6,"u32x16","","A 512-bit vector with 16 `u32` lanes.",null,null],[6,"f32x16","","A 512-bit vector with 16 `f32` lanes.",null,null],[6,"m32x16","","A 512-bit vector mask with 16 `m32` lanes.",null,null],[6,"i64x8","","A 512-bit vector with 8 `i64` lanes.",null,null],[6,"u64x8","","A 512-bit vector with 8 `u64` lanes.",null,null],[6,"f64x8","","A 512-bit vector with 8 `f64` lanes.",null,null],[6,"m64x8","","A 512-bit vector mask with 8 `m64` lanes.",null,null],[6,"i128x4","","A 512-bit vector with 4 `i128` lanes.",null,null],[6,"u128x4","","A 512-bit vector with 4 `u128` lanes.",null,null],[6,"m128x4","","A 512-bit vector mask with 4 `m128` lanes.",null,null],[6,"isizex2","","A vector with 2 `isize` lanes.",null,null],[6,"usizex2","","A vector with 2 `usize` lanes.",null,null],[6,"msizex2","","A vector mask with 2 `msize` lanes.",null,null],[6,"isizex4","","A vector with 4 `isize` lanes.",null,null],[6,"usizex4","","A vector with 4 `usize` lanes.",null,null],[6,"msizex4","","A vector mask with 4 `msize` lanes.",null,null],[6,"isizex8","","A vector with 8 `isize` lanes.",null,null],[6,"usizex8","","A vector with 8 `usize` lanes.",null,null],[6,"msizex8","","A vector mask with 8 `msize` lanes.",null,null],[6,"cptrx2","","A vector with 2 `*const T` lanes",null,null],[6,"mptrx2","","A vector with 2 `*mut T` lanes",null,null],[6,"cptrx4","","A vector with 4 `*const T` lanes",null,null],[6,"mptrx4","","A vector with 4 `*mut T` lanes",null,null],[6,"cptrx8","","A vector with 8 `*const T` lanes",null,null],[6,"mptrx8","","A vector with 8 `*mut T` lanes",null,null],[8,"SimdVector","","This trait is implemented by all SIMD vector types.",null,null],[16,"Element","","Element type of the SIMD vector",7,null],[18,"LANES","","The number of elements in the SIMD vector.",7,null],[16,"LanesType","","The type: `[u32; Self::N]`.",7,null],[8,"SimdArray","","Trait implemented by arrays that can be SIMD types.",null,null],[16,"Tuple","","The type of the #[repr(simd)] type.",8,null],[16,"T","","The element type of the vector.",8,null],[18,"N","","The number of elements in the array.",8,null],[16,"NT","","The type: `[u32; Self::N]`.",8,null],[8,"Mask","","This trait is implemented by all mask types",null,null],[10,"test","","",9,[[]]],[8,"FromCast","","Numeric cast from `T` to `Self`.",null,null],[10,"from_cast","","Numeric cast from `T` to `Self`.",10,[[]]],[8,"Cast","","Numeric cast from `Self` to `T`.",null,null],[10,"cast","","Numeric cast from `self` to `T`.",11,[[]]],[8,"FromBits","","Safe lossless bitwise conversion from `T` to `Self`.",null,null],[10,"from_bits","","Safe lossless bitwise transmute from `T` to `Self`.",12,[[]]],[8,"IntoBits","","Safe lossless bitwise conversion from `Self` to `T`.",null,null],[10,"into_bits","","Safe lossless bitwise transmute from `self` to `T`.",13,[[]]],[14,"shuffle","","Shuffles vector elements.",null,null],[11,"from","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"into","","",14,[[]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from_cast","","",15,[[["u8x2",6]]]],[11,"from_cast","","",15,[[["m8x2",6]]]],[11,"from_cast","","",15,[[["i16x2",6]]]],[11,"from_cast","","",15,[[["u16x2",6]]]],[11,"from_cast","","",15,[[["m16x2",6]]]],[11,"from_cast","","",15,[[["i32x2",6]]]],[11,"from_cast","","",15,[[["u32x2",6]]]],[11,"from_cast","","",15,[[["f32x2",6]]]],[11,"from_cast","","",15,[[["m32x2",6]]]],[11,"from_cast","","",15,[[["i64x2",6]]]],[11,"from_cast","","",15,[[["u64x2",6]]]],[11,"from_cast","","",15,[[["f64x2",6]]]],[11,"from_cast","","",15,[[["m64x2",6]]]],[11,"from_cast","","",15,[[["i128x2",6]]]],[11,"from_cast","","",15,[[["u128x2",6]]]],[11,"from_cast","","",15,[[["m128x2",6]]]],[11,"from_cast","","",15,[[["isizex2",6]]]],[11,"from_cast","","",15,[[["usizex2",6]]]],[11,"from_cast","","",15,[[["msizex2",6]]]],[11,"from_cast","","",16,[[["i8x2",6]]]],[11,"from_cast","","",16,[[["m8x2",6]]]],[11,"from_cast","","",16,[[["i16x2",6]]]],[11,"from_cast","","",16,[[["u16x2",6]]]],[11,"from_cast","","",16,[[["m16x2",6]]]],[11,"from_cast","","",16,[[["i32x2",6]]]],[11,"from_cast","","",16,[[["u32x2",6]]]],[11,"from_cast","","",16,[[["f32x2",6]]]],[11,"from_cast","","",16,[[["m32x2",6]]]],[11,"from_cast","","",16,[[["i64x2",6]]]],[11,"from_cast","","",16,[[["u64x2",6]]]],[11,"from_cast","","",16,[[["f64x2",6]]]],[11,"from_cast","","",16,[[["m64x2",6]]]],[11,"from_cast","","",16,[[["i128x2",6]]]],[11,"from_cast","","",16,[[["u128x2",6]]]],[11,"from_cast","","",16,[[["m128x2",6]]]],[11,"from_cast","","",16,[[["isizex2",6]]]],[11,"from_cast","","",16,[[["usizex2",6]]]],[11,"from_cast","","",16,[[["msizex2",6]]]],[11,"from_cast","","",17,[[["i8x2",6]]]],[11,"from_cast","","",17,[[["u8x2",6]]]],[11,"from_cast","","",17,[[["i16x2",6]]]],[11,"from_cast","","",17,[[["u16x2",6]]]],[11,"from_cast","","",17,[[["m16x2",6]]]],[11,"from_cast","","",17,[[["i32x2",6]]]],[11,"from_cast","","",17,[[["u32x2",6]]]],[11,"from_cast","","",17,[[["f32x2",6]]]],[11,"from_cast","","",17,[[["m32x2",6]]]],[11,"from_cast","","",17,[[["i64x2",6]]]],[11,"from_cast","","",17,[[["u64x2",6]]]],[11,"from_cast","","",17,[[["f64x2",6]]]],[11,"from_cast","","",17,[[["m64x2",6]]]],[11,"from_cast","","",17,[[["i128x2",6]]]],[11,"from_cast","","",17,[[["u128x2",6]]]],[11,"from_cast","","",17,[[["m128x2",6]]]],[11,"from_cast","","",17,[[["isizex2",6]]]],[11,"from_cast","","",17,[[["usizex2",6]]]],[11,"from_cast","","",17,[[["msizex2",6]]]],[11,"from_cast","","",18,[[["u8x4",6]]]],[11,"from_cast","","",18,[[["m8x4",6]]]],[11,"from_cast","","",18,[[["i16x4",6]]]],[11,"from_cast","","",18,[[["u16x4",6]]]],[11,"from_cast","","",18,[[["m16x4",6]]]],[11,"from_cast","","",18,[[["i32x4",6]]]],[11,"from_cast","","",18,[[["u32x4",6]]]],[11,"from_cast","","",18,[[["f32x4",6]]]],[11,"from_cast","","",18,[[["m32x4",6]]]],[11,"from_cast","","",18,[[["i64x4",6]]]],[11,"from_cast","","",18,[[["u64x4",6]]]],[11,"from_cast","","",18,[[["f64x4",6]]]],[11,"from_cast","","",18,[[["m64x4",6]]]],[11,"from_cast","","",18,[[["i128x4",6]]]],[11,"from_cast","","",18,[[["u128x4",6]]]],[11,"from_cast","","",18,[[["m128x4",6]]]],[11,"from_cast","","",18,[[["isizex4",6]]]],[11,"from_cast","","",18,[[["usizex4",6]]]],[11,"from_cast","","",18,[[["msizex4",6]]]],[11,"from_cast","","",19,[[["i8x4",6]]]],[11,"from_cast","","",19,[[["m8x4",6]]]],[11,"from_cast","","",19,[[["i16x4",6]]]],[11,"from_cast","","",19,[[["u16x4",6]]]],[11,"from_cast","","",19,[[["m16x4",6]]]],[11,"from_cast","","",19,[[["i32x4",6]]]],[11,"from_cast","","",19,[[["u32x4",6]]]],[11,"from_cast","","",19,[[["f32x4",6]]]],[11,"from_cast","","",19,[[["m32x4",6]]]],[11,"from_cast","","",19,[[["i64x4",6]]]],[11,"from_cast","","",19,[[["u64x4",6]]]],[11,"from_cast","","",19,[[["f64x4",6]]]],[11,"from_cast","","",19,[[["m64x4",6]]]],[11,"from_cast","","",19,[[["i128x4",6]]]],[11,"from_cast","","",19,[[["u128x4",6]]]],[11,"from_cast","","",19,[[["m128x4",6]]]],[11,"from_cast","","",19,[[["isizex4",6]]]],[11,"from_cast","","",19,[[["usizex4",6]]]],[11,"from_cast","","",19,[[["msizex4",6]]]],[11,"from_cast","","",20,[[["i8x4",6]]]],[11,"from_cast","","",20,[[["u8x4",6]]]],[11,"from_cast","","",20,[[["i16x4",6]]]],[11,"from_cast","","",20,[[["u16x4",6]]]],[11,"from_cast","","",20,[[["m16x4",6]]]],[11,"from_cast","","",20,[[["i32x4",6]]]],[11,"from_cast","","",20,[[["u32x4",6]]]],[11,"from_cast","","",20,[[["f32x4",6]]]],[11,"from_cast","","",20,[[["m32x4",6]]]],[11,"from_cast","","",20,[[["i64x4",6]]]],[11,"from_cast","","",20,[[["u64x4",6]]]],[11,"from_cast","","",20,[[["f64x4",6]]]],[11,"from_cast","","",20,[[["m64x4",6]]]],[11,"from_cast","","",20,[[["i128x4",6]]]],[11,"from_cast","","",20,[[["u128x4",6]]]],[11,"from_cast","","",20,[[["m128x4",6]]]],[11,"from_cast","","",20,[[["isizex4",6]]]],[11,"from_cast","","",20,[[["usizex4",6]]]],[11,"from_cast","","",20,[[["msizex4",6]]]],[11,"from_cast","","",21,[[["i8x2",6]]]],[11,"from_cast","","",21,[[["u8x2",6]]]],[11,"from_cast","","",21,[[["m8x2",6]]]],[11,"from_cast","","",21,[[["u16x2",6]]]],[11,"from_cast","","",21,[[["m16x2",6]]]],[11,"from_cast","","",21,[[["i32x2",6]]]],[11,"from_cast","","",21,[[["u32x2",6]]]],[11,"from_cast","","",21,[[["f32x2",6]]]],[11,"from_cast","","",21,[[["m32x2",6]]]],[11,"from_cast","","",21,[[["i64x2",6]]]],[11,"from_cast","","",21,[[["u64x2",6]]]],[11,"from_cast","","",21,[[["f64x2",6]]]],[11,"from_cast","","",21,[[["m64x2",6]]]],[11,"from_cast","","",21,[[["i128x2",6]]]],[11,"from_cast","","",21,[[["u128x2",6]]]],[11,"from_cast","","",21,[[["m128x2",6]]]],[11,"from_cast","","",21,[[["isizex2",6]]]],[11,"from_cast","","",21,[[["usizex2",6]]]],[11,"from_cast","","",21,[[["msizex2",6]]]],[11,"from_cast","","",22,[[["i8x2",6]]]],[11,"from_cast","","",22,[[["u8x2",6]]]],[11,"from_cast","","",22,[[["m8x2",6]]]],[11,"from_cast","","",22,[[["i16x2",6]]]],[11,"from_cast","","",22,[[["m16x2",6]]]],[11,"from_cast","","",22,[[["i32x2",6]]]],[11,"from_cast","","",22,[[["u32x2",6]]]],[11,"from_cast","","",22,[[["f32x2",6]]]],[11,"from_cast","","",22,[[["m32x2",6]]]],[11,"from_cast","","",22,[[["i64x2",6]]]],[11,"from_cast","","",22,[[["u64x2",6]]]],[11,"from_cast","","",22,[[["f64x2",6]]]],[11,"from_cast","","",22,[[["m64x2",6]]]],[11,"from_cast","","",22,[[["i128x2",6]]]],[11,"from_cast","","",22,[[["u128x2",6]]]],[11,"from_cast","","",22,[[["m128x2",6]]]],[11,"from_cast","","",22,[[["isizex2",6]]]],[11,"from_cast","","",22,[[["usizex2",6]]]],[11,"from_cast","","",22,[[["msizex2",6]]]],[11,"from_cast","","",23,[[["i8x2",6]]]],[11,"from_cast","","",23,[[["u8x2",6]]]],[11,"from_cast","","",23,[[["m8x2",6]]]],[11,"from_cast","","",23,[[["i16x2",6]]]],[11,"from_cast","","",23,[[["u16x2",6]]]],[11,"from_cast","","",23,[[["i32x2",6]]]],[11,"from_cast","","",23,[[["u32x2",6]]]],[11,"from_cast","","",23,[[["f32x2",6]]]],[11,"from_cast","","",23,[[["m32x2",6]]]],[11,"from_cast","","",23,[[["i64x2",6]]]],[11,"from_cast","","",23,[[["u64x2",6]]]],[11,"from_cast","","",23,[[["f64x2",6]]]],[11,"from_cast","","",23,[[["m64x2",6]]]],[11,"from_cast","","",23,[[["i128x2",6]]]],[11,"from_cast","","",23,[[["u128x2",6]]]],[11,"from_cast","","",23,[[["m128x2",6]]]],[11,"from_cast","","",23,[[["isizex2",6]]]],[11,"from_cast","","",23,[[["usizex2",6]]]],[11,"from_cast","","",23,[[["msizex2",6]]]],[11,"from_cast","","",24,[[["u8x8",6]]]],[11,"from_cast","","",24,[[["m8x8",6]]]],[11,"from_cast","","",24,[[["i16x8",6]]]],[11,"from_cast","","",24,[[["u16x8",6]]]],[11,"from_cast","","",24,[[["m16x8",6]]]],[11,"from_cast","","",24,[[["i32x8",6]]]],[11,"from_cast","","",24,[[["u32x8",6]]]],[11,"from_cast","","",24,[[["f32x8",6]]]],[11,"from_cast","","",24,[[["m32x8",6]]]],[11,"from_cast","","",24,[[["i64x8",6]]]],[11,"from_cast","","",24,[[["u64x8",6]]]],[11,"from_cast","","",24,[[["f64x8",6]]]],[11,"from_cast","","",24,[[["m64x8",6]]]],[11,"from_cast","","",24,[[["isizex8",6]]]],[11,"from_cast","","",24,[[["usizex8",6]]]],[11,"from_cast","","",24,[[["msizex8",6]]]],[11,"from_cast","","",25,[[["i8x8",6]]]],[11,"from_cast","","",25,[[["m8x8",6]]]],[11,"from_cast","","",25,[[["i16x8",6]]]],[11,"from_cast","","",25,[[["u16x8",6]]]],[11,"from_cast","","",25,[[["m16x8",6]]]],[11,"from_cast","","",25,[[["i32x8",6]]]],[11,"from_cast","","",25,[[["u32x8",6]]]],[11,"from_cast","","",25,[[["f32x8",6]]]],[11,"from_cast","","",25,[[["m32x8",6]]]],[11,"from_cast","","",25,[[["i64x8",6]]]],[11,"from_cast","","",25,[[["u64x8",6]]]],[11,"from_cast","","",25,[[["f64x8",6]]]],[11,"from_cast","","",25,[[["m64x8",6]]]],[11,"from_cast","","",25,[[["isizex8",6]]]],[11,"from_cast","","",25,[[["usizex8",6]]]],[11,"from_cast","","",25,[[["msizex8",6]]]],[11,"from_cast","","",26,[[["i8x8",6]]]],[11,"from_cast","","",26,[[["u8x8",6]]]],[11,"from_cast","","",26,[[["i16x8",6]]]],[11,"from_cast","","",26,[[["u16x8",6]]]],[11,"from_cast","","",26,[[["m16x8",6]]]],[11,"from_cast","","",26,[[["i32x8",6]]]],[11,"from_cast","","",26,[[["u32x8",6]]]],[11,"from_cast","","",26,[[["f32x8",6]]]],[11,"from_cast","","",26,[[["m32x8",6]]]],[11,"from_cast","","",26,[[["i64x8",6]]]],[11,"from_cast","","",26,[[["u64x8",6]]]],[11,"from_cast","","",26,[[["f64x8",6]]]],[11,"from_cast","","",26,[[["m64x8",6]]]],[11,"from_cast","","",26,[[["isizex8",6]]]],[11,"from_cast","","",26,[[["usizex8",6]]]],[11,"from_cast","","",26,[[["msizex8",6]]]],[11,"from_cast","","",27,[[["i8x4",6]]]],[11,"from_cast","","",27,[[["u8x4",6]]]],[11,"from_cast","","",27,[[["m8x4",6]]]],[11,"from_cast","","",27,[[["u16x4",6]]]],[11,"from_cast","","",27,[[["m16x4",6]]]],[11,"from_cast","","",27,[[["i32x4",6]]]],[11,"from_cast","","",27,[[["u32x4",6]]]],[11,"from_cast","","",27,[[["f32x4",6]]]],[11,"from_cast","","",27,[[["m32x4",6]]]],[11,"from_cast","","",27,[[["i64x4",6]]]],[11,"from_cast","","",27,[[["u64x4",6]]]],[11,"from_cast","","",27,[[["f64x4",6]]]],[11,"from_cast","","",27,[[["m64x4",6]]]],[11,"from_cast","","",27,[[["i128x4",6]]]],[11,"from_cast","","",27,[[["u128x4",6]]]],[11,"from_cast","","",27,[[["m128x4",6]]]],[11,"from_cast","","",27,[[["isizex4",6]]]],[11,"from_cast","","",27,[[["usizex4",6]]]],[11,"from_cast","","",27,[[["msizex4",6]]]],[11,"from_cast","","",28,[[["i8x4",6]]]],[11,"from_cast","","",28,[[["u8x4",6]]]],[11,"from_cast","","",28,[[["m8x4",6]]]],[11,"from_cast","","",28,[[["i16x4",6]]]],[11,"from_cast","","",28,[[["m16x4",6]]]],[11,"from_cast","","",28,[[["i32x4",6]]]],[11,"from_cast","","",28,[[["u32x4",6]]]],[11,"from_cast","","",28,[[["f32x4",6]]]],[11,"from_cast","","",28,[[["m32x4",6]]]],[11,"from_cast","","",28,[[["i64x4",6]]]],[11,"from_cast","","",28,[[["u64x4",6]]]],[11,"from_cast","","",28,[[["f64x4",6]]]],[11,"from_cast","","",28,[[["m64x4",6]]]],[11,"from_cast","","",28,[[["i128x4",6]]]],[11,"from_cast","","",28,[[["u128x4",6]]]],[11,"from_cast","","",28,[[["m128x4",6]]]],[11,"from_cast","","",28,[[["isizex4",6]]]],[11,"from_cast","","",28,[[["usizex4",6]]]],[11,"from_cast","","",28,[[["msizex4",6]]]],[11,"from_cast","","",29,[[["i8x4",6]]]],[11,"from_cast","","",29,[[["u8x4",6]]]],[11,"from_cast","","",29,[[["m8x4",6]]]],[11,"from_cast","","",29,[[["i16x4",6]]]],[11,"from_cast","","",29,[[["u16x4",6]]]],[11,"from_cast","","",29,[[["i32x4",6]]]],[11,"from_cast","","",29,[[["u32x4",6]]]],[11,"from_cast","","",29,[[["f32x4",6]]]],[11,"from_cast","","",29,[[["m32x4",6]]]],[11,"from_cast","","",29,[[["i64x4",6]]]],[11,"from_cast","","",29,[[["u64x4",6]]]],[11,"from_cast","","",29,[[["f64x4",6]]]],[11,"from_cast","","",29,[[["m64x4",6]]]],[11,"from_cast","","",29,[[["i128x4",6]]]],[11,"from_cast","","",29,[[["u128x4",6]]]],[11,"from_cast","","",29,[[["m128x4",6]]]],[11,"from_cast","","",29,[[["isizex4",6]]]],[11,"from_cast","","",29,[[["usizex4",6]]]],[11,"from_cast","","",29,[[["msizex4",6]]]],[11,"from_cast","","",30,[[["i8x2",6]]]],[11,"from_cast","","",30,[[["u8x2",6]]]],[11,"from_cast","","",30,[[["m8x2",6]]]],[11,"from_cast","","",30,[[["i16x2",6]]]],[11,"from_cast","","",30,[[["u16x2",6]]]],[11,"from_cast","","",30,[[["m16x2",6]]]],[11,"from_cast","","",30,[[["u32x2",6]]]],[11,"from_cast","","",30,[[["f32x2",6]]]],[11,"from_cast","","",30,[[["m32x2",6]]]],[11,"from_cast","","",30,[[["i64x2",6]]]],[11,"from_cast","","",30,[[["u64x2",6]]]],[11,"from_cast","","",30,[[["f64x2",6]]]],[11,"from_cast","","",30,[[["m64x2",6]]]],[11,"from_cast","","",30,[[["i128x2",6]]]],[11,"from_cast","","",30,[[["u128x2",6]]]],[11,"from_cast","","",30,[[["m128x2",6]]]],[11,"from_cast","","",30,[[["isizex2",6]]]],[11,"from_cast","","",30,[[["usizex2",6]]]],[11,"from_cast","","",30,[[["msizex2",6]]]],[11,"from_cast","","",31,[[["i8x2",6]]]],[11,"from_cast","","",31,[[["u8x2",6]]]],[11,"from_cast","","",31,[[["m8x2",6]]]],[11,"from_cast","","",31,[[["i16x2",6]]]],[11,"from_cast","","",31,[[["u16x2",6]]]],[11,"from_cast","","",31,[[["m16x2",6]]]],[11,"from_cast","","",31,[[["i32x2",6]]]],[11,"from_cast","","",31,[[["f32x2",6]]]],[11,"from_cast","","",31,[[["m32x2",6]]]],[11,"from_cast","","",31,[[["i64x2",6]]]],[11,"from_cast","","",31,[[["u64x2",6]]]],[11,"from_cast","","",31,[[["f64x2",6]]]],[11,"from_cast","","",31,[[["m64x2",6]]]],[11,"from_cast","","",31,[[["i128x2",6]]]],[11,"from_cast","","",31,[[["u128x2",6]]]],[11,"from_cast","","",31,[[["m128x2",6]]]],[11,"from_cast","","",31,[[["isizex2",6]]]],[11,"from_cast","","",31,[[["usizex2",6]]]],[11,"from_cast","","",31,[[["msizex2",6]]]],[11,"from_cast","","",32,[[["i8x2",6]]]],[11,"from_cast","","",32,[[["u8x2",6]]]],[11,"from_cast","","",32,[[["m8x2",6]]]],[11,"from_cast","","",32,[[["i16x2",6]]]],[11,"from_cast","","",32,[[["u16x2",6]]]],[11,"from_cast","","",32,[[["m16x2",6]]]],[11,"from_cast","","",32,[[["i32x2",6]]]],[11,"from_cast","","",32,[[["u32x2",6]]]],[11,"from_cast","","",32,[[["m32x2",6]]]],[11,"from_cast","","",32,[[["i64x2",6]]]],[11,"from_cast","","",32,[[["u64x2",6]]]],[11,"from_cast","","",32,[[["f64x2",6]]]],[11,"from_cast","","",32,[[["m64x2",6]]]],[11,"from_cast","","",32,[[["i128x2",6]]]],[11,"from_cast","","",32,[[["u128x2",6]]]],[11,"from_cast","","",32,[[["m128x2",6]]]],[11,"from_cast","","",32,[[["isizex2",6]]]],[11,"from_cast","","",32,[[["usizex2",6]]]],[11,"from_cast","","",32,[[["msizex2",6]]]],[11,"from_cast","","",33,[[["i8x2",6]]]],[11,"from_cast","","",33,[[["u8x2",6]]]],[11,"from_cast","","",33,[[["m8x2",6]]]],[11,"from_cast","","",33,[[["i16x2",6]]]],[11,"from_cast","","",33,[[["u16x2",6]]]],[11,"from_cast","","",33,[[["m16x2",6]]]],[11,"from_cast","","",33,[[["i32x2",6]]]],[11,"from_cast","","",33,[[["u32x2",6]]]],[11,"from_cast","","",33,[[["f32x2",6]]]],[11,"from_cast","","",33,[[["i64x2",6]]]],[11,"from_cast","","",33,[[["u64x2",6]]]],[11,"from_cast","","",33,[[["f64x2",6]]]],[11,"from_cast","","",33,[[["m64x2",6]]]],[11,"from_cast","","",33,[[["i128x2",6]]]],[11,"from_cast","","",33,[[["u128x2",6]]]],[11,"from_cast","","",33,[[["m128x2",6]]]],[11,"from_cast","","",33,[[["isizex2",6]]]],[11,"from_cast","","",33,[[["usizex2",6]]]],[11,"from_cast","","",33,[[["msizex2",6]]]],[11,"from_cast","","",34,[[["u8x16",6]]]],[11,"from_cast","","",34,[[["m8x16",6]]]],[11,"from_cast","","",34,[[["i16x16",6]]]],[11,"from_cast","","",34,[[["u16x16",6]]]],[11,"from_cast","","",34,[[["m16x16",6]]]],[11,"from_cast","","",34,[[["i32x16",6]]]],[11,"from_cast","","",34,[[["u32x16",6]]]],[11,"from_cast","","",34,[[["f32x16",6]]]],[11,"from_cast","","",34,[[["m32x16",6]]]],[11,"from_cast","","",35,[[["i8x16",6]]]],[11,"from_cast","","",35,[[["m8x16",6]]]],[11,"from_cast","","",35,[[["i16x16",6]]]],[11,"from_cast","","",35,[[["u16x16",6]]]],[11,"from_cast","","",35,[[["m16x16",6]]]],[11,"from_cast","","",35,[[["i32x16",6]]]],[11,"from_cast","","",35,[[["u32x16",6]]]],[11,"from_cast","","",35,[[["f32x16",6]]]],[11,"from_cast","","",35,[[["m32x16",6]]]],[11,"from_cast","","",36,[[["i8x16",6]]]],[11,"from_cast","","",36,[[["u8x16",6]]]],[11,"from_cast","","",36,[[["i16x16",6]]]],[11,"from_cast","","",36,[[["u16x16",6]]]],[11,"from_cast","","",36,[[["m16x16",6]]]],[11,"from_cast","","",36,[[["i32x16",6]]]],[11,"from_cast","","",36,[[["u32x16",6]]]],[11,"from_cast","","",36,[[["f32x16",6]]]],[11,"from_cast","","",36,[[["m32x16",6]]]],[11,"from_cast","","",37,[[["i8x8",6]]]],[11,"from_cast","","",37,[[["u8x8",6]]]],[11,"from_cast","","",37,[[["m8x8",6]]]],[11,"from_cast","","",37,[[["u16x8",6]]]],[11,"from_cast","","",37,[[["m16x8",6]]]],[11,"from_cast","","",37,[[["i32x8",6]]]],[11,"from_cast","","",37,[[["u32x8",6]]]],[11,"from_cast","","",37,[[["f32x8",6]]]],[11,"from_cast","","",37,[[["m32x8",6]]]],[11,"from_cast","","",37,[[["i64x8",6]]]],[11,"from_cast","","",37,[[["u64x8",6]]]],[11,"from_cast","","",37,[[["f64x8",6]]]],[11,"from_cast","","",37,[[["m64x8",6]]]],[11,"from_cast","","",37,[[["isizex8",6]]]],[11,"from_cast","","",37,[[["usizex8",6]]]],[11,"from_cast","","",37,[[["msizex8",6]]]],[11,"from_cast","","",38,[[["i8x8",6]]]],[11,"from_cast","","",38,[[["u8x8",6]]]],[11,"from_cast","","",38,[[["m8x8",6]]]],[11,"from_cast","","",38,[[["i16x8",6]]]],[11,"from_cast","","",38,[[["m16x8",6]]]],[11,"from_cast","","",38,[[["i32x8",6]]]],[11,"from_cast","","",38,[[["u32x8",6]]]],[11,"from_cast","","",38,[[["f32x8",6]]]],[11,"from_cast","","",38,[[["m32x8",6]]]],[11,"from_cast","","",38,[[["i64x8",6]]]],[11,"from_cast","","",38,[[["u64x8",6]]]],[11,"from_cast","","",38,[[["f64x8",6]]]],[11,"from_cast","","",38,[[["m64x8",6]]]],[11,"from_cast","","",38,[[["isizex8",6]]]],[11,"from_cast","","",38,[[["usizex8",6]]]],[11,"from_cast","","",38,[[["msizex8",6]]]],[11,"from_cast","","",39,[[["i8x8",6]]]],[11,"from_cast","","",39,[[["u8x8",6]]]],[11,"from_cast","","",39,[[["m8x8",6]]]],[11,"from_cast","","",39,[[["i16x8",6]]]],[11,"from_cast","","",39,[[["u16x8",6]]]],[11,"from_cast","","",39,[[["i32x8",6]]]],[11,"from_cast","","",39,[[["u32x8",6]]]],[11,"from_cast","","",39,[[["f32x8",6]]]],[11,"from_cast","","",39,[[["m32x8",6]]]],[11,"from_cast","","",39,[[["i64x8",6]]]],[11,"from_cast","","",39,[[["u64x8",6]]]],[11,"from_cast","","",39,[[["f64x8",6]]]],[11,"from_cast","","",39,[[["m64x8",6]]]],[11,"from_cast","","",39,[[["isizex8",6]]]],[11,"from_cast","","",39,[[["usizex8",6]]]],[11,"from_cast","","",39,[[["msizex8",6]]]],[11,"from_cast","","",40,[[["i8x4",6]]]],[11,"from_cast","","",40,[[["u8x4",6]]]],[11,"from_cast","","",40,[[["m8x4",6]]]],[11,"from_cast","","",40,[[["i16x4",6]]]],[11,"from_cast","","",40,[[["u16x4",6]]]],[11,"from_cast","","",40,[[["m16x4",6]]]],[11,"from_cast","","",40,[[["u32x4",6]]]],[11,"from_cast","","",40,[[["f32x4",6]]]],[11,"from_cast","","",40,[[["m32x4",6]]]],[11,"from_cast","","",40,[[["i64x4",6]]]],[11,"from_cast","","",40,[[["u64x4",6]]]],[11,"from_cast","","",40,[[["f64x4",6]]]],[11,"from_cast","","",40,[[["m64x4",6]]]],[11,"from_cast","","",40,[[["i128x4",6]]]],[11,"from_cast","","",40,[[["u128x4",6]]]],[11,"from_cast","","",40,[[["m128x4",6]]]],[11,"from_cast","","",40,[[["isizex4",6]]]],[11,"from_cast","","",40,[[["usizex4",6]]]],[11,"from_cast","","",40,[[["msizex4",6]]]],[11,"from_cast","","",41,[[["i8x4",6]]]],[11,"from_cast","","",41,[[["u8x4",6]]]],[11,"from_cast","","",41,[[["m8x4",6]]]],[11,"from_cast","","",41,[[["i16x4",6]]]],[11,"from_cast","","",41,[[["u16x4",6]]]],[11,"from_cast","","",41,[[["m16x4",6]]]],[11,"from_cast","","",41,[[["i32x4",6]]]],[11,"from_cast","","",41,[[["f32x4",6]]]],[11,"from_cast","","",41,[[["m32x4",6]]]],[11,"from_cast","","",41,[[["i64x4",6]]]],[11,"from_cast","","",41,[[["u64x4",6]]]],[11,"from_cast","","",41,[[["f64x4",6]]]],[11,"from_cast","","",41,[[["m64x4",6]]]],[11,"from_cast","","",41,[[["i128x4",6]]]],[11,"from_cast","","",41,[[["u128x4",6]]]],[11,"from_cast","","",41,[[["m128x4",6]]]],[11,"from_cast","","",41,[[["isizex4",6]]]],[11,"from_cast","","",41,[[["usizex4",6]]]],[11,"from_cast","","",41,[[["msizex4",6]]]],[11,"from_cast","","",42,[[["i8x4",6]]]],[11,"from_cast","","",42,[[["u8x4",6]]]],[11,"from_cast","","",42,[[["m8x4",6]]]],[11,"from_cast","","",42,[[["i16x4",6]]]],[11,"from_cast","","",42,[[["u16x4",6]]]],[11,"from_cast","","",42,[[["m16x4",6]]]],[11,"from_cast","","",42,[[["i32x4",6]]]],[11,"from_cast","","",42,[[["u32x4",6]]]],[11,"from_cast","","",42,[[["m32x4",6]]]],[11,"from_cast","","",42,[[["i64x4",6]]]],[11,"from_cast","","",42,[[["u64x4",6]]]],[11,"from_cast","","",42,[[["f64x4",6]]]],[11,"from_cast","","",42,[[["m64x4",6]]]],[11,"from_cast","","",42,[[["i128x4",6]]]],[11,"from_cast","","",42,[[["u128x4",6]]]],[11,"from_cast","","",42,[[["m128x4",6]]]],[11,"from_cast","","",42,[[["isizex4",6]]]],[11,"from_cast","","",42,[[["usizex4",6]]]],[11,"from_cast","","",42,[[["msizex4",6]]]],[11,"from_cast","","",43,[[["i8x4",6]]]],[11,"from_cast","","",43,[[["u8x4",6]]]],[11,"from_cast","","",43,[[["m8x4",6]]]],[11,"from_cast","","",43,[[["i16x4",6]]]],[11,"from_cast","","",43,[[["u16x4",6]]]],[11,"from_cast","","",43,[[["m16x4",6]]]],[11,"from_cast","","",43,[[["i32x4",6]]]],[11,"from_cast","","",43,[[["u32x4",6]]]],[11,"from_cast","","",43,[[["f32x4",6]]]],[11,"from_cast","","",43,[[["i64x4",6]]]],[11,"from_cast","","",43,[[["u64x4",6]]]],[11,"from_cast","","",43,[[["f64x4",6]]]],[11,"from_cast","","",43,[[["m64x4",6]]]],[11,"from_cast","","",43,[[["i128x4",6]]]],[11,"from_cast","","",43,[[["u128x4",6]]]],[11,"from_cast","","",43,[[["m128x4",6]]]],[11,"from_cast","","",43,[[["isizex4",6]]]],[11,"from_cast","","",43,[[["usizex4",6]]]],[11,"from_cast","","",43,[[["msizex4",6]]]],[11,"from_cast","","",44,[[["i8x2",6]]]],[11,"from_cast","","",44,[[["u8x2",6]]]],[11,"from_cast","","",44,[[["m8x2",6]]]],[11,"from_cast","","",44,[[["i16x2",6]]]],[11,"from_cast","","",44,[[["u16x2",6]]]],[11,"from_cast","","",44,[[["m16x2",6]]]],[11,"from_cast","","",44,[[["i32x2",6]]]],[11,"from_cast","","",44,[[["u32x2",6]]]],[11,"from_cast","","",44,[[["f32x2",6]]]],[11,"from_cast","","",44,[[["m32x2",6]]]],[11,"from_cast","","",44,[[["u64x2",6]]]],[11,"from_cast","","",44,[[["f64x2",6]]]],[11,"from_cast","","",44,[[["m64x2",6]]]],[11,"from_cast","","",44,[[["i128x2",6]]]],[11,"from_cast","","",44,[[["u128x2",6]]]],[11,"from_cast","","",44,[[["m128x2",6]]]],[11,"from_cast","","",44,[[["isizex2",6]]]],[11,"from_cast","","",44,[[["usizex2",6]]]],[11,"from_cast","","",44,[[["msizex2",6]]]],[11,"from_cast","","",45,[[["i8x2",6]]]],[11,"from_cast","","",45,[[["u8x2",6]]]],[11,"from_cast","","",45,[[["m8x2",6]]]],[11,"from_cast","","",45,[[["i16x2",6]]]],[11,"from_cast","","",45,[[["u16x2",6]]]],[11,"from_cast","","",45,[[["m16x2",6]]]],[11,"from_cast","","",45,[[["i32x2",6]]]],[11,"from_cast","","",45,[[["u32x2",6]]]],[11,"from_cast","","",45,[[["f32x2",6]]]],[11,"from_cast","","",45,[[["m32x2",6]]]],[11,"from_cast","","",45,[[["i64x2",6]]]],[11,"from_cast","","",45,[[["f64x2",6]]]],[11,"from_cast","","",45,[[["m64x2",6]]]],[11,"from_cast","","",45,[[["i128x2",6]]]],[11,"from_cast","","",45,[[["u128x2",6]]]],[11,"from_cast","","",45,[[["m128x2",6]]]],[11,"from_cast","","",45,[[["isizex2",6]]]],[11,"from_cast","","",45,[[["usizex2",6]]]],[11,"from_cast","","",45,[[["msizex2",6]]]],[11,"from_cast","","",46,[[["i8x2",6]]]],[11,"from_cast","","",46,[[["u8x2",6]]]],[11,"from_cast","","",46,[[["m8x2",6]]]],[11,"from_cast","","",46,[[["i16x2",6]]]],[11,"from_cast","","",46,[[["u16x2",6]]]],[11,"from_cast","","",46,[[["m16x2",6]]]],[11,"from_cast","","",46,[[["i32x2",6]]]],[11,"from_cast","","",46,[[["u32x2",6]]]],[11,"from_cast","","",46,[[["f32x2",6]]]],[11,"from_cast","","",46,[[["m32x2",6]]]],[11,"from_cast","","",46,[[["i64x2",6]]]],[11,"from_cast","","",46,[[["u64x2",6]]]],[11,"from_cast","","",46,[[["m64x2",6]]]],[11,"from_cast","","",46,[[["i128x2",6]]]],[11,"from_cast","","",46,[[["u128x2",6]]]],[11,"from_cast","","",46,[[["m128x2",6]]]],[11,"from_cast","","",46,[[["isizex2",6]]]],[11,"from_cast","","",46,[[["usizex2",6]]]],[11,"from_cast","","",46,[[["msizex2",6]]]],[11,"from_cast","","",47,[[["i8x2",6]]]],[11,"from_cast","","",47,[[["u8x2",6]]]],[11,"from_cast","","",47,[[["m8x2",6]]]],[11,"from_cast","","",47,[[["i16x2",6]]]],[11,"from_cast","","",47,[[["u16x2",6]]]],[11,"from_cast","","",47,[[["m16x2",6]]]],[11,"from_cast","","",47,[[["i32x2",6]]]],[11,"from_cast","","",47,[[["u32x2",6]]]],[11,"from_cast","","",47,[[["f32x2",6]]]],[11,"from_cast","","",47,[[["m32x2",6]]]],[11,"from_cast","","",47,[[["i64x2",6]]]],[11,"from_cast","","",47,[[["u64x2",6]]]],[11,"from_cast","","",47,[[["f64x2",6]]]],[11,"from_cast","","",47,[[["i128x2",6]]]],[11,"from_cast","","",47,[[["u128x2",6]]]],[11,"from_cast","","",47,[[["m128x2",6]]]],[11,"from_cast","","",47,[[["isizex2",6]]]],[11,"from_cast","","",47,[[["usizex2",6]]]],[11,"from_cast","","",47,[[["msizex2",6]]]],[11,"from_cast","","",48,[[["i8x2",6]]]],[11,"from_cast","","",48,[[["u8x2",6]]]],[11,"from_cast","","",48,[[["m8x2",6]]]],[11,"from_cast","","",48,[[["i16x2",6]]]],[11,"from_cast","","",48,[[["u16x2",6]]]],[11,"from_cast","","",48,[[["m16x2",6]]]],[11,"from_cast","","",48,[[["i32x2",6]]]],[11,"from_cast","","",48,[[["u32x2",6]]]],[11,"from_cast","","",48,[[["f32x2",6]]]],[11,"from_cast","","",48,[[["m32x2",6]]]],[11,"from_cast","","",48,[[["i64x2",6]]]],[11,"from_cast","","",48,[[["u64x2",6]]]],[11,"from_cast","","",48,[[["f64x2",6]]]],[11,"from_cast","","",48,[[["m64x2",6]]]],[11,"from_cast","","",48,[[["i128x2",6]]]],[11,"from_cast","","",48,[[["u128x2",6]]]],[11,"from_cast","","",48,[[["m128x2",6]]]],[11,"from_cast","","",48,[[["usizex2",6]]]],[11,"from_cast","","",48,[[["msizex2",6]]]],[11,"from_cast","","",49,[[["i8x2",6]]]],[11,"from_cast","","",49,[[["u8x2",6]]]],[11,"from_cast","","",49,[[["m8x2",6]]]],[11,"from_cast","","",49,[[["i16x2",6]]]],[11,"from_cast","","",49,[[["u16x2",6]]]],[11,"from_cast","","",49,[[["m16x2",6]]]],[11,"from_cast","","",49,[[["i32x2",6]]]],[11,"from_cast","","",49,[[["u32x2",6]]]],[11,"from_cast","","",49,[[["f32x2",6]]]],[11,"from_cast","","",49,[[["m32x2",6]]]],[11,"from_cast","","",49,[[["i64x2",6]]]],[11,"from_cast","","",49,[[["u64x2",6]]]],[11,"from_cast","","",49,[[["f64x2",6]]]],[11,"from_cast","","",49,[[["m64x2",6]]]],[11,"from_cast","","",49,[[["i128x2",6]]]],[11,"from_cast","","",49,[[["u128x2",6]]]],[11,"from_cast","","",49,[[["m128x2",6]]]],[11,"from_cast","","",49,[[["isizex2",6]]]],[11,"from_cast","","",49,[[["msizex2",6]]]],[11,"from_cast","","",50,[[["i8x2",6]]]],[11,"from_cast","","",50,[[["u8x2",6]]]],[11,"from_cast","","",50,[[["m8x2",6]]]],[11,"from_cast","","",50,[[["i16x2",6]]]],[11,"from_cast","","",50,[[["u16x2",6]]]],[11,"from_cast","","",50,[[["m16x2",6]]]],[11,"from_cast","","",50,[[["i32x2",6]]]],[11,"from_cast","","",50,[[["u32x2",6]]]],[11,"from_cast","","",50,[[["f32x2",6]]]],[11,"from_cast","","",50,[[["m32x2",6]]]],[11,"from_cast","","",50,[[["i64x2",6]]]],[11,"from_cast","","",50,[[["u64x2",6]]]],[11,"from_cast","","",50,[[["f64x2",6]]]],[11,"from_cast","","",50,[[["m64x2",6]]]],[11,"from_cast","","",50,[[["i128x2",6]]]],[11,"from_cast","","",50,[[["u128x2",6]]]],[11,"from_cast","","",50,[[["m128x2",6]]]],[11,"from_cast","","",50,[[["isizex2",6]]]],[11,"from_cast","","",50,[[["usizex2",6]]]],[11,"from_cast","","",51,[[["u128x1",6]]]],[11,"from_cast","","",51,[[["m128x1",6]]]],[11,"from_cast","","",52,[[["i128x1",6]]]],[11,"from_cast","","",52,[[["m128x1",6]]]],[11,"from_cast","","",53,[[["i128x1",6]]]],[11,"from_cast","","",53,[[["u128x1",6]]]],[11,"from_cast","","",54,[[["u8x32",6]]]],[11,"from_cast","","",54,[[["m8x32",6]]]],[11,"from_cast","","",54,[[["i16x32",6]]]],[11,"from_cast","","",54,[[["u16x32",6]]]],[11,"from_cast","","",54,[[["m16x32",6]]]],[11,"from_cast","","",55,[[["i8x32",6]]]],[11,"from_cast","","",55,[[["m8x32",6]]]],[11,"from_cast","","",55,[[["i16x32",6]]]],[11,"from_cast","","",55,[[["u16x32",6]]]],[11,"from_cast","","",55,[[["m16x32",6]]]],[11,"from_cast","","",56,[[["i8x32",6]]]],[11,"from_cast","","",56,[[["u8x32",6]]]],[11,"from_cast","","",56,[[["i16x32",6]]]],[11,"from_cast","","",56,[[["u16x32",6]]]],[11,"from_cast","","",56,[[["m16x32",6]]]],[11,"from_cast","","",57,[[["i8x16",6]]]],[11,"from_cast","","",57,[[["u8x16",6]]]],[11,"from_cast","","",57,[[["m8x16",6]]]],[11,"from_cast","","",57,[[["u16x16",6]]]],[11,"from_cast","","",57,[[["m16x16",6]]]],[11,"from_cast","","",57,[[["i32x16",6]]]],[11,"from_cast","","",57,[[["u32x16",6]]]],[11,"from_cast","","",57,[[["f32x16",6]]]],[11,"from_cast","","",57,[[["m32x16",6]]]],[11,"from_cast","","",58,[[["i8x16",6]]]],[11,"from_cast","","",58,[[["u8x16",6]]]],[11,"from_cast","","",58,[[["m8x16",6]]]],[11,"from_cast","","",58,[[["i16x16",6]]]],[11,"from_cast","","",58,[[["m16x16",6]]]],[11,"from_cast","","",58,[[["i32x16",6]]]],[11,"from_cast","","",58,[[["u32x16",6]]]],[11,"from_cast","","",58,[[["f32x16",6]]]],[11,"from_cast","","",58,[[["m32x16",6]]]],[11,"from_cast","","",59,[[["i8x16",6]]]],[11,"from_cast","","",59,[[["u8x16",6]]]],[11,"from_cast","","",59,[[["m8x16",6]]]],[11,"from_cast","","",59,[[["i16x16",6]]]],[11,"from_cast","","",59,[[["u16x16",6]]]],[11,"from_cast","","",59,[[["i32x16",6]]]],[11,"from_cast","","",59,[[["u32x16",6]]]],[11,"from_cast","","",59,[[["f32x16",6]]]],[11,"from_cast","","",59,[[["m32x16",6]]]],[11,"from_cast","","",60,[[["i8x8",6]]]],[11,"from_cast","","",60,[[["u8x8",6]]]],[11,"from_cast","","",60,[[["m8x8",6]]]],[11,"from_cast","","",60,[[["i16x8",6]]]],[11,"from_cast","","",60,[[["u16x8",6]]]],[11,"from_cast","","",60,[[["m16x8",6]]]],[11,"from_cast","","",60,[[["u32x8",6]]]],[11,"from_cast","","",60,[[["f32x8",6]]]],[11,"from_cast","","",60,[[["m32x8",6]]]],[11,"from_cast","","",60,[[["i64x8",6]]]],[11,"from_cast","","",60,[[["u64x8",6]]]],[11,"from_cast","","",60,[[["f64x8",6]]]],[11,"from_cast","","",60,[[["m64x8",6]]]],[11,"from_cast","","",60,[[["isizex8",6]]]],[11,"from_cast","","",60,[[["usizex8",6]]]],[11,"from_cast","","",60,[[["msizex8",6]]]],[11,"from_cast","","",61,[[["i8x8",6]]]],[11,"from_cast","","",61,[[["u8x8",6]]]],[11,"from_cast","","",61,[[["m8x8",6]]]],[11,"from_cast","","",61,[[["i16x8",6]]]],[11,"from_cast","","",61,[[["u16x8",6]]]],[11,"from_cast","","",61,[[["m16x8",6]]]],[11,"from_cast","","",61,[[["i32x8",6]]]],[11,"from_cast","","",61,[[["f32x8",6]]]],[11,"from_cast","","",61,[[["m32x8",6]]]],[11,"from_cast","","",61,[[["i64x8",6]]]],[11,"from_cast","","",61,[[["u64x8",6]]]],[11,"from_cast","","",61,[[["f64x8",6]]]],[11,"from_cast","","",61,[[["m64x8",6]]]],[11,"from_cast","","",61,[[["isizex8",6]]]],[11,"from_cast","","",61,[[["usizex8",6]]]],[11,"from_cast","","",61,[[["msizex8",6]]]],[11,"from_cast","","",62,[[["i8x8",6]]]],[11,"from_cast","","",62,[[["u8x8",6]]]],[11,"from_cast","","",62,[[["m8x8",6]]]],[11,"from_cast","","",62,[[["i16x8",6]]]],[11,"from_cast","","",62,[[["u16x8",6]]]],[11,"from_cast","","",62,[[["m16x8",6]]]],[11,"from_cast","","",62,[[["i32x8",6]]]],[11,"from_cast","","",62,[[["u32x8",6]]]],[11,"from_cast","","",62,[[["m32x8",6]]]],[11,"from_cast","","",62,[[["i64x8",6]]]],[11,"from_cast","","",62,[[["u64x8",6]]]],[11,"from_cast","","",62,[[["f64x8",6]]]],[11,"from_cast","","",62,[[["m64x8",6]]]],[11,"from_cast","","",62,[[["isizex8",6]]]],[11,"from_cast","","",62,[[["usizex8",6]]]],[11,"from_cast","","",62,[[["msizex8",6]]]],[11,"from_cast","","",63,[[["i8x8",6]]]],[11,"from_cast","","",63,[[["u8x8",6]]]],[11,"from_cast","","",63,[[["m8x8",6]]]],[11,"from_cast","","",63,[[["i16x8",6]]]],[11,"from_cast","","",63,[[["u16x8",6]]]],[11,"from_cast","","",63,[[["m16x8",6]]]],[11,"from_cast","","",63,[[["i32x8",6]]]],[11,"from_cast","","",63,[[["u32x8",6]]]],[11,"from_cast","","",63,[[["f32x8",6]]]],[11,"from_cast","","",63,[[["i64x8",6]]]],[11,"from_cast","","",63,[[["u64x8",6]]]],[11,"from_cast","","",63,[[["f64x8",6]]]],[11,"from_cast","","",63,[[["m64x8",6]]]],[11,"from_cast","","",63,[[["isizex8",6]]]],[11,"from_cast","","",63,[[["usizex8",6]]]],[11,"from_cast","","",63,[[["msizex8",6]]]],[11,"from_cast","","",64,[[["i8x4",6]]]],[11,"from_cast","","",64,[[["u8x4",6]]]],[11,"from_cast","","",64,[[["m8x4",6]]]],[11,"from_cast","","",64,[[["i16x4",6]]]],[11,"from_cast","","",64,[[["u16x4",6]]]],[11,"from_cast","","",64,[[["m16x4",6]]]],[11,"from_cast","","",64,[[["i32x4",6]]]],[11,"from_cast","","",64,[[["u32x4",6]]]],[11,"from_cast","","",64,[[["f32x4",6]]]],[11,"from_cast","","",64,[[["m32x4",6]]]],[11,"from_cast","","",64,[[["u64x4",6]]]],[11,"from_cast","","",64,[[["f64x4",6]]]],[11,"from_cast","","",64,[[["m64x4",6]]]],[11,"from_cast","","",64,[[["i128x4",6]]]],[11,"from_cast","","",64,[[["u128x4",6]]]],[11,"from_cast","","",64,[[["m128x4",6]]]],[11,"from_cast","","",64,[[["isizex4",6]]]],[11,"from_cast","","",64,[[["usizex4",6]]]],[11,"from_cast","","",64,[[["msizex4",6]]]],[11,"from_cast","","",65,[[["i8x4",6]]]],[11,"from_cast","","",65,[[["u8x4",6]]]],[11,"from_cast","","",65,[[["m8x4",6]]]],[11,"from_cast","","",65,[[["i16x4",6]]]],[11,"from_cast","","",65,[[["u16x4",6]]]],[11,"from_cast","","",65,[[["m16x4",6]]]],[11,"from_cast","","",65,[[["i32x4",6]]]],[11,"from_cast","","",65,[[["u32x4",6]]]],[11,"from_cast","","",65,[[["f32x4",6]]]],[11,"from_cast","","",65,[[["m32x4",6]]]],[11,"from_cast","","",65,[[["i64x4",6]]]],[11,"from_cast","","",65,[[["f64x4",6]]]],[11,"from_cast","","",65,[[["m64x4",6]]]],[11,"from_cast","","",65,[[["i128x4",6]]]],[11,"from_cast","","",65,[[["u128x4",6]]]],[11,"from_cast","","",65,[[["m128x4",6]]]],[11,"from_cast","","",65,[[["isizex4",6]]]],[11,"from_cast","","",65,[[["usizex4",6]]]],[11,"from_cast","","",65,[[["msizex4",6]]]],[11,"from_cast","","",66,[[["i8x4",6]]]],[11,"from_cast","","",66,[[["u8x4",6]]]],[11,"from_cast","","",66,[[["m8x4",6]]]],[11,"from_cast","","",66,[[["i16x4",6]]]],[11,"from_cast","","",66,[[["u16x4",6]]]],[11,"from_cast","","",66,[[["m16x4",6]]]],[11,"from_cast","","",66,[[["i32x4",6]]]],[11,"from_cast","","",66,[[["u32x4",6]]]],[11,"from_cast","","",66,[[["f32x4",6]]]],[11,"from_cast","","",66,[[["m32x4",6]]]],[11,"from_cast","","",66,[[["i64x4",6]]]],[11,"from_cast","","",66,[[["u64x4",6]]]],[11,"from_cast","","",66,[[["m64x4",6]]]],[11,"from_cast","","",66,[[["i128x4",6]]]],[11,"from_cast","","",66,[[["u128x4",6]]]],[11,"from_cast","","",66,[[["m128x4",6]]]],[11,"from_cast","","",66,[[["isizex4",6]]]],[11,"from_cast","","",66,[[["usizex4",6]]]],[11,"from_cast","","",66,[[["msizex4",6]]]],[11,"from_cast","","",67,[[["i8x4",6]]]],[11,"from_cast","","",67,[[["u8x4",6]]]],[11,"from_cast","","",67,[[["m8x4",6]]]],[11,"from_cast","","",67,[[["i16x4",6]]]],[11,"from_cast","","",67,[[["u16x4",6]]]],[11,"from_cast","","",67,[[["m16x4",6]]]],[11,"from_cast","","",67,[[["i32x4",6]]]],[11,"from_cast","","",67,[[["u32x4",6]]]],[11,"from_cast","","",67,[[["f32x4",6]]]],[11,"from_cast","","",67,[[["m32x4",6]]]],[11,"from_cast","","",67,[[["i64x4",6]]]],[11,"from_cast","","",67,[[["u64x4",6]]]],[11,"from_cast","","",67,[[["f64x4",6]]]],[11,"from_cast","","",67,[[["i128x4",6]]]],[11,"from_cast","","",67,[[["u128x4",6]]]],[11,"from_cast","","",67,[[["m128x4",6]]]],[11,"from_cast","","",67,[[["isizex4",6]]]],[11,"from_cast","","",67,[[["usizex4",6]]]],[11,"from_cast","","",67,[[["msizex4",6]]]],[11,"from_cast","","",68,[[["i8x2",6]]]],[11,"from_cast","","",68,[[["u8x2",6]]]],[11,"from_cast","","",68,[[["m8x2",6]]]],[11,"from_cast","","",68,[[["i16x2",6]]]],[11,"from_cast","","",68,[[["u16x2",6]]]],[11,"from_cast","","",68,[[["m16x2",6]]]],[11,"from_cast","","",68,[[["i32x2",6]]]],[11,"from_cast","","",68,[[["u32x2",6]]]],[11,"from_cast","","",68,[[["f32x2",6]]]],[11,"from_cast","","",68,[[["m32x2",6]]]],[11,"from_cast","","",68,[[["i64x2",6]]]],[11,"from_cast","","",68,[[["u64x2",6]]]],[11,"from_cast","","",68,[[["f64x2",6]]]],[11,"from_cast","","",68,[[["m64x2",6]]]],[11,"from_cast","","",68,[[["u128x2",6]]]],[11,"from_cast","","",68,[[["m128x2",6]]]],[11,"from_cast","","",68,[[["isizex2",6]]]],[11,"from_cast","","",68,[[["usizex2",6]]]],[11,"from_cast","","",68,[[["msizex2",6]]]],[11,"from_cast","","",69,[[["i8x2",6]]]],[11,"from_cast","","",69,[[["u8x2",6]]]],[11,"from_cast","","",69,[[["m8x2",6]]]],[11,"from_cast","","",69,[[["i16x2",6]]]],[11,"from_cast","","",69,[[["u16x2",6]]]],[11,"from_cast","","",69,[[["m16x2",6]]]],[11,"from_cast","","",69,[[["i32x2",6]]]],[11,"from_cast","","",69,[[["u32x2",6]]]],[11,"from_cast","","",69,[[["f32x2",6]]]],[11,"from_cast","","",69,[[["m32x2",6]]]],[11,"from_cast","","",69,[[["i64x2",6]]]],[11,"from_cast","","",69,[[["u64x2",6]]]],[11,"from_cast","","",69,[[["f64x2",6]]]],[11,"from_cast","","",69,[[["m64x2",6]]]],[11,"from_cast","","",69,[[["i128x2",6]]]],[11,"from_cast","","",69,[[["m128x2",6]]]],[11,"from_cast","","",69,[[["isizex2",6]]]],[11,"from_cast","","",69,[[["usizex2",6]]]],[11,"from_cast","","",69,[[["msizex2",6]]]],[11,"from_cast","","",70,[[["i8x2",6]]]],[11,"from_cast","","",70,[[["u8x2",6]]]],[11,"from_cast","","",70,[[["m8x2",6]]]],[11,"from_cast","","",70,[[["i16x2",6]]]],[11,"from_cast","","",70,[[["u16x2",6]]]],[11,"from_cast","","",70,[[["m16x2",6]]]],[11,"from_cast","","",70,[[["i32x2",6]]]],[11,"from_cast","","",70,[[["u32x2",6]]]],[11,"from_cast","","",70,[[["f32x2",6]]]],[11,"from_cast","","",70,[[["m32x2",6]]]],[11,"from_cast","","",70,[[["i64x2",6]]]],[11,"from_cast","","",70,[[["u64x2",6]]]],[11,"from_cast","","",70,[[["m64x2",6]]]],[11,"from_cast","","",70,[[["f64x2",6]]]],[11,"from_cast","","",70,[[["i128x2",6]]]],[11,"from_cast","","",70,[[["u128x2",6]]]],[11,"from_cast","","",70,[[["isizex2",6]]]],[11,"from_cast","","",70,[[["usizex2",6]]]],[11,"from_cast","","",70,[[["msizex2",6]]]],[11,"from_cast","","",71,[[["i8x4",6]]]],[11,"from_cast","","",71,[[["u8x4",6]]]],[11,"from_cast","","",71,[[["m8x4",6]]]],[11,"from_cast","","",71,[[["i16x4",6]]]],[11,"from_cast","","",71,[[["u16x4",6]]]],[11,"from_cast","","",71,[[["m16x4",6]]]],[11,"from_cast","","",71,[[["i32x4",6]]]],[11,"from_cast","","",71,[[["u32x4",6]]]],[11,"from_cast","","",71,[[["f32x4",6]]]],[11,"from_cast","","",71,[[["m32x4",6]]]],[11,"from_cast","","",71,[[["i64x4",6]]]],[11,"from_cast","","",71,[[["u64x4",6]]]],[11,"from_cast","","",71,[[["f64x4",6]]]],[11,"from_cast","","",71,[[["m64x4",6]]]],[11,"from_cast","","",71,[[["i128x4",6]]]],[11,"from_cast","","",71,[[["u128x4",6]]]],[11,"from_cast","","",71,[[["m128x4",6]]]],[11,"from_cast","","",71,[[["usizex4",6]]]],[11,"from_cast","","",71,[[["msizex4",6]]]],[11,"from_cast","","",72,[[["i8x4",6]]]],[11,"from_cast","","",72,[[["u8x4",6]]]],[11,"from_cast","","",72,[[["m8x4",6]]]],[11,"from_cast","","",72,[[["i16x4",6]]]],[11,"from_cast","","",72,[[["u16x4",6]]]],[11,"from_cast","","",72,[[["m16x4",6]]]],[11,"from_cast","","",72,[[["i32x4",6]]]],[11,"from_cast","","",72,[[["u32x4",6]]]],[11,"from_cast","","",72,[[["f32x4",6]]]],[11,"from_cast","","",72,[[["m32x4",6]]]],[11,"from_cast","","",72,[[["i64x4",6]]]],[11,"from_cast","","",72,[[["u64x4",6]]]],[11,"from_cast","","",72,[[["f64x4",6]]]],[11,"from_cast","","",72,[[["m64x4",6]]]],[11,"from_cast","","",72,[[["i128x4",6]]]],[11,"from_cast","","",72,[[["u128x4",6]]]],[11,"from_cast","","",72,[[["m128x4",6]]]],[11,"from_cast","","",72,[[["isizex4",6]]]],[11,"from_cast","","",72,[[["msizex4",6]]]],[11,"from_cast","","",73,[[["i8x4",6]]]],[11,"from_cast","","",73,[[["u8x4",6]]]],[11,"from_cast","","",73,[[["m8x4",6]]]],[11,"from_cast","","",73,[[["i16x4",6]]]],[11,"from_cast","","",73,[[["u16x4",6]]]],[11,"from_cast","","",73,[[["m16x4",6]]]],[11,"from_cast","","",73,[[["i32x4",6]]]],[11,"from_cast","","",73,[[["u32x4",6]]]],[11,"from_cast","","",73,[[["f32x4",6]]]],[11,"from_cast","","",73,[[["m32x4",6]]]],[11,"from_cast","","",73,[[["i64x4",6]]]],[11,"from_cast","","",73,[[["u64x4",6]]]],[11,"from_cast","","",73,[[["f64x4",6]]]],[11,"from_cast","","",73,[[["m64x4",6]]]],[11,"from_cast","","",73,[[["i128x4",6]]]],[11,"from_cast","","",73,[[["u128x4",6]]]],[11,"from_cast","","",73,[[["m128x4",6]]]],[11,"from_cast","","",73,[[["isizex4",6]]]],[11,"from_cast","","",73,[[["usizex4",6]]]],[11,"from_cast","","",74,[[["u8x64",6]]]],[11,"from_cast","","",74,[[["m8x64",6]]]],[11,"from_cast","","",75,[[["i8x64",6]]]],[11,"from_cast","","",75,[[["m8x64",6]]]],[11,"from_cast","","",76,[[["i8x64",6]]]],[11,"from_cast","","",76,[[["u8x64",6]]]],[11,"from_cast","","",77,[[["i8x32",6]]]],[11,"from_cast","","",77,[[["u8x32",6]]]],[11,"from_cast","","",77,[[["m8x32",6]]]],[11,"from_cast","","",77,[[["u16x32",6]]]],[11,"from_cast","","",77,[[["m16x32",6]]]],[11,"from_cast","","",78,[[["i8x32",6]]]],[11,"from_cast","","",78,[[["u8x32",6]]]],[11,"from_cast","","",78,[[["m8x32",6]]]],[11,"from_cast","","",78,[[["i16x32",6]]]],[11,"from_cast","","",78,[[["m16x32",6]]]],[11,"from_cast","","",79,[[["i8x32",6]]]],[11,"from_cast","","",79,[[["u8x32",6]]]],[11,"from_cast","","",79,[[["m8x32",6]]]],[11,"from_cast","","",79,[[["i16x32",6]]]],[11,"from_cast","","",79,[[["u16x32",6]]]],[11,"from_cast","","",80,[[["i8x16",6]]]],[11,"from_cast","","",80,[[["u8x16",6]]]],[11,"from_cast","","",80,[[["m8x16",6]]]],[11,"from_cast","","",80,[[["i16x16",6]]]],[11,"from_cast","","",80,[[["u16x16",6]]]],[11,"from_cast","","",80,[[["m16x16",6]]]],[11,"from_cast","","",80,[[["u32x16",6]]]],[11,"from_cast","","",80,[[["f32x16",6]]]],[11,"from_cast","","",80,[[["m32x16",6]]]],[11,"from_cast","","",81,[[["i8x16",6]]]],[11,"from_cast","","",81,[[["u8x16",6]]]],[11,"from_cast","","",81,[[["m8x16",6]]]],[11,"from_cast","","",81,[[["i16x16",6]]]],[11,"from_cast","","",81,[[["u16x16",6]]]],[11,"from_cast","","",81,[[["m16x16",6]]]],[11,"from_cast","","",81,[[["i32x16",6]]]],[11,"from_cast","","",81,[[["f32x16",6]]]],[11,"from_cast","","",81,[[["m32x16",6]]]],[11,"from_cast","","",82,[[["i8x16",6]]]],[11,"from_cast","","",82,[[["u8x16",6]]]],[11,"from_cast","","",82,[[["m8x16",6]]]],[11,"from_cast","","",82,[[["i16x16",6]]]],[11,"from_cast","","",82,[[["u16x16",6]]]],[11,"from_cast","","",82,[[["m16x16",6]]]],[11,"from_cast","","",82,[[["i32x16",6]]]],[11,"from_cast","","",82,[[["u32x16",6]]]],[11,"from_cast","","",82,[[["m32x16",6]]]],[11,"from_cast","","",83,[[["i8x16",6]]]],[11,"from_cast","","",83,[[["u8x16",6]]]],[11,"from_cast","","",83,[[["m8x16",6]]]],[11,"from_cast","","",83,[[["i16x16",6]]]],[11,"from_cast","","",83,[[["u16x16",6]]]],[11,"from_cast","","",83,[[["m16x16",6]]]],[11,"from_cast","","",83,[[["i32x16",6]]]],[11,"from_cast","","",83,[[["u32x16",6]]]],[11,"from_cast","","",83,[[["f32x16",6]]]],[11,"from_cast","","",84,[[["i8x8",6]]]],[11,"from_cast","","",84,[[["u8x8",6]]]],[11,"from_cast","","",84,[[["m8x8",6]]]],[11,"from_cast","","",84,[[["i16x8",6]]]],[11,"from_cast","","",84,[[["u16x8",6]]]],[11,"from_cast","","",84,[[["m16x8",6]]]],[11,"from_cast","","",84,[[["i32x8",6]]]],[11,"from_cast","","",84,[[["u32x8",6]]]],[11,"from_cast","","",84,[[["f32x8",6]]]],[11,"from_cast","","",84,[[["m32x8",6]]]],[11,"from_cast","","",84,[[["u64x8",6]]]],[11,"from_cast","","",84,[[["f64x8",6]]]],[11,"from_cast","","",84,[[["m64x8",6]]]],[11,"from_cast","","",84,[[["isizex8",6]]]],[11,"from_cast","","",84,[[["usizex8",6]]]],[11,"from_cast","","",84,[[["msizex8",6]]]],[11,"from_cast","","",85,[[["i8x8",6]]]],[11,"from_cast","","",85,[[["u8x8",6]]]],[11,"from_cast","","",85,[[["m8x8",6]]]],[11,"from_cast","","",85,[[["i16x8",6]]]],[11,"from_cast","","",85,[[["u16x8",6]]]],[11,"from_cast","","",85,[[["m16x8",6]]]],[11,"from_cast","","",85,[[["i32x8",6]]]],[11,"from_cast","","",85,[[["u32x8",6]]]],[11,"from_cast","","",85,[[["f32x8",6]]]],[11,"from_cast","","",85,[[["m32x8",6]]]],[11,"from_cast","","",85,[[["i64x8",6]]]],[11,"from_cast","","",85,[[["f64x8",6]]]],[11,"from_cast","","",85,[[["m64x8",6]]]],[11,"from_cast","","",85,[[["isizex8",6]]]],[11,"from_cast","","",85,[[["usizex8",6]]]],[11,"from_cast","","",85,[[["msizex8",6]]]],[11,"from_cast","","",86,[[["i8x8",6]]]],[11,"from_cast","","",86,[[["u8x8",6]]]],[11,"from_cast","","",86,[[["m8x8",6]]]],[11,"from_cast","","",86,[[["i16x8",6]]]],[11,"from_cast","","",86,[[["u16x8",6]]]],[11,"from_cast","","",86,[[["m16x8",6]]]],[11,"from_cast","","",86,[[["i32x8",6]]]],[11,"from_cast","","",86,[[["u32x8",6]]]],[11,"from_cast","","",86,[[["f32x8",6]]]],[11,"from_cast","","",86,[[["m32x8",6]]]],[11,"from_cast","","",86,[[["i64x8",6]]]],[11,"from_cast","","",86,[[["u64x8",6]]]],[11,"from_cast","","",86,[[["m64x8",6]]]],[11,"from_cast","","",86,[[["isizex8",6]]]],[11,"from_cast","","",86,[[["usizex8",6]]]],[11,"from_cast","","",86,[[["msizex8",6]]]],[11,"from_cast","","",87,[[["i8x8",6]]]],[11,"from_cast","","",87,[[["u8x8",6]]]],[11,"from_cast","","",87,[[["m8x8",6]]]],[11,"from_cast","","",87,[[["i16x8",6]]]],[11,"from_cast","","",87,[[["u16x8",6]]]],[11,"from_cast","","",87,[[["m16x8",6]]]],[11,"from_cast","","",87,[[["i32x8",6]]]],[11,"from_cast","","",87,[[["u32x8",6]]]],[11,"from_cast","","",87,[[["f32x8",6]]]],[11,"from_cast","","",87,[[["m32x8",6]]]],[11,"from_cast","","",87,[[["i64x8",6]]]],[11,"from_cast","","",87,[[["u64x8",6]]]],[11,"from_cast","","",87,[[["f64x8",6]]]],[11,"from_cast","","",87,[[["isizex8",6]]]],[11,"from_cast","","",87,[[["usizex8",6]]]],[11,"from_cast","","",87,[[["msizex8",6]]]],[11,"from_cast","","",88,[[["i8x4",6]]]],[11,"from_cast","","",88,[[["u8x4",6]]]],[11,"from_cast","","",88,[[["m8x4",6]]]],[11,"from_cast","","",88,[[["i16x4",6]]]],[11,"from_cast","","",88,[[["u16x4",6]]]],[11,"from_cast","","",88,[[["m16x4",6]]]],[11,"from_cast","","",88,[[["i32x4",6]]]],[11,"from_cast","","",88,[[["u32x4",6]]]],[11,"from_cast","","",88,[[["f32x4",6]]]],[11,"from_cast","","",88,[[["m32x4",6]]]],[11,"from_cast","","",88,[[["i64x4",6]]]],[11,"from_cast","","",88,[[["u64x4",6]]]],[11,"from_cast","","",88,[[["f64x4",6]]]],[11,"from_cast","","",88,[[["m64x4",6]]]],[11,"from_cast","","",88,[[["u128x4",6]]]],[11,"from_cast","","",88,[[["m128x4",6]]]],[11,"from_cast","","",88,[[["isizex4",6]]]],[11,"from_cast","","",88,[[["usizex4",6]]]],[11,"from_cast","","",88,[[["msizex4",6]]]],[11,"from_cast","","",89,[[["i8x4",6]]]],[11,"from_cast","","",89,[[["u8x4",6]]]],[11,"from_cast","","",89,[[["m8x4",6]]]],[11,"from_cast","","",89,[[["i16x4",6]]]],[11,"from_cast","","",89,[[["u16x4",6]]]],[11,"from_cast","","",89,[[["m16x4",6]]]],[11,"from_cast","","",89,[[["i32x4",6]]]],[11,"from_cast","","",89,[[["u32x4",6]]]],[11,"from_cast","","",89,[[["f32x4",6]]]],[11,"from_cast","","",89,[[["m32x4",6]]]],[11,"from_cast","","",89,[[["i64x4",6]]]],[11,"from_cast","","",89,[[["u64x4",6]]]],[11,"from_cast","","",89,[[["f64x4",6]]]],[11,"from_cast","","",89,[[["m64x4",6]]]],[11,"from_cast","","",89,[[["i128x4",6]]]],[11,"from_cast","","",89,[[["m128x4",6]]]],[11,"from_cast","","",89,[[["isizex4",6]]]],[11,"from_cast","","",89,[[["usizex4",6]]]],[11,"from_cast","","",89,[[["msizex4",6]]]],[11,"from_cast","","",90,[[["i8x4",6]]]],[11,"from_cast","","",90,[[["u8x4",6]]]],[11,"from_cast","","",90,[[["m8x4",6]]]],[11,"from_cast","","",90,[[["i16x4",6]]]],[11,"from_cast","","",90,[[["u16x4",6]]]],[11,"from_cast","","",90,[[["m16x4",6]]]],[11,"from_cast","","",90,[[["i32x4",6]]]],[11,"from_cast","","",90,[[["u32x4",6]]]],[11,"from_cast","","",90,[[["f32x4",6]]]],[11,"from_cast","","",90,[[["m32x4",6]]]],[11,"from_cast","","",90,[[["i64x4",6]]]],[11,"from_cast","","",90,[[["u64x4",6]]]],[11,"from_cast","","",90,[[["m64x4",6]]]],[11,"from_cast","","",90,[[["f64x4",6]]]],[11,"from_cast","","",90,[[["i128x4",6]]]],[11,"from_cast","","",90,[[["u128x4",6]]]],[11,"from_cast","","",90,[[["isizex4",6]]]],[11,"from_cast","","",90,[[["usizex4",6]]]],[11,"from_cast","","",90,[[["msizex4",6]]]],[11,"from_cast","","",91,[[["i8x8",6]]]],[11,"from_cast","","",91,[[["u8x8",6]]]],[11,"from_cast","","",91,[[["m8x8",6]]]],[11,"from_cast","","",91,[[["i16x8",6]]]],[11,"from_cast","","",91,[[["u16x8",6]]]],[11,"from_cast","","",91,[[["m16x8",6]]]],[11,"from_cast","","",91,[[["i32x8",6]]]],[11,"from_cast","","",91,[[["u32x8",6]]]],[11,"from_cast","","",91,[[["f32x8",6]]]],[11,"from_cast","","",91,[[["m32x8",6]]]],[11,"from_cast","","",91,[[["i64x8",6]]]],[11,"from_cast","","",91,[[["u64x8",6]]]],[11,"from_cast","","",91,[[["f64x8",6]]]],[11,"from_cast","","",91,[[["m64x8",6]]]],[11,"from_cast","","",91,[[["usizex8",6]]]],[11,"from_cast","","",91,[[["msizex8",6]]]],[11,"from_cast","","",92,[[["i8x8",6]]]],[11,"from_cast","","",92,[[["u8x8",6]]]],[11,"from_cast","","",92,[[["m8x8",6]]]],[11,"from_cast","","",92,[[["i16x8",6]]]],[11,"from_cast","","",92,[[["u16x8",6]]]],[11,"from_cast","","",92,[[["m16x8",6]]]],[11,"from_cast","","",92,[[["i32x8",6]]]],[11,"from_cast","","",92,[[["u32x8",6]]]],[11,"from_cast","","",92,[[["f32x8",6]]]],[11,"from_cast","","",92,[[["m32x8",6]]]],[11,"from_cast","","",92,[[["i64x8",6]]]],[11,"from_cast","","",92,[[["u64x8",6]]]],[11,"from_cast","","",92,[[["f64x8",6]]]],[11,"from_cast","","",92,[[["m64x8",6]]]],[11,"from_cast","","",92,[[["isizex8",6]]]],[11,"from_cast","","",92,[[["msizex8",6]]]],[11,"from_cast","","",93,[[["i8x8",6]]]],[11,"from_cast","","",93,[[["u8x8",6]]]],[11,"from_cast","","",93,[[["m8x8",6]]]],[11,"from_cast","","",93,[[["i16x8",6]]]],[11,"from_cast","","",93,[[["u16x8",6]]]],[11,"from_cast","","",93,[[["m16x8",6]]]],[11,"from_cast","","",93,[[["i32x8",6]]]],[11,"from_cast","","",93,[[["u32x8",6]]]],[11,"from_cast","","",93,[[["f32x8",6]]]],[11,"from_cast","","",93,[[["m32x8",6]]]],[11,"from_cast","","",93,[[["i64x8",6]]]],[11,"from_cast","","",93,[[["u64x8",6]]]],[11,"from_cast","","",93,[[["f64x8",6]]]],[11,"from_cast","","",93,[[["m64x8",6]]]],[11,"from_cast","","",93,[[["isizex8",6]]]],[11,"from_cast","","",93,[[["usizex8",6]]]],[11,"from_bits","","",15,[[["u8x2",6]]]],[11,"from_bits","","",15,[[["m8x2",6]]]],[11,"from_bits","","",16,[[["i8x2",6]]]],[11,"from_bits","","",16,[[["m8x2",6]]]],[11,"from_bits","","",18,[[["u8x4",6]]]],[11,"from_bits","","",18,[[["m8x4",6]]]],[11,"from_bits","","",18,[[["i16x2",6]]]],[11,"from_bits","","",18,[[["u16x2",6]]]],[11,"from_bits","","",18,[[["m16x2",6]]]],[11,"from_bits","","",19,[[["i8x4",6]]]],[11,"from_bits","","",19,[[["m8x4",6]]]],[11,"from_bits","","",19,[[["i16x2",6]]]],[11,"from_bits","","",19,[[["u16x2",6]]]],[11,"from_bits","","",19,[[["m16x2",6]]]],[11,"from_bits","","",20,[[["m16x2",6]]]],[11,"from_bits","","",21,[[["i8x4",6]]]],[11,"from_bits","","",21,[[["u8x4",6]]]],[11,"from_bits","","",21,[[["m8x4",6]]]],[11,"from_bits","","",21,[[["u16x2",6]]]],[11,"from_bits","","",21,[[["m16x2",6]]]],[11,"from_bits","","",22,[[["i8x4",6]]]],[11,"from_bits","","",22,[[["u8x4",6]]]],[11,"from_bits","","",22,[[["m8x4",6]]]],[11,"from_bits","","",22,[[["i16x2",6]]]],[11,"from_bits","","",22,[[["m16x2",6]]]],[11,"from_bits","","",24,[[["u8x8",6]]]],[11,"from_bits","","",24,[[["m8x8",6]]]],[11,"from_bits","","",24,[[["i16x4",6]]]],[11,"from_bits","","",24,[[["u16x4",6]]]],[11,"from_bits","","",24,[[["m16x4",6]]]],[11,"from_bits","","",24,[[["i32x2",6]]]],[11,"from_bits","","",24,[[["u32x2",6]]]],[11,"from_bits","","",24,[[["f32x2",6]]]],[11,"from_bits","","",24,[[["m32x2",6]]]],[11,"from_bits","","",25,[[["i8x8",6]]]],[11,"from_bits","","",25,[[["m8x8",6]]]],[11,"from_bits","","",25,[[["i16x4",6]]]],[11,"from_bits","","",25,[[["u16x4",6]]]],[11,"from_bits","","",25,[[["m16x4",6]]]],[11,"from_bits","","",25,[[["i32x2",6]]]],[11,"from_bits","","",25,[[["u32x2",6]]]],[11,"from_bits","","",25,[[["f32x2",6]]]],[11,"from_bits","","",25,[[["m32x2",6]]]],[11,"from_bits","","",26,[[["m16x4",6]]]],[11,"from_bits","","",26,[[["m32x2",6]]]],[11,"from_bits","","",27,[[["i8x8",6]]]],[11,"from_bits","","",27,[[["u8x8",6]]]],[11,"from_bits","","",27,[[["m8x8",6]]]],[11,"from_bits","","",27,[[["u16x4",6]]]],[11,"from_bits","","",27,[[["m16x4",6]]]],[11,"from_bits","","",27,[[["i32x2",6]]]],[11,"from_bits","","",27,[[["u32x2",6]]]],[11,"from_bits","","",27,[[["f32x2",6]]]],[11,"from_bits","","",27,[[["m32x2",6]]]],[11,"from_bits","","",28,[[["i8x8",6]]]],[11,"from_bits","","",28,[[["u8x8",6]]]],[11,"from_bits","","",28,[[["m8x8",6]]]],[11,"from_bits","","",28,[[["i16x4",6]]]],[11,"from_bits","","",28,[[["m16x4",6]]]],[11,"from_bits","","",28,[[["i32x2",6]]]],[11,"from_bits","","",28,[[["u32x2",6]]]],[11,"from_bits","","",28,[[["f32x2",6]]]],[11,"from_bits","","",28,[[["m32x2",6]]]],[11,"from_bits","","",29,[[["m32x2",6]]]],[11,"from_bits","","",30,[[["i8x8",6]]]],[11,"from_bits","","",30,[[["u8x8",6]]]],[11,"from_bits","","",30,[[["m8x8",6]]]],[11,"from_bits","","",30,[[["i16x4",6]]]],[11,"from_bits","","",30,[[["u16x4",6]]]],[11,"from_bits","","",30,[[["m16x4",6]]]],[11,"from_bits","","",30,[[["u32x2",6]]]],[11,"from_bits","","",30,[[["f32x2",6]]]],[11,"from_bits","","",30,[[["m32x2",6]]]],[11,"from_bits","","",31,[[["i8x8",6]]]],[11,"from_bits","","",31,[[["u8x8",6]]]],[11,"from_bits","","",31,[[["m8x8",6]]]],[11,"from_bits","","",31,[[["i16x4",6]]]],[11,"from_bits","","",31,[[["u16x4",6]]]],[11,"from_bits","","",31,[[["m16x4",6]]]],[11,"from_bits","","",31,[[["i32x2",6]]]],[11,"from_bits","","",31,[[["f32x2",6]]]],[11,"from_bits","","",31,[[["m32x2",6]]]],[11,"from_bits","","",32,[[["i8x8",6]]]],[11,"from_bits","","",32,[[["u8x8",6]]]],[11,"from_bits","","",32,[[["m8x8",6]]]],[11,"from_bits","","",32,[[["i16x4",6]]]],[11,"from_bits","","",32,[[["u16x4",6]]]],[11,"from_bits","","",32,[[["m16x4",6]]]],[11,"from_bits","","",32,[[["i32x2",6]]]],[11,"from_bits","","",32,[[["u32x2",6]]]],[11,"from_bits","","",32,[[["m32x2",6]]]],[11,"from_bits","","",34,[[["u8x16",6]]]],[11,"from_bits","","",34,[[["m8x16",6]]]],[11,"from_bits","","",34,[[["i16x8",6]]]],[11,"from_bits","","",34,[[["u16x8",6]]]],[11,"from_bits","","",34,[[["m16x8",6]]]],[11,"from_bits","","",34,[[["i32x4",6]]]],[11,"from_bits","","",34,[[["u32x4",6]]]],[11,"from_bits","","",34,[[["f32x4",6]]]],[11,"from_bits","","",34,[[["m32x4",6]]]],[11,"from_bits","","",34,[[["i64x2",6]]]],[11,"from_bits","","",34,[[["u64x2",6]]]],[11,"from_bits","","",34,[[["f64x2",6]]]],[11,"from_bits","","",34,[[["m64x2",6]]]],[11,"from_bits","","",34,[[["i128x1",6]]]],[11,"from_bits","","",34,[[["u128x1",6]]]],[11,"from_bits","","",34,[[["m128x1",6]]]],[11,"from_bits","","",35,[[["i8x16",6]]]],[11,"from_bits","","",35,[[["m8x16",6]]]],[11,"from_bits","","",35,[[["i16x8",6]]]],[11,"from_bits","","",35,[[["u16x8",6]]]],[11,"from_bits","","",35,[[["m16x8",6]]]],[11,"from_bits","","",35,[[["i32x4",6]]]],[11,"from_bits","","",35,[[["u32x4",6]]]],[11,"from_bits","","",35,[[["f32x4",6]]]],[11,"from_bits","","",35,[[["m32x4",6]]]],[11,"from_bits","","",35,[[["i64x2",6]]]],[11,"from_bits","","",35,[[["u64x2",6]]]],[11,"from_bits","","",35,[[["f64x2",6]]]],[11,"from_bits","","",35,[[["m64x2",6]]]],[11,"from_bits","","",35,[[["i128x1",6]]]],[11,"from_bits","","",35,[[["u128x1",6]]]],[11,"from_bits","","",35,[[["m128x1",6]]]],[11,"from_bits","","",36,[[["m16x8",6]]]],[11,"from_bits","","",36,[[["m32x4",6]]]],[11,"from_bits","","",36,[[["m64x2",6]]]],[11,"from_bits","","",36,[[["m128x1",6]]]],[11,"from_bits","","",37,[[["i8x16",6]]]],[11,"from_bits","","",37,[[["u8x16",6]]]],[11,"from_bits","","",37,[[["m8x16",6]]]],[11,"from_bits","","",37,[[["u16x8",6]]]],[11,"from_bits","","",37,[[["m16x8",6]]]],[11,"from_bits","","",37,[[["i32x4",6]]]],[11,"from_bits","","",37,[[["u32x4",6]]]],[11,"from_bits","","",37,[[["f32x4",6]]]],[11,"from_bits","","",37,[[["m32x4",6]]]],[11,"from_bits","","",37,[[["i64x2",6]]]],[11,"from_bits","","",37,[[["u64x2",6]]]],[11,"from_bits","","",37,[[["f64x2",6]]]],[11,"from_bits","","",37,[[["m64x2",6]]]],[11,"from_bits","","",37,[[["i128x1",6]]]],[11,"from_bits","","",37,[[["u128x1",6]]]],[11,"from_bits","","",37,[[["m128x1",6]]]],[11,"from_bits","","",38,[[["i8x16",6]]]],[11,"from_bits","","",38,[[["u8x16",6]]]],[11,"from_bits","","",38,[[["m8x16",6]]]],[11,"from_bits","","",38,[[["i16x8",6]]]],[11,"from_bits","","",38,[[["m16x8",6]]]],[11,"from_bits","","",38,[[["i32x4",6]]]],[11,"from_bits","","",38,[[["u32x4",6]]]],[11,"from_bits","","",38,[[["f32x4",6]]]],[11,"from_bits","","",38,[[["m32x4",6]]]],[11,"from_bits","","",38,[[["i64x2",6]]]],[11,"from_bits","","",38,[[["u64x2",6]]]],[11,"from_bits","","",38,[[["f64x2",6]]]],[11,"from_bits","","",38,[[["m64x2",6]]]],[11,"from_bits","","",38,[[["i128x1",6]]]],[11,"from_bits","","",38,[[["u128x1",6]]]],[11,"from_bits","","",38,[[["m128x1",6]]]],[11,"from_bits","","",39,[[["m32x4",6]]]],[11,"from_bits","","",39,[[["m64x2",6]]]],[11,"from_bits","","",39,[[["m128x1",6]]]],[11,"from_bits","","",40,[[["i8x16",6]]]],[11,"from_bits","","",40,[[["u8x16",6]]]],[11,"from_bits","","",40,[[["m8x16",6]]]],[11,"from_bits","","",40,[[["i16x8",6]]]],[11,"from_bits","","",40,[[["u16x8",6]]]],[11,"from_bits","","",40,[[["m16x8",6]]]],[11,"from_bits","","",40,[[["u32x4",6]]]],[11,"from_bits","","",40,[[["f32x4",6]]]],[11,"from_bits","","",40,[[["m32x4",6]]]],[11,"from_bits","","",40,[[["i64x2",6]]]],[11,"from_bits","","",40,[[["u64x2",6]]]],[11,"from_bits","","",40,[[["f64x2",6]]]],[11,"from_bits","","",40,[[["m64x2",6]]]],[11,"from_bits","","",40,[[["i128x1",6]]]],[11,"from_bits","","",40,[[["u128x1",6]]]],[11,"from_bits","","",40,[[["m128x1",6]]]],[11,"from_bits","","",41,[[["i8x16",6]]]],[11,"from_bits","","",41,[[["u8x16",6]]]],[11,"from_bits","","",41,[[["m8x16",6]]]],[11,"from_bits","","",41,[[["i16x8",6]]]],[11,"from_bits","","",41,[[["u16x8",6]]]],[11,"from_bits","","",41,[[["m16x8",6]]]],[11,"from_bits","","",41,[[["i32x4",6]]]],[11,"from_bits","","",41,[[["f32x4",6]]]],[11,"from_bits","","",41,[[["m32x4",6]]]],[11,"from_bits","","",41,[[["i64x2",6]]]],[11,"from_bits","","",41,[[["u64x2",6]]]],[11,"from_bits","","",41,[[["f64x2",6]]]],[11,"from_bits","","",41,[[["m64x2",6]]]],[11,"from_bits","","",41,[[["i128x1",6]]]],[11,"from_bits","","",41,[[["u128x1",6]]]],[11,"from_bits","","",41,[[["m128x1",6]]]],[11,"from_bits","","",42,[[["i8x16",6]]]],[11,"from_bits","","",42,[[["u8x16",6]]]],[11,"from_bits","","",42,[[["m8x16",6]]]],[11,"from_bits","","",42,[[["i16x8",6]]]],[11,"from_bits","","",42,[[["u16x8",6]]]],[11,"from_bits","","",42,[[["m16x8",6]]]],[11,"from_bits","","",42,[[["i32x4",6]]]],[11,"from_bits","","",42,[[["u32x4",6]]]],[11,"from_bits","","",42,[[["m32x4",6]]]],[11,"from_bits","","",42,[[["i64x2",6]]]],[11,"from_bits","","",42,[[["u64x2",6]]]],[11,"from_bits","","",42,[[["f64x2",6]]]],[11,"from_bits","","",42,[[["m64x2",6]]]],[11,"from_bits","","",42,[[["i128x1",6]]]],[11,"from_bits","","",42,[[["u128x1",6]]]],[11,"from_bits","","",42,[[["m128x1",6]]]],[11,"from_bits","","",43,[[["m64x2",6]]]],[11,"from_bits","","",43,[[["m128x1",6]]]],[11,"from_bits","","",44,[[["i8x16",6]]]],[11,"from_bits","","",44,[[["u8x16",6]]]],[11,"from_bits","","",44,[[["m8x16",6]]]],[11,"from_bits","","",44,[[["i16x8",6]]]],[11,"from_bits","","",44,[[["u16x8",6]]]],[11,"from_bits","","",44,[[["m16x8",6]]]],[11,"from_bits","","",44,[[["i32x4",6]]]],[11,"from_bits","","",44,[[["u32x4",6]]]],[11,"from_bits","","",44,[[["f32x4",6]]]],[11,"from_bits","","",44,[[["m32x4",6]]]],[11,"from_bits","","",44,[[["u64x2",6]]]],[11,"from_bits","","",44,[[["f64x2",6]]]],[11,"from_bits","","",44,[[["m64x2",6]]]],[11,"from_bits","","",44,[[["i128x1",6]]]],[11,"from_bits","","",44,[[["u128x1",6]]]],[11,"from_bits","","",44,[[["m128x1",6]]]],[11,"from_bits","","",45,[[["i8x16",6]]]],[11,"from_bits","","",45,[[["u8x16",6]]]],[11,"from_bits","","",45,[[["m8x16",6]]]],[11,"from_bits","","",45,[[["i16x8",6]]]],[11,"from_bits","","",45,[[["u16x8",6]]]],[11,"from_bits","","",45,[[["m16x8",6]]]],[11,"from_bits","","",45,[[["i32x4",6]]]],[11,"from_bits","","",45,[[["u32x4",6]]]],[11,"from_bits","","",45,[[["f32x4",6]]]],[11,"from_bits","","",45,[[["m32x4",6]]]],[11,"from_bits","","",45,[[["i64x2",6]]]],[11,"from_bits","","",45,[[["f64x2",6]]]],[11,"from_bits","","",45,[[["m64x2",6]]]],[11,"from_bits","","",45,[[["i128x1",6]]]],[11,"from_bits","","",45,[[["u128x1",6]]]],[11,"from_bits","","",45,[[["m128x1",6]]]],[11,"from_bits","","",46,[[["i8x16",6]]]],[11,"from_bits","","",46,[[["u8x16",6]]]],[11,"from_bits","","",46,[[["m8x16",6]]]],[11,"from_bits","","",46,[[["i16x8",6]]]],[11,"from_bits","","",46,[[["u16x8",6]]]],[11,"from_bits","","",46,[[["m16x8",6]]]],[11,"from_bits","","",46,[[["i32x4",6]]]],[11,"from_bits","","",46,[[["u32x4",6]]]],[11,"from_bits","","",46,[[["f32x4",6]]]],[11,"from_bits","","",46,[[["m32x4",6]]]],[11,"from_bits","","",46,[[["i64x2",6]]]],[11,"from_bits","","",46,[[["u64x2",6]]]],[11,"from_bits","","",46,[[["m64x2",6]]]],[11,"from_bits","","",46,[[["i128x1",6]]]],[11,"from_bits","","",46,[[["u128x1",6]]]],[11,"from_bits","","",46,[[["m128x1",6]]]],[11,"from_bits","","",47,[[["m128x1",6]]]],[11,"from_bits","","",51,[[["i8x16",6]]]],[11,"from_bits","","",51,[[["u8x16",6]]]],[11,"from_bits","","",51,[[["m8x16",6]]]],[11,"from_bits","","",51,[[["i16x8",6]]]],[11,"from_bits","","",51,[[["u16x8",6]]]],[11,"from_bits","","",51,[[["m16x8",6]]]],[11,"from_bits","","",51,[[["i32x4",6]]]],[11,"from_bits","","",51,[[["u32x4",6]]]],[11,"from_bits","","",51,[[["f32x4",6]]]],[11,"from_bits","","",51,[[["m32x4",6]]]],[11,"from_bits","","",51,[[["i64x2",6]]]],[11,"from_bits","","",51,[[["u64x2",6]]]],[11,"from_bits","","",51,[[["f64x2",6]]]],[11,"from_bits","","",51,[[["m64x2",6]]]],[11,"from_bits","","",51,[[["u128x1",6]]]],[11,"from_bits","","",51,[[["m128x1",6]]]],[11,"from_bits","","",52,[[["i8x16",6]]]],[11,"from_bits","","",52,[[["u8x16",6]]]],[11,"from_bits","","",52,[[["m8x16",6]]]],[11,"from_bits","","",52,[[["i16x8",6]]]],[11,"from_bits","","",52,[[["u16x8",6]]]],[11,"from_bits","","",52,[[["m16x8",6]]]],[11,"from_bits","","",52,[[["i32x4",6]]]],[11,"from_bits","","",52,[[["u32x4",6]]]],[11,"from_bits","","",52,[[["f32x4",6]]]],[11,"from_bits","","",52,[[["m32x4",6]]]],[11,"from_bits","","",52,[[["i64x2",6]]]],[11,"from_bits","","",52,[[["u64x2",6]]]],[11,"from_bits","","",52,[[["f64x2",6]]]],[11,"from_bits","","",52,[[["m64x2",6]]]],[11,"from_bits","","",52,[[["i128x1",6]]]],[11,"from_bits","","",52,[[["m128x1",6]]]],[11,"from_bits","","",54,[[["u8x32",6]]]],[11,"from_bits","","",54,[[["m8x32",6]]]],[11,"from_bits","","",54,[[["i16x16",6]]]],[11,"from_bits","","",54,[[["u16x16",6]]]],[11,"from_bits","","",54,[[["m16x16",6]]]],[11,"from_bits","","",54,[[["i32x8",6]]]],[11,"from_bits","","",54,[[["u32x8",6]]]],[11,"from_bits","","",54,[[["f32x8",6]]]],[11,"from_bits","","",54,[[["m32x8",6]]]],[11,"from_bits","","",54,[[["i64x4",6]]]],[11,"from_bits","","",54,[[["u64x4",6]]]],[11,"from_bits","","",54,[[["f64x4",6]]]],[11,"from_bits","","",54,[[["m64x4",6]]]],[11,"from_bits","","",54,[[["i128x2",6]]]],[11,"from_bits","","",54,[[["u128x2",6]]]],[11,"from_bits","","",54,[[["m128x2",6]]]],[11,"from_bits","","",55,[[["i8x32",6]]]],[11,"from_bits","","",55,[[["m8x32",6]]]],[11,"from_bits","","",55,[[["i16x16",6]]]],[11,"from_bits","","",55,[[["u16x16",6]]]],[11,"from_bits","","",55,[[["m16x16",6]]]],[11,"from_bits","","",55,[[["i32x8",6]]]],[11,"from_bits","","",55,[[["u32x8",6]]]],[11,"from_bits","","",55,[[["f32x8",6]]]],[11,"from_bits","","",55,[[["m32x8",6]]]],[11,"from_bits","","",55,[[["i64x4",6]]]],[11,"from_bits","","",55,[[["u64x4",6]]]],[11,"from_bits","","",55,[[["f64x4",6]]]],[11,"from_bits","","",55,[[["m64x4",6]]]],[11,"from_bits","","",55,[[["i128x2",6]]]],[11,"from_bits","","",55,[[["u128x2",6]]]],[11,"from_bits","","",55,[[["m128x2",6]]]],[11,"from_bits","","",56,[[["m16x16",6]]]],[11,"from_bits","","",56,[[["m32x8",6]]]],[11,"from_bits","","",56,[[["m64x4",6]]]],[11,"from_bits","","",56,[[["m128x2",6]]]],[11,"from_bits","","",57,[[["i8x32",6]]]],[11,"from_bits","","",57,[[["u8x32",6]]]],[11,"from_bits","","",57,[[["m8x32",6]]]],[11,"from_bits","","",57,[[["u16x16",6]]]],[11,"from_bits","","",57,[[["m16x16",6]]]],[11,"from_bits","","",57,[[["i32x8",6]]]],[11,"from_bits","","",57,[[["u32x8",6]]]],[11,"from_bits","","",57,[[["f32x8",6]]]],[11,"from_bits","","",57,[[["m32x8",6]]]],[11,"from_bits","","",57,[[["i64x4",6]]]],[11,"from_bits","","",57,[[["u64x4",6]]]],[11,"from_bits","","",57,[[["f64x4",6]]]],[11,"from_bits","","",57,[[["m64x4",6]]]],[11,"from_bits","","",57,[[["i128x2",6]]]],[11,"from_bits","","",57,[[["u128x2",6]]]],[11,"from_bits","","",57,[[["m128x2",6]]]],[11,"from_bits","","",58,[[["i8x32",6]]]],[11,"from_bits","","",58,[[["u8x32",6]]]],[11,"from_bits","","",58,[[["m8x32",6]]]],[11,"from_bits","","",58,[[["i16x16",6]]]],[11,"from_bits","","",58,[[["m16x16",6]]]],[11,"from_bits","","",58,[[["i32x8",6]]]],[11,"from_bits","","",58,[[["u32x8",6]]]],[11,"from_bits","","",58,[[["f32x8",6]]]],[11,"from_bits","","",58,[[["m32x8",6]]]],[11,"from_bits","","",58,[[["i64x4",6]]]],[11,"from_bits","","",58,[[["u64x4",6]]]],[11,"from_bits","","",58,[[["f64x4",6]]]],[11,"from_bits","","",58,[[["m64x4",6]]]],[11,"from_bits","","",58,[[["i128x2",6]]]],[11,"from_bits","","",58,[[["u128x2",6]]]],[11,"from_bits","","",58,[[["m128x2",6]]]],[11,"from_bits","","",59,[[["m32x8",6]]]],[11,"from_bits","","",59,[[["m64x4",6]]]],[11,"from_bits","","",59,[[["m128x2",6]]]],[11,"from_bits","","",60,[[["i8x32",6]]]],[11,"from_bits","","",60,[[["u8x32",6]]]],[11,"from_bits","","",60,[[["m8x32",6]]]],[11,"from_bits","","",60,[[["i16x16",6]]]],[11,"from_bits","","",60,[[["u16x16",6]]]],[11,"from_bits","","",60,[[["m16x16",6]]]],[11,"from_bits","","",60,[[["u32x8",6]]]],[11,"from_bits","","",60,[[["f32x8",6]]]],[11,"from_bits","","",60,[[["m32x8",6]]]],[11,"from_bits","","",60,[[["i64x4",6]]]],[11,"from_bits","","",60,[[["u64x4",6]]]],[11,"from_bits","","",60,[[["f64x4",6]]]],[11,"from_bits","","",60,[[["m64x4",6]]]],[11,"from_bits","","",60,[[["i128x2",6]]]],[11,"from_bits","","",60,[[["u128x2",6]]]],[11,"from_bits","","",60,[[["m128x2",6]]]],[11,"from_bits","","",61,[[["i8x32",6]]]],[11,"from_bits","","",61,[[["u8x32",6]]]],[11,"from_bits","","",61,[[["m8x32",6]]]],[11,"from_bits","","",61,[[["i16x16",6]]]],[11,"from_bits","","",61,[[["u16x16",6]]]],[11,"from_bits","","",61,[[["m16x16",6]]]],[11,"from_bits","","",61,[[["i32x8",6]]]],[11,"from_bits","","",61,[[["f32x8",6]]]],[11,"from_bits","","",61,[[["m32x8",6]]]],[11,"from_bits","","",61,[[["i64x4",6]]]],[11,"from_bits","","",61,[[["u64x4",6]]]],[11,"from_bits","","",61,[[["f64x4",6]]]],[11,"from_bits","","",61,[[["m64x4",6]]]],[11,"from_bits","","",61,[[["i128x2",6]]]],[11,"from_bits","","",61,[[["u128x2",6]]]],[11,"from_bits","","",61,[[["m128x2",6]]]],[11,"from_bits","","",62,[[["i8x32",6]]]],[11,"from_bits","","",62,[[["u8x32",6]]]],[11,"from_bits","","",62,[[["m8x32",6]]]],[11,"from_bits","","",62,[[["i16x16",6]]]],[11,"from_bits","","",62,[[["u16x16",6]]]],[11,"from_bits","","",62,[[["m16x16",6]]]],[11,"from_bits","","",62,[[["i32x8",6]]]],[11,"from_bits","","",62,[[["u32x8",6]]]],[11,"from_bits","","",62,[[["m32x8",6]]]],[11,"from_bits","","",62,[[["i64x4",6]]]],[11,"from_bits","","",62,[[["u64x4",6]]]],[11,"from_bits","","",62,[[["f64x4",6]]]],[11,"from_bits","","",62,[[["m64x4",6]]]],[11,"from_bits","","",62,[[["i128x2",6]]]],[11,"from_bits","","",62,[[["u128x2",6]]]],[11,"from_bits","","",62,[[["m128x2",6]]]],[11,"from_bits","","",63,[[["m64x4",6]]]],[11,"from_bits","","",63,[[["m128x2",6]]]],[11,"from_bits","","",64,[[["i8x32",6]]]],[11,"from_bits","","",64,[[["u8x32",6]]]],[11,"from_bits","","",64,[[["m8x32",6]]]],[11,"from_bits","","",64,[[["i16x16",6]]]],[11,"from_bits","","",64,[[["u16x16",6]]]],[11,"from_bits","","",64,[[["m16x16",6]]]],[11,"from_bits","","",64,[[["i32x8",6]]]],[11,"from_bits","","",64,[[["u32x8",6]]]],[11,"from_bits","","",64,[[["f32x8",6]]]],[11,"from_bits","","",64,[[["m32x8",6]]]],[11,"from_bits","","",64,[[["u64x4",6]]]],[11,"from_bits","","",64,[[["f64x4",6]]]],[11,"from_bits","","",64,[[["m64x4",6]]]],[11,"from_bits","","",64,[[["i128x2",6]]]],[11,"from_bits","","",64,[[["u128x2",6]]]],[11,"from_bits","","",64,[[["m128x2",6]]]],[11,"from_bits","","",65,[[["i8x32",6]]]],[11,"from_bits","","",65,[[["u8x32",6]]]],[11,"from_bits","","",65,[[["m8x32",6]]]],[11,"from_bits","","",65,[[["i16x16",6]]]],[11,"from_bits","","",65,[[["u16x16",6]]]],[11,"from_bits","","",65,[[["m16x16",6]]]],[11,"from_bits","","",65,[[["i32x8",6]]]],[11,"from_bits","","",65,[[["u32x8",6]]]],[11,"from_bits","","",65,[[["f32x8",6]]]],[11,"from_bits","","",65,[[["m32x8",6]]]],[11,"from_bits","","",65,[[["i64x4",6]]]],[11,"from_bits","","",65,[[["f64x4",6]]]],[11,"from_bits","","",65,[[["m64x4",6]]]],[11,"from_bits","","",65,[[["i128x2",6]]]],[11,"from_bits","","",65,[[["u128x2",6]]]],[11,"from_bits","","",65,[[["m128x2",6]]]],[11,"from_bits","","",66,[[["i8x32",6]]]],[11,"from_bits","","",66,[[["u8x32",6]]]],[11,"from_bits","","",66,[[["m8x32",6]]]],[11,"from_bits","","",66,[[["i16x16",6]]]],[11,"from_bits","","",66,[[["u16x16",6]]]],[11,"from_bits","","",66,[[["m16x16",6]]]],[11,"from_bits","","",66,[[["i32x8",6]]]],[11,"from_bits","","",66,[[["u32x8",6]]]],[11,"from_bits","","",66,[[["f32x8",6]]]],[11,"from_bits","","",66,[[["m32x8",6]]]],[11,"from_bits","","",66,[[["i64x4",6]]]],[11,"from_bits","","",66,[[["u64x4",6]]]],[11,"from_bits","","",66,[[["m64x4",6]]]],[11,"from_bits","","",66,[[["i128x2",6]]]],[11,"from_bits","","",66,[[["u128x2",6]]]],[11,"from_bits","","",66,[[["m128x2",6]]]],[11,"from_bits","","",67,[[["m128x2",6]]]],[11,"from_bits","","",68,[[["i8x32",6]]]],[11,"from_bits","","",68,[[["u8x32",6]]]],[11,"from_bits","","",68,[[["m8x32",6]]]],[11,"from_bits","","",68,[[["i16x16",6]]]],[11,"from_bits","","",68,[[["u16x16",6]]]],[11,"from_bits","","",68,[[["m16x16",6]]]],[11,"from_bits","","",68,[[["i32x8",6]]]],[11,"from_bits","","",68,[[["u32x8",6]]]],[11,"from_bits","","",68,[[["f32x8",6]]]],[11,"from_bits","","",68,[[["m32x8",6]]]],[11,"from_bits","","",68,[[["i64x4",6]]]],[11,"from_bits","","",68,[[["u64x4",6]]]],[11,"from_bits","","",68,[[["f64x4",6]]]],[11,"from_bits","","",68,[[["m64x4",6]]]],[11,"from_bits","","",68,[[["u128x2",6]]]],[11,"from_bits","","",68,[[["m128x2",6]]]],[11,"from_bits","","",69,[[["i8x32",6]]]],[11,"from_bits","","",69,[[["u8x32",6]]]],[11,"from_bits","","",69,[[["m8x32",6]]]],[11,"from_bits","","",69,[[["i16x16",6]]]],[11,"from_bits","","",69,[[["u16x16",6]]]],[11,"from_bits","","",69,[[["m16x16",6]]]],[11,"from_bits","","",69,[[["i32x8",6]]]],[11,"from_bits","","",69,[[["u32x8",6]]]],[11,"from_bits","","",69,[[["f32x8",6]]]],[11,"from_bits","","",69,[[["m32x8",6]]]],[11,"from_bits","","",69,[[["i64x4",6]]]],[11,"from_bits","","",69,[[["u64x4",6]]]],[11,"from_bits","","",69,[[["f64x4",6]]]],[11,"from_bits","","",69,[[["m64x4",6]]]],[11,"from_bits","","",69,[[["i128x2",6]]]],[11,"from_bits","","",69,[[["m128x2",6]]]],[11,"from_bits","","",74,[[["u8x64",6]]]],[11,"from_bits","","",74,[[["m8x64",6]]]],[11,"from_bits","","",74,[[["i16x32",6]]]],[11,"from_bits","","",74,[[["u16x32",6]]]],[11,"from_bits","","",74,[[["m16x32",6]]]],[11,"from_bits","","",74,[[["i32x16",6]]]],[11,"from_bits","","",74,[[["u32x16",6]]]],[11,"from_bits","","",74,[[["f32x16",6]]]],[11,"from_bits","","",74,[[["m32x16",6]]]],[11,"from_bits","","",74,[[["i64x8",6]]]],[11,"from_bits","","",74,[[["u64x8",6]]]],[11,"from_bits","","",74,[[["f64x8",6]]]],[11,"from_bits","","",74,[[["m64x8",6]]]],[11,"from_bits","","",74,[[["i128x4",6]]]],[11,"from_bits","","",74,[[["u128x4",6]]]],[11,"from_bits","","",74,[[["m128x4",6]]]],[11,"from_bits","","",75,[[["i8x64",6]]]],[11,"from_bits","","",75,[[["m8x64",6]]]],[11,"from_bits","","",75,[[["i16x32",6]]]],[11,"from_bits","","",75,[[["u16x32",6]]]],[11,"from_bits","","",75,[[["m16x32",6]]]],[11,"from_bits","","",75,[[["i32x16",6]]]],[11,"from_bits","","",75,[[["u32x16",6]]]],[11,"from_bits","","",75,[[["f32x16",6]]]],[11,"from_bits","","",75,[[["m32x16",6]]]],[11,"from_bits","","",75,[[["i64x8",6]]]],[11,"from_bits","","",75,[[["u64x8",6]]]],[11,"from_bits","","",75,[[["f64x8",6]]]],[11,"from_bits","","",75,[[["m64x8",6]]]],[11,"from_bits","","",75,[[["i128x4",6]]]],[11,"from_bits","","",75,[[["u128x4",6]]]],[11,"from_bits","","",75,[[["m128x4",6]]]],[11,"from_bits","","",76,[[["m16x32",6]]]],[11,"from_bits","","",76,[[["m32x16",6]]]],[11,"from_bits","","",76,[[["m64x8",6]]]],[11,"from_bits","","",76,[[["m128x4",6]]]],[11,"from_bits","","",77,[[["i8x64",6]]]],[11,"from_bits","","",77,[[["u8x64",6]]]],[11,"from_bits","","",77,[[["m8x64",6]]]],[11,"from_bits","","",77,[[["u16x32",6]]]],[11,"from_bits","","",77,[[["m16x32",6]]]],[11,"from_bits","","",77,[[["i32x16",6]]]],[11,"from_bits","","",77,[[["u32x16",6]]]],[11,"from_bits","","",77,[[["f32x16",6]]]],[11,"from_bits","","",77,[[["m32x16",6]]]],[11,"from_bits","","",77,[[["i64x8",6]]]],[11,"from_bits","","",77,[[["u64x8",6]]]],[11,"from_bits","","",77,[[["f64x8",6]]]],[11,"from_bits","","",77,[[["m64x8",6]]]],[11,"from_bits","","",77,[[["i128x4",6]]]],[11,"from_bits","","",77,[[["u128x4",6]]]],[11,"from_bits","","",77,[[["m128x4",6]]]],[11,"from_bits","","",78,[[["i8x64",6]]]],[11,"from_bits","","",78,[[["u8x64",6]]]],[11,"from_bits","","",78,[[["m8x64",6]]]],[11,"from_bits","","",78,[[["i16x32",6]]]],[11,"from_bits","","",78,[[["m16x32",6]]]],[11,"from_bits","","",78,[[["i32x16",6]]]],[11,"from_bits","","",78,[[["u32x16",6]]]],[11,"from_bits","","",78,[[["f32x16",6]]]],[11,"from_bits","","",78,[[["m32x16",6]]]],[11,"from_bits","","",78,[[["i64x8",6]]]],[11,"from_bits","","",78,[[["u64x8",6]]]],[11,"from_bits","","",78,[[["f64x8",6]]]],[11,"from_bits","","",78,[[["m64x8",6]]]],[11,"from_bits","","",78,[[["i128x4",6]]]],[11,"from_bits","","",78,[[["u128x4",6]]]],[11,"from_bits","","",78,[[["m128x4",6]]]],[11,"from_bits","","",79,[[["m32x16",6]]]],[11,"from_bits","","",79,[[["m64x8",6]]]],[11,"from_bits","","",79,[[["m128x4",6]]]],[11,"from_bits","","",80,[[["i8x64",6]]]],[11,"from_bits","","",80,[[["u8x64",6]]]],[11,"from_bits","","",80,[[["m8x64",6]]]],[11,"from_bits","","",80,[[["i16x32",6]]]],[11,"from_bits","","",80,[[["u16x32",6]]]],[11,"from_bits","","",80,[[["m16x32",6]]]],[11,"from_bits","","",80,[[["u32x16",6]]]],[11,"from_bits","","",80,[[["f32x16",6]]]],[11,"from_bits","","",80,[[["m32x16",6]]]],[11,"from_bits","","",80,[[["i64x8",6]]]],[11,"from_bits","","",80,[[["u64x8",6]]]],[11,"from_bits","","",80,[[["f64x8",6]]]],[11,"from_bits","","",80,[[["m64x8",6]]]],[11,"from_bits","","",80,[[["i128x4",6]]]],[11,"from_bits","","",80,[[["u128x4",6]]]],[11,"from_bits","","",80,[[["m128x4",6]]]],[11,"from_bits","","",81,[[["i8x64",6]]]],[11,"from_bits","","",81,[[["u8x64",6]]]],[11,"from_bits","","",81,[[["m8x64",6]]]],[11,"from_bits","","",81,[[["i16x32",6]]]],[11,"from_bits","","",81,[[["u16x32",6]]]],[11,"from_bits","","",81,[[["m16x32",6]]]],[11,"from_bits","","",81,[[["i32x16",6]]]],[11,"from_bits","","",81,[[["f32x16",6]]]],[11,"from_bits","","",81,[[["m32x16",6]]]],[11,"from_bits","","",81,[[["i64x8",6]]]],[11,"from_bits","","",81,[[["u64x8",6]]]],[11,"from_bits","","",81,[[["f64x8",6]]]],[11,"from_bits","","",81,[[["m64x8",6]]]],[11,"from_bits","","",81,[[["i128x4",6]]]],[11,"from_bits","","",81,[[["u128x4",6]]]],[11,"from_bits","","",81,[[["m128x4",6]]]],[11,"from_bits","","",82,[[["i8x64",6]]]],[11,"from_bits","","",82,[[["u8x64",6]]]],[11,"from_bits","","",82,[[["m8x64",6]]]],[11,"from_bits","","",82,[[["i16x32",6]]]],[11,"from_bits","","",82,[[["u16x32",6]]]],[11,"from_bits","","",82,[[["m16x32",6]]]],[11,"from_bits","","",82,[[["i32x16",6]]]],[11,"from_bits","","",82,[[["u32x16",6]]]],[11,"from_bits","","",82,[[["m32x16",6]]]],[11,"from_bits","","",82,[[["i64x8",6]]]],[11,"from_bits","","",82,[[["u64x8",6]]]],[11,"from_bits","","",82,[[["f64x8",6]]]],[11,"from_bits","","",82,[[["m64x8",6]]]],[11,"from_bits","","",82,[[["i128x4",6]]]],[11,"from_bits","","",82,[[["u128x4",6]]]],[11,"from_bits","","",82,[[["m128x4",6]]]],[11,"from_bits","","",83,[[["m64x8",6]]]],[11,"from_bits","","",83,[[["m128x4",6]]]],[11,"from_bits","","",84,[[["i8x64",6]]]],[11,"from_bits","","",84,[[["u8x64",6]]]],[11,"from_bits","","",84,[[["m8x64",6]]]],[11,"from_bits","","",84,[[["i16x32",6]]]],[11,"from_bits","","",84,[[["u16x32",6]]]],[11,"from_bits","","",84,[[["m16x32",6]]]],[11,"from_bits","","",84,[[["i32x16",6]]]],[11,"from_bits","","",84,[[["u32x16",6]]]],[11,"from_bits","","",84,[[["f32x16",6]]]],[11,"from_bits","","",84,[[["m32x16",6]]]],[11,"from_bits","","",84,[[["u64x8",6]]]],[11,"from_bits","","",84,[[["f64x8",6]]]],[11,"from_bits","","",84,[[["m64x8",6]]]],[11,"from_bits","","",84,[[["i128x4",6]]]],[11,"from_bits","","",84,[[["u128x4",6]]]],[11,"from_bits","","",84,[[["m128x4",6]]]],[11,"from_bits","","",85,[[["i8x64",6]]]],[11,"from_bits","","",85,[[["u8x64",6]]]],[11,"from_bits","","",85,[[["m8x64",6]]]],[11,"from_bits","","",85,[[["i16x32",6]]]],[11,"from_bits","","",85,[[["u16x32",6]]]],[11,"from_bits","","",85,[[["m16x32",6]]]],[11,"from_bits","","",85,[[["i32x16",6]]]],[11,"from_bits","","",85,[[["u32x16",6]]]],[11,"from_bits","","",85,[[["f32x16",6]]]],[11,"from_bits","","",85,[[["m32x16",6]]]],[11,"from_bits","","",85,[[["i64x8",6]]]],[11,"from_bits","","",85,[[["f64x8",6]]]],[11,"from_bits","","",85,[[["m64x8",6]]]],[11,"from_bits","","",85,[[["i128x4",6]]]],[11,"from_bits","","",85,[[["u128x4",6]]]],[11,"from_bits","","",85,[[["m128x4",6]]]],[11,"from_bits","","",86,[[["i8x64",6]]]],[11,"from_bits","","",86,[[["u8x64",6]]]],[11,"from_bits","","",86,[[["m8x64",6]]]],[11,"from_bits","","",86,[[["i16x32",6]]]],[11,"from_bits","","",86,[[["u16x32",6]]]],[11,"from_bits","","",86,[[["m16x32",6]]]],[11,"from_bits","","",86,[[["i32x16",6]]]],[11,"from_bits","","",86,[[["u32x16",6]]]],[11,"from_bits","","",86,[[["f32x16",6]]]],[11,"from_bits","","",86,[[["m32x16",6]]]],[11,"from_bits","","",86,[[["i64x8",6]]]],[11,"from_bits","","",86,[[["u64x8",6]]]],[11,"from_bits","","",86,[[["m64x8",6]]]],[11,"from_bits","","",86,[[["i128x4",6]]]],[11,"from_bits","","",86,[[["u128x4",6]]]],[11,"from_bits","","",86,[[["m128x4",6]]]],[11,"from_bits","","",87,[[["m128x4",6]]]],[11,"from_bits","","",88,[[["i8x64",6]]]],[11,"from_bits","","",88,[[["u8x64",6]]]],[11,"from_bits","","",88,[[["m8x64",6]]]],[11,"from_bits","","",88,[[["i16x32",6]]]],[11,"from_bits","","",88,[[["u16x32",6]]]],[11,"from_bits","","",88,[[["m16x32",6]]]],[11,"from_bits","","",88,[[["i32x16",6]]]],[11,"from_bits","","",88,[[["u32x16",6]]]],[11,"from_bits","","",88,[[["f32x16",6]]]],[11,"from_bits","","",88,[[["m32x16",6]]]],[11,"from_bits","","",88,[[["i64x8",6]]]],[11,"from_bits","","",88,[[["u64x8",6]]]],[11,"from_bits","","",88,[[["f64x8",6]]]],[11,"from_bits","","",88,[[["m64x8",6]]]],[11,"from_bits","","",88,[[["u128x4",6]]]],[11,"from_bits","","",88,[[["m128x4",6]]]],[11,"from_bits","","",89,[[["i8x64",6]]]],[11,"from_bits","","",89,[[["u8x64",6]]]],[11,"from_bits","","",89,[[["m8x64",6]]]],[11,"from_bits","","",89,[[["i16x32",6]]]],[11,"from_bits","","",89,[[["u16x32",6]]]],[11,"from_bits","","",89,[[["m16x32",6]]]],[11,"from_bits","","",89,[[["i32x16",6]]]],[11,"from_bits","","",89,[[["u32x16",6]]]],[11,"from_bits","","",89,[[["f32x16",6]]]],[11,"from_bits","","",89,[[["m32x16",6]]]],[11,"from_bits","","",89,[[["i64x8",6]]]],[11,"from_bits","","",89,[[["u64x8",6]]]],[11,"from_bits","","",89,[[["f64x8",6]]]],[11,"from_bits","","",89,[[["m64x8",6]]]],[11,"from_bits","","",89,[[["i128x4",6]]]],[11,"from_bits","","",89,[[["m128x4",6]]]],[11,"from_bits","","",34,[[["__m128",3]]]],[11,"from_bits","","",35,[[["__m128",3]]]],[11,"from_bits","","",37,[[["__m128",3]]]],[11,"from_bits","","",38,[[["__m128",3]]]],[11,"from_bits","","",40,[[["__m128",3]]]],[11,"from_bits","","",41,[[["__m128",3]]]],[11,"from_bits","","",42,[[["__m128",3]]]],[11,"from_bits","","",44,[[["__m128",3]]]],[11,"from_bits","","",45,[[["__m128",3]]]],[11,"from_bits","","",46,[[["__m128",3]]]],[11,"from_bits","","",51,[[["__m128",3]]]],[11,"from_bits","","",52,[[["__m128",3]]]],[11,"from_bits","","",34,[[["__m128i",3]]]],[11,"from_bits","","",35,[[["__m128i",3]]]],[11,"from_bits","","",37,[[["__m128i",3]]]],[11,"from_bits","","",38,[[["__m128i",3]]]],[11,"from_bits","","",40,[[["__m128i",3]]]],[11,"from_bits","","",41,[[["__m128i",3]]]],[11,"from_bits","","",42,[[["__m128i",3]]]],[11,"from_bits","","",44,[[["__m128i",3]]]],[11,"from_bits","","",45,[[["__m128i",3]]]],[11,"from_bits","","",46,[[["__m128i",3]]]],[11,"from_bits","","",51,[[["__m128i",3]]]],[11,"from_bits","","",52,[[["__m128i",3]]]],[11,"from_bits","","",34,[[["__m128d",3]]]],[11,"from_bits","","",35,[[["__m128d",3]]]],[11,"from_bits","","",37,[[["__m128d",3]]]],[11,"from_bits","","",38,[[["__m128d",3]]]],[11,"from_bits","","",40,[[["__m128d",3]]]],[11,"from_bits","","",41,[[["__m128d",3]]]],[11,"from_bits","","",42,[[["__m128d",3]]]],[11,"from_bits","","",44,[[["__m128d",3]]]],[11,"from_bits","","",45,[[["__m128d",3]]]],[11,"from_bits","","",46,[[["__m128d",3]]]],[11,"from_bits","","",51,[[["__m128d",3]]]],[11,"from_bits","","",52,[[["__m128d",3]]]],[11,"from_bits","","",54,[[["__m256",3]]]],[11,"from_bits","","",55,[[["__m256",3]]]],[11,"from_bits","","",57,[[["__m256",3]]]],[11,"from_bits","","",58,[[["__m256",3]]]],[11,"from_bits","","",60,[[["__m256",3]]]],[11,"from_bits","","",61,[[["__m256",3]]]],[11,"from_bits","","",62,[[["__m256",3]]]],[11,"from_bits","","",64,[[["__m256",3]]]],[11,"from_bits","","",65,[[["__m256",3]]]],[11,"from_bits","","",66,[[["__m256",3]]]],[11,"from_bits","","",68,[[["__m256",3]]]],[11,"from_bits","","",69,[[["__m256",3]]]],[11,"from_bits","","",54,[[["__m256i",3]]]],[11,"from_bits","","",55,[[["__m256i",3]]]],[11,"from_bits","","",57,[[["__m256i",3]]]],[11,"from_bits","","",58,[[["__m256i",3]]]],[11,"from_bits","","",60,[[["__m256i",3]]]],[11,"from_bits","","",61,[[["__m256i",3]]]],[11,"from_bits","","",62,[[["__m256i",3]]]],[11,"from_bits","","",64,[[["__m256i",3]]]],[11,"from_bits","","",65,[[["__m256i",3]]]],[11,"from_bits","","",66,[[["__m256i",3]]]],[11,"from_bits","","",68,[[["__m256i",3]]]],[11,"from_bits","","",69,[[["__m256i",3]]]],[11,"from_bits","","",54,[[["__m256d",3]]]],[11,"from_bits","","",55,[[["__m256d",3]]]],[11,"from_bits","","",57,[[["__m256d",3]]]],[11,"from_bits","","",58,[[["__m256d",3]]]],[11,"from_bits","","",60,[[["__m256d",3]]]],[11,"from_bits","","",61,[[["__m256d",3]]]],[11,"from_bits","","",62,[[["__m256d",3]]]],[11,"from_bits","","",64,[[["__m256d",3]]]],[11,"from_bits","","",65,[[["__m256d",3]]]],[11,"from_bits","","",66,[[["__m256d",3]]]],[11,"from_bits","","",68,[[["__m256d",3]]]],[11,"from_bits","","",69,[[["__m256d",3]]]],[11,"test","","",0,[[]]],[11,"test","","",1,[[]]],[11,"test","","",2,[[]]],[11,"test","","",3,[[]]],[11,"test","","",4,[[]]],[11,"test","","",5,[[]]],[11,"from","","",15,[[]]],[11,"from","","",16,[[]]],[11,"from","","",17,[[]]],[11,"from","","",17,[[["m16x2",6]]]],[11,"from","","",17,[[["m32x2",6]]]],[11,"from","","",17,[[["m64x2",6]]]],[11,"from","","",17,[[["m128x2",6]]]],[11,"from","","",18,[[]]],[11,"from","","",19,[[]]],[11,"from","","",20,[[]]],[11,"from","","",20,[[["m16x4",6]]]],[11,"from","","",20,[[["m32x4",6]]]],[11,"from","","",20,[[["m64x4",6]]]],[11,"from","","",21,[[]]],[11,"from","","",21,[[["i8x2",6]]]],[11,"from","","",21,[[["u8x2",6]]]],[11,"from","","",22,[[]]],[11,"from","","",22,[[["u8x2",6]]]],[11,"from","","",23,[[]]],[11,"from","","",23,[[["m8x2",6]]]],[11,"from","","",23,[[["m32x2",6]]]],[11,"from","","",23,[[["m64x2",6]]]],[11,"from","","",23,[[["m128x2",6]]]],[11,"from","","",24,[[]]],[11,"from","","",25,[[]]],[11,"from","","",26,[[]]],[11,"from","","",26,[[["m16x8",6]]]],[11,"from","","",26,[[["m32x8",6]]]],[11,"from","","",27,[[]]],[11,"from","","",27,[[["i8x4",6]]]],[11,"from","","",27,[[["u8x4",6]]]],[11,"from","","",28,[[]]],[11,"from","","",28,[[["u8x4",6]]]],[11,"from","","",29,[[]]],[11,"from","","",29,[[["m8x4",6]]]],[11,"from","","",29,[[["m32x4",6]]]],[11,"from","","",29,[[["m64x4",6]]]],[11,"from","","",30,[[]]],[11,"from","","",30,[[["i8x2",6]]]],[11,"from","","",30,[[["u8x2",6]]]],[11,"from","","",30,[[["i16x2",6]]]],[11,"from","","",30,[[["u16x2",6]]]],[11,"from","","",31,[[]]],[11,"from","","",31,[[["u8x2",6]]]],[11,"from","","",31,[[["u16x2",6]]]],[11,"from","","",33,[[]]],[11,"from","","",33,[[["m8x2",6]]]],[11,"from","","",33,[[["m16x2",6]]]],[11,"from","","",33,[[["m64x2",6]]]],[11,"from","","",33,[[["m128x2",6]]]],[11,"from","","",32,[[]]],[11,"from","","",32,[[["i8x2",6]]]],[11,"from","","",32,[[["u8x2",6]]]],[11,"from","","",32,[[["i16x2",6]]]],[11,"from","","",32,[[["u16x2",6]]]],[11,"from","","",34,[[]]],[11,"from","","",35,[[]]],[11,"from","","",36,[[]]],[11,"from","","",36,[[["m16x16",6]]]],[11,"from","","",37,[[]]],[11,"from","","",37,[[["i8x8",6]]]],[11,"from","","",37,[[["u8x8",6]]]],[11,"from","","",38,[[]]],[11,"from","","",38,[[["u8x8",6]]]],[11,"from","","",39,[[]]],[11,"from","","",39,[[["m8x8",6]]]],[11,"from","","",39,[[["m32x8",6]]]],[11,"from","","",40,[[]]],[11,"from","","",40,[[["i8x4",6]]]],[11,"from","","",40,[[["u8x4",6]]]],[11,"from","","",40,[[["i16x4",6]]]],[11,"from","","",40,[[["u16x4",6]]]],[11,"from","","",41,[[]]],[11,"from","","",41,[[["u8x4",6]]]],[11,"from","","",41,[[["u16x4",6]]]],[11,"from","","",42,[[]]],[11,"from","","",42,[[["i8x4",6]]]],[11,"from","","",42,[[["u8x4",6]]]],[11,"from","","",42,[[["i16x4",6]]]],[11,"from","","",42,[[["u16x4",6]]]],[11,"from","","",43,[[]]],[11,"from","","",43,[[["m8x4",6]]]],[11,"from","","",43,[[["m16x4",6]]]],[11,"from","","",43,[[["m64x4",6]]]],[11,"from","","",44,[[]]],[11,"from","","",44,[[["i8x2",6]]]],[11,"from","","",44,[[["u8x2",6]]]],[11,"from","","",44,[[["i16x2",6]]]],[11,"from","","",44,[[["u16x2",6]]]],[11,"from","","",44,[[["i32x2",6]]]],[11,"from","","",44,[[["u32x2",6]]]],[11,"from","","",45,[[]]],[11,"from","","",45,[[["u8x2",6]]]],[11,"from","","",45,[[["u16x2",6]]]],[11,"from","","",45,[[["u32x2",6]]]],[11,"from","","",46,[[]]],[11,"from","","",46,[[["i8x2",6]]]],[11,"from","","",46,[[["u8x2",6]]]],[11,"from","","",46,[[["i16x2",6]]]],[11,"from","","",46,[[["u16x2",6]]]],[11,"from","","",46,[[["i32x2",6]]]],[11,"from","","",46,[[["u32x2",6]]]],[11,"from","","",46,[[["f32x2",6]]]],[11,"from","","",47,[[]]],[11,"from","","",47,[[["m8x2",6]]]],[11,"from","","",47,[[["m16x2",6]]]],[11,"from","","",47,[[["m32x2",6]]]],[11,"from","","",47,[[["m128x2",6]]]],[11,"from","","",51,[[]]],[11,"from","","",52,[[]]],[11,"from","","",53,[[]]],[11,"from","","",54,[[]]],[11,"from","","",55,[[]]],[11,"from","","",56,[[]]],[11,"from","","",57,[[]]],[11,"from","","",57,[[["i8x16",6]]]],[11,"from","","",57,[[["u8x16",6]]]],[11,"from","","",58,[[]]],[11,"from","","",58,[[["u8x16",6]]]],[11,"from","","",59,[[]]],[11,"from","","",59,[[["m8x16",6]]]],[11,"from","","",60,[[]]],[11,"from","","",60,[[["i8x8",6]]]],[11,"from","","",60,[[["u8x8",6]]]],[11,"from","","",60,[[["i16x8",6]]]],[11,"from","","",60,[[["u16x8",6]]]],[11,"from","","",61,[[]]],[11,"from","","",61,[[["u8x8",6]]]],[11,"from","","",61,[[["u16x8",6]]]],[11,"from","","",62,[[]]],[11,"from","","",62,[[["i8x8",6]]]],[11,"from","","",62,[[["u8x8",6]]]],[11,"from","","",62,[[["i16x8",6]]]],[11,"from","","",62,[[["u16x8",6]]]],[11,"from","","",63,[[]]],[11,"from","","",63,[[["m8x8",6]]]],[11,"from","","",63,[[["m16x8",6]]]],[11,"from","","",64,[[]]],[11,"from","","",64,[[["i8x4",6]]]],[11,"from","","",64,[[["u8x4",6]]]],[11,"from","","",64,[[["i16x4",6]]]],[11,"from","","",64,[[["u16x4",6]]]],[11,"from","","",64,[[["i32x4",6]]]],[11,"from","","",64,[[["u32x4",6]]]],[11,"from","","",65,[[]]],[11,"from","","",65,[[["u8x4",6]]]],[11,"from","","",65,[[["u16x4",6]]]],[11,"from","","",65,[[["u32x4",6]]]],[11,"from","","",66,[[]]],[11,"from","","",66,[[["i8x4",6]]]],[11,"from","","",66,[[["u8x4",6]]]],[11,"from","","",66,[[["i16x4",6]]]],[11,"from","","",66,[[["u16x4",6]]]],[11,"from","","",66,[[["i32x4",6]]]],[11,"from","","",66,[[["u32x4",6]]]],[11,"from","","",66,[[["f32x4",6]]]],[11,"from","","",67,[[]]],[11,"from","","",67,[[["m8x4",6]]]],[11,"from","","",67,[[["m16x4",6]]]],[11,"from","","",67,[[["m32x4",6]]]],[11,"from","","",68,[[]]],[11,"from","","",68,[[["i8x2",6]]]],[11,"from","","",68,[[["u8x2",6]]]],[11,"from","","",68,[[["i16x2",6]]]],[11,"from","","",68,[[["u16x2",6]]]],[11,"from","","",68,[[["i32x2",6]]]],[11,"from","","",68,[[["u32x2",6]]]],[11,"from","","",68,[[["i64x2",6]]]],[11,"from","","",68,[[["u64x2",6]]]],[11,"from","","",69,[[]]],[11,"from","","",69,[[["u8x2",6]]]],[11,"from","","",69,[[["u16x2",6]]]],[11,"from","","",69,[[["u32x2",6]]]],[11,"from","","",69,[[["u64x2",6]]]],[11,"from","","",70,[[]]],[11,"from","","",70,[[["m8x2",6]]]],[11,"from","","",70,[[["m16x2",6]]]],[11,"from","","",70,[[["m32x2",6]]]],[11,"from","","",70,[[["m64x2",6]]]],[11,"from","","",74,[[]]],[11,"from","","",75,[[]]],[11,"from","","",76,[[]]],[11,"from","","",77,[[]]],[11,"from","","",77,[[["i8x32",6]]]],[11,"from","","",77,[[["u8x32",6]]]],[11,"from","","",78,[[]]],[11,"from","","",78,[[["u8x32",6]]]],[11,"from","","",79,[[]]],[11,"from","","",79,[[["m8x32",6]]]],[11,"from","","",80,[[]]],[11,"from","","",80,[[["i8x16",6]]]],[11,"from","","",80,[[["u8x16",6]]]],[11,"from","","",80,[[["i16x16",6]]]],[11,"from","","",80,[[["u16x16",6]]]],[11,"from","","",81,[[]]],[11,"from","","",81,[[["u8x16",6]]]],[11,"from","","",81,[[["u16x16",6]]]],[11,"from","","",82,[[]]],[11,"from","","",82,[[["i8x16",6]]]],[11,"from","","",82,[[["u8x16",6]]]],[11,"from","","",82,[[["i16x16",6]]]],[11,"from","","",82,[[["u16x16",6]]]],[11,"from","","",83,[[]]],[11,"from","","",83,[[["m8x16",6]]]],[11,"from","","",83,[[["m16x16",6]]]],[11,"from","","",84,[[]]],[11,"from","","",84,[[["i8x8",6]]]],[11,"from","","",84,[[["u8x8",6]]]],[11,"from","","",84,[[["i16x8",6]]]],[11,"from","","",84,[[["u16x8",6]]]],[11,"from","","",84,[[["i32x8",6]]]],[11,"from","","",84,[[["u32x8",6]]]],[11,"from","","",85,[[]]],[11,"from","","",85,[[["u8x8",6]]]],[11,"from","","",85,[[["u16x8",6]]]],[11,"from","","",85,[[["u32x8",6]]]],[11,"from","","",86,[[]]],[11,"from","","",86,[[["i8x8",6]]]],[11,"from","","",86,[[["u8x8",6]]]],[11,"from","","",86,[[["i16x8",6]]]],[11,"from","","",86,[[["u16x8",6]]]],[11,"from","","",86,[[["i32x8",6]]]],[11,"from","","",86,[[["u32x8",6]]]],[11,"from","","",86,[[["f32x8",6]]]],[11,"from","","",87,[[]]],[11,"from","","",87,[[["m8x8",6]]]],[11,"from","","",87,[[["m16x8",6]]]],[11,"from","","",87,[[["m32x8",6]]]],[11,"from","","",88,[[]]],[11,"from","","",88,[[["i8x4",6]]]],[11,"from","","",88,[[["u8x4",6]]]],[11,"from","","",88,[[["i16x4",6]]]],[11,"from","","",88,[[["u16x4",6]]]],[11,"from","","",88,[[["i32x4",6]]]],[11,"from","","",88,[[["u32x4",6]]]],[11,"from","","",88,[[["i64x4",6]]]],[11,"from","","",88,[[["u64x4",6]]]],[11,"from","","",89,[[]]],[11,"from","","",89,[[["u8x4",6]]]],[11,"from","","",89,[[["u16x4",6]]]],[11,"from","","",89,[[["u32x4",6]]]],[11,"from","","",89,[[["u64x4",6]]]],[11,"from","","",90,[[]]],[11,"from","","",90,[[["m8x4",6]]]],[11,"from","","",90,[[["m16x4",6]]]],[11,"from","","",90,[[["m32x4",6]]]],[11,"from","","",90,[[["m64x4",6]]]],[11,"from","","",48,[[]]],[11,"from","","",49,[[]]],[11,"from","","",50,[[]]],[11,"from","","",71,[[]]],[11,"from","","",72,[[]]],[11,"from","","",73,[[]]],[11,"from","","",91,[[]]],[11,"from","","",92,[[]]],[11,"from","","",93,[[]]],[11,"from","","",94,[[]]],[11,"from","","",95,[[]]],[11,"from","","",96,[[]]],[11,"from","","",97,[[]]],[11,"from","","",98,[[]]],[11,"from","","",99,[[]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",1,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",2,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",3,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",4,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",5,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",23,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",26,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",29,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","","",31,[[["formatter",3]],["result",6]]],[11,"fmt","","",33,[[["formatter",3]],["result",6]]],[11,"fmt","","",32,[[["formatter",3]],["result",6]]],[11,"fmt","","",34,[[["formatter",3]],["result",6]]],[11,"fmt","","",35,[[["formatter",3]],["result",6]]],[11,"fmt","","",36,[[["formatter",3]],["result",6]]],[11,"fmt","","",37,[[["formatter",3]],["result",6]]],[11,"fmt","","",38,[[["formatter",3]],["result",6]]],[11,"fmt","","",39,[[["formatter",3]],["result",6]]],[11,"fmt","","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",41,[[["formatter",3]],["result",6]]],[11,"fmt","","",42,[[["formatter",3]],["result",6]]],[11,"fmt","","",43,[[["formatter",3]],["result",6]]],[11,"fmt","","",44,[[["formatter",3]],["result",6]]],[11,"fmt","","",45,[[["formatter",3]],["result",6]]],[11,"fmt","","",46,[[["formatter",3]],["result",6]]],[11,"fmt","","",47,[[["formatter",3]],["result",6]]],[11,"fmt","","",51,[[["formatter",3]],["result",6]]],[11,"fmt","","",52,[[["formatter",3]],["result",6]]],[11,"fmt","","",53,[[["formatter",3]],["result",6]]],[11,"fmt","","",54,[[["formatter",3]],["result",6]]],[11,"fmt","","",55,[[["formatter",3]],["result",6]]],[11,"fmt","","",56,[[["formatter",3]],["result",6]]],[11,"fmt","","",57,[[["formatter",3]],["result",6]]],[11,"fmt","","",58,[[["formatter",3]],["result",6]]],[11,"fmt","","",59,[[["formatter",3]],["result",6]]],[11,"fmt","","",60,[[["formatter",3]],["result",6]]],[11,"fmt","","",61,[[["formatter",3]],["result",6]]],[11,"fmt","","",62,[[["formatter",3]],["result",6]]],[11,"fmt","","",63,[[["formatter",3]],["result",6]]],[11,"fmt","","",64,[[["formatter",3]],["result",6]]],[11,"fmt","","",65,[[["formatter",3]],["result",6]]],[11,"fmt","","",66,[[["formatter",3]],["result",6]]],[11,"fmt","","",67,[[["formatter",3]],["result",6]]],[11,"fmt","","",68,[[["formatter",3]],["result",6]]],[11,"fmt","","",69,[[["formatter",3]],["result",6]]],[11,"fmt","","",70,[[["formatter",3]],["result",6]]],[11,"fmt","","",74,[[["formatter",3]],["result",6]]],[11,"fmt","","",75,[[["formatter",3]],["result",6]]],[11,"fmt","","",76,[[["formatter",3]],["result",6]]],[11,"fmt","","",77,[[["formatter",3]],["result",6]]],[11,"fmt","","",78,[[["formatter",3]],["result",6]]],[11,"fmt","","",79,[[["formatter",3]],["result",6]]],[11,"fmt","","",80,[[["formatter",3]],["result",6]]],[11,"fmt","","",81,[[["formatter",3]],["result",6]]],[11,"fmt","","",82,[[["formatter",3]],["result",6]]],[11,"fmt","","",83,[[["formatter",3]],["result",6]]],[11,"fmt","","",84,[[["formatter",3]],["result",6]]],[11,"fmt","","",85,[[["formatter",3]],["result",6]]],[11,"fmt","","",86,[[["formatter",3]],["result",6]]],[11,"fmt","","",87,[[["formatter",3]],["result",6]]],[11,"fmt","","",88,[[["formatter",3]],["result",6]]],[11,"fmt","","",89,[[["formatter",3]],["result",6]]],[11,"fmt","","",90,[[["formatter",3]],["result",6]]],[11,"fmt","","",48,[[["formatter",3]],["result",6]]],[11,"fmt","","",49,[[["formatter",3]],["result",6]]],[11,"fmt","","",50,[[["formatter",3]],["result",6]]],[11,"fmt","","",71,[[["formatter",3]],["result",6]]],[11,"fmt","","",72,[[["formatter",3]],["result",6]]],[11,"fmt","","",73,[[["formatter",3]],["result",6]]],[11,"fmt","","",91,[[["formatter",3]],["result",6]]],[11,"fmt","","",92,[[["formatter",3]],["result",6]]],[11,"fmt","","",93,[[["formatter",3]],["result",6]]],[11,"fmt","","",94,[[["formatter",3]],["result",6]]],[11,"fmt","","",95,[[["formatter",3]],["result",6]]],[11,"fmt","","",96,[[["formatter",3]],["result",6]]],[11,"fmt","","",97,[[["formatter",3]],["result",6]]],[11,"fmt","","",98,[[["formatter",3]],["result",6]]],[11,"fmt","","",99,[[["formatter",3]],["result",6]]],[11,"div","","",15,[[]]],[11,"div","","",15,[[]]],[11,"div","","",16,[[]]],[11,"div","","",16,[[]]],[11,"div","","",18,[[]]],[11,"div","","",18,[[]]],[11,"div","","",19,[[]]],[11,"div","","",19,[[]]],[11,"div","","",21,[[]]],[11,"div","","",21,[[]]],[11,"div","","",22,[[]]],[11,"div","","",22,[[]]],[11,"div","","",24,[[]]],[11,"div","","",24,[[]]],[11,"div","","",25,[[]]],[11,"div","","",25,[[]]],[11,"div","","",27,[[]]],[11,"div","","",27,[[]]],[11,"div","","",28,[[]]],[11,"div","","",28,[[]]],[11,"div","","",30,[[]]],[11,"div","","",30,[[]]],[11,"div","","",31,[[]]],[11,"div","","",31,[[]]],[11,"div","","",32,[[]]],[11,"div","","",32,[[]]],[11,"div","","",34,[[]]],[11,"div","","",34,[[]]],[11,"div","","",35,[[]]],[11,"div","","",35,[[]]],[11,"div","","",37,[[]]],[11,"div","","",37,[[]]],[11,"div","","",38,[[]]],[11,"div","","",38,[[]]],[11,"div","","",40,[[]]],[11,"div","","",40,[[]]],[11,"div","","",41,[[]]],[11,"div","","",41,[[]]],[11,"div","","",42,[[]]],[11,"div","","",42,[[]]],[11,"div","","",44,[[]]],[11,"div","","",44,[[]]],[11,"div","","",45,[[]]],[11,"div","","",45,[[]]],[11,"div","","",46,[[]]],[11,"div","","",46,[[]]],[11,"div","","",51,[[]]],[11,"div","","",51,[[]]],[11,"div","","",52,[[]]],[11,"div","","",52,[[]]],[11,"div","","",54,[[]]],[11,"div","","",54,[[]]],[11,"div","","",55,[[]]],[11,"div","","",55,[[]]],[11,"div","","",57,[[]]],[11,"div","","",57,[[]]],[11,"div","","",58,[[]]],[11,"div","","",58,[[]]],[11,"div","","",60,[[]]],[11,"div","","",60,[[]]],[11,"div","","",61,[[]]],[11,"div","","",61,[[]]],[11,"div","","",62,[[]]],[11,"div","","",62,[[]]],[11,"div","","",64,[[]]],[11,"div","","",64,[[]]],[11,"div","","",65,[[]]],[11,"div","","",65,[[]]],[11,"div","","",66,[[]]],[11,"div","","",66,[[]]],[11,"div","","",68,[[]]],[11,"div","","",68,[[]]],[11,"div","","",69,[[]]],[11,"div","","",69,[[]]],[11,"div","","",74,[[]]],[11,"div","","",74,[[]]],[11,"div","","",75,[[]]],[11,"div","","",75,[[]]],[11,"div","","",77,[[]]],[11,"div","","",77,[[]]],[11,"div","","",78,[[]]],[11,"div","","",78,[[]]],[11,"div","","",80,[[]]],[11,"div","","",80,[[]]],[11,"div","","",81,[[]]],[11,"div","","",81,[[]]],[11,"div","","",82,[[]]],[11,"div","","",82,[[]]],[11,"div","","",84,[[]]],[11,"div","","",84,[[]]],[11,"div","","",85,[[]]],[11,"div","","",85,[[]]],[11,"div","","",86,[[]]],[11,"div","","",86,[[]]],[11,"div","","",88,[[]]],[11,"div","","",88,[[]]],[11,"div","","",89,[[]]],[11,"div","","",89,[[]]],[11,"div","","",48,[[]]],[11,"div","","",48,[[]]],[11,"div","","",49,[[]]],[11,"div","","",49,[[]]],[11,"div","","",71,[[]]],[11,"div","","",71,[[]]],[11,"div","","",72,[[]]],[11,"div","","",72,[[]]],[11,"div","","",91,[[]]],[11,"div","","",91,[[]]],[11,"div","","",92,[[]]],[11,"div","","",92,[[]]],[11,"rem","","",15,[[]]],[11,"rem","","",15,[[]]],[11,"rem","","",16,[[]]],[11,"rem","","",16,[[]]],[11,"rem","","",18,[[]]],[11,"rem","","",18,[[]]],[11,"rem","","",19,[[]]],[11,"rem","","",19,[[]]],[11,"rem","","",21,[[]]],[11,"rem","","",21,[[]]],[11,"rem","","",22,[[]]],[11,"rem","","",22,[[]]],[11,"rem","","",24,[[]]],[11,"rem","","",24,[[]]],[11,"rem","","",25,[[]]],[11,"rem","","",25,[[]]],[11,"rem","","",27,[[]]],[11,"rem","","",27,[[]]],[11,"rem","","",28,[[]]],[11,"rem","","",28,[[]]],[11,"rem","","",30,[[]]],[11,"rem","","",30,[[]]],[11,"rem","","",31,[[]]],[11,"rem","","",31,[[]]],[11,"rem","","",32,[[]]],[11,"rem","","",32,[[]]],[11,"rem","","",34,[[]]],[11,"rem","","",34,[[]]],[11,"rem","","",35,[[]]],[11,"rem","","",35,[[]]],[11,"rem","","",37,[[]]],[11,"rem","","",37,[[]]],[11,"rem","","",38,[[]]],[11,"rem","","",38,[[]]],[11,"rem","","",40,[[]]],[11,"rem","","",40,[[]]],[11,"rem","","",41,[[]]],[11,"rem","","",41,[[]]],[11,"rem","","",42,[[]]],[11,"rem","","",42,[[]]],[11,"rem","","",44,[[]]],[11,"rem","","",44,[[]]],[11,"rem","","",45,[[]]],[11,"rem","","",45,[[]]],[11,"rem","","",46,[[]]],[11,"rem","","",46,[[]]],[11,"rem","","",51,[[]]],[11,"rem","","",51,[[]]],[11,"rem","","",52,[[]]],[11,"rem","","",52,[[]]],[11,"rem","","",54,[[]]],[11,"rem","","",54,[[]]],[11,"rem","","",55,[[]]],[11,"rem","","",55,[[]]],[11,"rem","","",57,[[]]],[11,"rem","","",57,[[]]],[11,"rem","","",58,[[]]],[11,"rem","","",58,[[]]],[11,"rem","","",60,[[]]],[11,"rem","","",60,[[]]],[11,"rem","","",61,[[]]],[11,"rem","","",61,[[]]],[11,"rem","","",62,[[]]],[11,"rem","","",62,[[]]],[11,"rem","","",64,[[]]],[11,"rem","","",64,[[]]],[11,"rem","","",65,[[]]],[11,"rem","","",65,[[]]],[11,"rem","","",66,[[]]],[11,"rem","","",66,[[]]],[11,"rem","","",68,[[]]],[11,"rem","","",68,[[]]],[11,"rem","","",69,[[]]],[11,"rem","","",69,[[]]],[11,"rem","","",74,[[]]],[11,"rem","","",74,[[]]],[11,"rem","","",75,[[]]],[11,"rem","","",75,[[]]],[11,"rem","","",77,[[]]],[11,"rem","","",77,[[]]],[11,"rem","","",78,[[]]],[11,"rem","","",78,[[]]],[11,"rem","","",80,[[]]],[11,"rem","","",80,[[]]],[11,"rem","","",81,[[]]],[11,"rem","","",81,[[]]],[11,"rem","","",82,[[]]],[11,"rem","","",82,[[]]],[11,"rem","","",84,[[]]],[11,"rem","","",84,[[]]],[11,"rem","","",85,[[]]],[11,"rem","","",85,[[]]],[11,"rem","","",86,[[]]],[11,"rem","","",86,[[]]],[11,"rem","","",88,[[]]],[11,"rem","","",88,[[]]],[11,"rem","","",89,[[]]],[11,"rem","","",89,[[]]],[11,"rem","","",48,[[]]],[11,"rem","","",48,[[]]],[11,"rem","","",49,[[]]],[11,"rem","","",49,[[]]],[11,"rem","","",71,[[]]],[11,"rem","","",71,[[]]],[11,"rem","","",72,[[]]],[11,"rem","","",72,[[]]],[11,"rem","","",91,[[]]],[11,"rem","","",91,[[]]],[11,"rem","","",92,[[]]],[11,"rem","","",92,[[]]],[11,"sub","","",15,[[]]],[11,"sub","","",15,[[]]],[11,"sub","","",16,[[]]],[11,"sub","","",16,[[]]],[11,"sub","","",18,[[]]],[11,"sub","","",18,[[]]],[11,"sub","","",19,[[]]],[11,"sub","","",19,[[]]],[11,"sub","","",21,[[]]],[11,"sub","","",21,[[]]],[11,"sub","","",22,[[]]],[11,"sub","","",22,[[]]],[11,"sub","","",24,[[]]],[11,"sub","","",24,[[]]],[11,"sub","","",25,[[]]],[11,"sub","","",25,[[]]],[11,"sub","","",27,[[]]],[11,"sub","","",27,[[]]],[11,"sub","","",28,[[]]],[11,"sub","","",28,[[]]],[11,"sub","","",30,[[]]],[11,"sub","","",30,[[]]],[11,"sub","","",31,[[]]],[11,"sub","","",31,[[]]],[11,"sub","","",32,[[]]],[11,"sub","","",32,[[]]],[11,"sub","","",34,[[]]],[11,"sub","","",34,[[]]],[11,"sub","","",35,[[]]],[11,"sub","","",35,[[]]],[11,"sub","","",37,[[]]],[11,"sub","","",37,[[]]],[11,"sub","","",38,[[]]],[11,"sub","","",38,[[]]],[11,"sub","","",40,[[]]],[11,"sub","","",40,[[]]],[11,"sub","","",41,[[]]],[11,"sub","","",41,[[]]],[11,"sub","","",42,[[]]],[11,"sub","","",42,[[]]],[11,"sub","","",44,[[]]],[11,"sub","","",44,[[]]],[11,"sub","","",45,[[]]],[11,"sub","","",45,[[]]],[11,"sub","","",46,[[]]],[11,"sub","","",46,[[]]],[11,"sub","","",51,[[]]],[11,"sub","","",51,[[]]],[11,"sub","","",52,[[]]],[11,"sub","","",52,[[]]],[11,"sub","","",54,[[]]],[11,"sub","","",54,[[]]],[11,"sub","","",55,[[]]],[11,"sub","","",55,[[]]],[11,"sub","","",57,[[]]],[11,"sub","","",57,[[]]],[11,"sub","","",58,[[]]],[11,"sub","","",58,[[]]],[11,"sub","","",60,[[]]],[11,"sub","","",60,[[]]],[11,"sub","","",61,[[]]],[11,"sub","","",61,[[]]],[11,"sub","","",62,[[]]],[11,"sub","","",62,[[]]],[11,"sub","","",64,[[]]],[11,"sub","","",64,[[]]],[11,"sub","","",65,[[]]],[11,"sub","","",65,[[]]],[11,"sub","","",66,[[]]],[11,"sub","","",66,[[]]],[11,"sub","","",68,[[]]],[11,"sub","","",68,[[]]],[11,"sub","","",69,[[]]],[11,"sub","","",69,[[]]],[11,"sub","","",74,[[]]],[11,"sub","","",74,[[]]],[11,"sub","","",75,[[]]],[11,"sub","","",75,[[]]],[11,"sub","","",77,[[]]],[11,"sub","","",77,[[]]],[11,"sub","","",78,[[]]],[11,"sub","","",78,[[]]],[11,"sub","","",80,[[]]],[11,"sub","","",80,[[]]],[11,"sub","","",81,[[]]],[11,"sub","","",81,[[]]],[11,"sub","","",82,[[]]],[11,"sub","","",82,[[]]],[11,"sub","","",84,[[]]],[11,"sub","","",84,[[]]],[11,"sub","","",85,[[]]],[11,"sub","","",85,[[]]],[11,"sub","","",86,[[]]],[11,"sub","","",86,[[]]],[11,"sub","","",88,[[]]],[11,"sub","","",88,[[]]],[11,"sub","","",89,[[]]],[11,"sub","","",89,[[]]],[11,"sub","","",48,[[]]],[11,"sub","","",48,[[]]],[11,"sub","","",49,[[]]],[11,"sub","","",49,[[]]],[11,"sub","","",71,[[]]],[11,"sub","","",71,[[]]],[11,"sub","","",72,[[]]],[11,"sub","","",72,[[]]],[11,"sub","","",91,[[]]],[11,"sub","","",91,[[]]],[11,"sub","","",92,[[]]],[11,"sub","","",92,[[]]],[11,"eq","","",0,[[]]],[11,"ne","","",0,[[]]],[11,"eq","","",1,[[]]],[11,"ne","","",1,[[]]],[11,"eq","","",2,[[]]],[11,"ne","","",2,[[]]],[11,"eq","","",3,[[]]],[11,"ne","","",3,[[]]],[11,"eq","","",4,[[]]],[11,"ne","","",4,[[]]],[11,"eq","","",5,[[]]],[11,"ne","","",5,[[]]],[11,"eq","","",15,[[]]],[11,"ne","","",15,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",16,[[]]],[11,"ne","","",16,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",17,[[]]],[11,"ne","","",17,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",18,[[]]],[11,"ne","","",18,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",19,[[]]],[11,"ne","","",19,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",20,[[]]],[11,"ne","","",20,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",21,[[]]],[11,"ne","","",21,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",22,[[]]],[11,"ne","","",22,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",23,[[]]],[11,"ne","","",23,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",24,[[]]],[11,"ne","","",24,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",25,[[]]],[11,"ne","","",25,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",26,[[]]],[11,"ne","","",26,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",27,[[]]],[11,"ne","","",27,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",28,[[]]],[11,"ne","","",28,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",29,[[]]],[11,"ne","","",29,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",30,[[]]],[11,"ne","","",30,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",31,[[]]],[11,"ne","","",31,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",33,[[]]],[11,"ne","","",33,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",32,[[]]],[11,"ne","","",32,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",34,[[]]],[11,"ne","","",34,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",35,[[]]],[11,"ne","","",35,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",36,[[]]],[11,"ne","","",36,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",37,[[]]],[11,"ne","","",37,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",38,[[]]],[11,"ne","","",38,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",39,[[]]],[11,"ne","","",39,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",40,[[]]],[11,"ne","","",40,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",41,[[]]],[11,"ne","","",41,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",42,[[]]],[11,"ne","","",42,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",43,[[]]],[11,"ne","","",43,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",44,[[]]],[11,"ne","","",44,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",45,[[]]],[11,"ne","","",45,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",46,[[]]],[11,"ne","","",46,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",47,[[]]],[11,"ne","","",47,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",51,[[]]],[11,"ne","","",51,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",52,[[]]],[11,"ne","","",52,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",53,[[]]],[11,"ne","","",53,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",54,[[]]],[11,"ne","","",54,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",55,[[]]],[11,"ne","","",55,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",56,[[]]],[11,"ne","","",56,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",57,[[]]],[11,"ne","","",57,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",58,[[]]],[11,"ne","","",58,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",59,[[]]],[11,"ne","","",59,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",60,[[]]],[11,"ne","","",60,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",61,[[]]],[11,"ne","","",61,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",62,[[]]],[11,"ne","","",62,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",63,[[]]],[11,"ne","","",63,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",64,[[]]],[11,"ne","","",64,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",65,[[]]],[11,"ne","","",65,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",66,[[]]],[11,"ne","","",66,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",67,[[]]],[11,"ne","","",67,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",68,[[]]],[11,"ne","","",68,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",69,[[]]],[11,"ne","","",69,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",70,[[]]],[11,"ne","","",70,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",74,[[]]],[11,"ne","","",74,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",75,[[]]],[11,"ne","","",75,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",76,[[]]],[11,"ne","","",76,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",77,[[]]],[11,"ne","","",77,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",78,[[]]],[11,"ne","","",78,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",79,[[]]],[11,"ne","","",79,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",80,[[]]],[11,"ne","","",80,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",81,[[]]],[11,"ne","","",81,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",82,[[]]],[11,"ne","","",82,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",83,[[]]],[11,"ne","","",83,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",84,[[]]],[11,"ne","","",84,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",85,[[]]],[11,"ne","","",85,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",86,[[]]],[11,"ne","","",86,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",87,[[]]],[11,"ne","","",87,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",88,[[]]],[11,"ne","","",88,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",89,[[]]],[11,"ne","","",89,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",90,[[]]],[11,"ne","","",90,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",48,[[]]],[11,"ne","","",48,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",49,[[]]],[11,"ne","","",49,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",50,[[]]],[11,"ne","","",50,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",71,[[]]],[11,"ne","","",71,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",72,[[]]],[11,"ne","","",72,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",73,[[]]],[11,"ne","","",73,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",91,[[]]],[11,"ne","","",91,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",92,[[]]],[11,"ne","","",92,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",93,[[]]],[11,"ne","","",93,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",94,[[]]],[11,"ne","","",94,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",95,[[]]],[11,"ne","","",95,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",96,[[]]],[11,"ne","","",96,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",97,[[]]],[11,"ne","","",97,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",98,[[]]],[11,"ne","","",98,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"eq","","",99,[[]]],[11,"ne","","",99,[[]]],[11,"eq","","",14,[[]]],[11,"ne","","",14,[[]]],[11,"cmp","","",0,[[],["ordering",4]]],[11,"cmp","","",1,[[],["ordering",4]]],[11,"cmp","","",2,[[],["ordering",4]]],[11,"cmp","","",3,[[],["ordering",4]]],[11,"cmp","","",4,[[],["ordering",4]]],[11,"cmp","","",5,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"partial_cmp","","",0,[[],[["option",4],["ordering",4]]]],[11,"lt","","",0,[[]]],[11,"gt","","",0,[[]]],[11,"le","","",0,[[]]],[11,"ge","","",0,[[]]],[11,"partial_cmp","","",1,[[],[["option",4],["ordering",4]]]],[11,"lt","","",1,[[]]],[11,"gt","","",1,[[]]],[11,"le","","",1,[[]]],[11,"ge","","",1,[[]]],[11,"partial_cmp","","",2,[[],[["option",4],["ordering",4]]]],[11,"lt","","",2,[[]]],[11,"gt","","",2,[[]]],[11,"le","","",2,[[]]],[11,"ge","","",2,[[]]],[11,"partial_cmp","","",3,[[],[["option",4],["ordering",4]]]],[11,"lt","","",3,[[]]],[11,"gt","","",3,[[]]],[11,"le","","",3,[[]]],[11,"ge","","",3,[[]]],[11,"partial_cmp","","",4,[[],[["option",4],["ordering",4]]]],[11,"lt","","",4,[[]]],[11,"gt","","",4,[[]]],[11,"le","","",4,[[]]],[11,"ge","","",4,[[]]],[11,"partial_cmp","","",5,[[],[["option",4],["ordering",4]]]],[11,"lt","","",5,[[]]],[11,"gt","","",5,[[]]],[11,"le","","",5,[[]]],[11,"ge","","",5,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"partial_cmp","","",14,[[],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[]]],[11,"le","","",14,[[]]],[11,"ge","","",14,[[]]],[11,"gt","","",14,[[]]],[11,"add","","",15,[[]]],[11,"add","","",15,[[]]],[11,"add","","",16,[[]]],[11,"add","","",16,[[]]],[11,"add","","",18,[[]]],[11,"add","","",18,[[]]],[11,"add","","",19,[[]]],[11,"add","","",19,[[]]],[11,"add","","",21,[[]]],[11,"add","","",21,[[]]],[11,"add","","",22,[[]]],[11,"add","","",22,[[]]],[11,"add","","",24,[[]]],[11,"add","","",24,[[]]],[11,"add","","",25,[[]]],[11,"add","","",25,[[]]],[11,"add","","",27,[[]]],[11,"add","","",27,[[]]],[11,"add","","",28,[[]]],[11,"add","","",28,[[]]],[11,"add","","",30,[[]]],[11,"add","","",30,[[]]],[11,"add","","",31,[[]]],[11,"add","","",31,[[]]],[11,"add","","",32,[[]]],[11,"add","","",32,[[]]],[11,"add","","",34,[[]]],[11,"add","","",34,[[]]],[11,"add","","",35,[[]]],[11,"add","","",35,[[]]],[11,"add","","",37,[[]]],[11,"add","","",37,[[]]],[11,"add","","",38,[[]]],[11,"add","","",38,[[]]],[11,"add","","",40,[[]]],[11,"add","","",40,[[]]],[11,"add","","",41,[[]]],[11,"add","","",41,[[]]],[11,"add","","",42,[[]]],[11,"add","","",42,[[]]],[11,"add","","",44,[[]]],[11,"add","","",44,[[]]],[11,"add","","",45,[[]]],[11,"add","","",45,[[]]],[11,"add","","",46,[[]]],[11,"add","","",46,[[]]],[11,"add","","",51,[[]]],[11,"add","","",51,[[]]],[11,"add","","",52,[[]]],[11,"add","","",52,[[]]],[11,"add","","",54,[[]]],[11,"add","","",54,[[]]],[11,"add","","",55,[[]]],[11,"add","","",55,[[]]],[11,"add","","",57,[[]]],[11,"add","","",57,[[]]],[11,"add","","",58,[[]]],[11,"add","","",58,[[]]],[11,"add","","",60,[[]]],[11,"add","","",60,[[]]],[11,"add","","",61,[[]]],[11,"add","","",61,[[]]],[11,"add","","",62,[[]]],[11,"add","","",62,[[]]],[11,"add","","",64,[[]]],[11,"add","","",64,[[]]],[11,"add","","",65,[[]]],[11,"add","","",65,[[]]],[11,"add","","",66,[[]]],[11,"add","","",66,[[]]],[11,"add","","",68,[[]]],[11,"add","","",68,[[]]],[11,"add","","",69,[[]]],[11,"add","","",69,[[]]],[11,"add","","",74,[[]]],[11,"add","","",74,[[]]],[11,"add","","",75,[[]]],[11,"add","","",75,[[]]],[11,"add","","",77,[[]]],[11,"add","","",77,[[]]],[11,"add","","",78,[[]]],[11,"add","","",78,[[]]],[11,"add","","",80,[[]]],[11,"add","","",80,[[]]],[11,"add","","",81,[[]]],[11,"add","","",81,[[]]],[11,"add","","",82,[[]]],[11,"add","","",82,[[]]],[11,"add","","",84,[[]]],[11,"add","","",84,[[]]],[11,"add","","",85,[[]]],[11,"add","","",85,[[]]],[11,"add","","",86,[[]]],[11,"add","","",86,[[]]],[11,"add","","",88,[[]]],[11,"add","","",88,[[]]],[11,"add","","",89,[[]]],[11,"add","","",89,[[]]],[11,"add","","",48,[[]]],[11,"add","","",48,[[]]],[11,"add","","",49,[[]]],[11,"add","","",49,[[]]],[11,"add","","",71,[[]]],[11,"add","","",71,[[]]],[11,"add","","",72,[[]]],[11,"add","","",72,[[]]],[11,"add","","",91,[[]]],[11,"add","","",91,[[]]],[11,"add","","",92,[[]]],[11,"add","","",92,[[]]],[11,"mul","","",15,[[]]],[11,"mul","","",15,[[]]],[11,"mul","","",16,[[]]],[11,"mul","","",16,[[]]],[11,"mul","","",18,[[]]],[11,"mul","","",18,[[]]],[11,"mul","","",19,[[]]],[11,"mul","","",19,[[]]],[11,"mul","","",21,[[]]],[11,"mul","","",21,[[]]],[11,"mul","","",22,[[]]],[11,"mul","","",22,[[]]],[11,"mul","","",24,[[]]],[11,"mul","","",24,[[]]],[11,"mul","","",25,[[]]],[11,"mul","","",25,[[]]],[11,"mul","","",27,[[]]],[11,"mul","","",27,[[]]],[11,"mul","","",28,[[]]],[11,"mul","","",28,[[]]],[11,"mul","","",30,[[]]],[11,"mul","","",30,[[]]],[11,"mul","","",31,[[]]],[11,"mul","","",31,[[]]],[11,"mul","","",32,[[]]],[11,"mul","","",32,[[]]],[11,"mul","","",34,[[]]],[11,"mul","","",34,[[]]],[11,"mul","","",35,[[]]],[11,"mul","","",35,[[]]],[11,"mul","","",37,[[]]],[11,"mul","","",37,[[]]],[11,"mul","","",38,[[]]],[11,"mul","","",38,[[]]],[11,"mul","","",40,[[]]],[11,"mul","","",40,[[]]],[11,"mul","","",41,[[]]],[11,"mul","","",41,[[]]],[11,"mul","","",42,[[]]],[11,"mul","","",42,[[]]],[11,"mul","","",44,[[]]],[11,"mul","","",44,[[]]],[11,"mul","","",45,[[]]],[11,"mul","","",45,[[]]],[11,"mul","","",46,[[]]],[11,"mul","","",46,[[]]],[11,"mul","","",51,[[]]],[11,"mul","","",51,[[]]],[11,"mul","","",52,[[]]],[11,"mul","","",52,[[]]],[11,"mul","","",54,[[]]],[11,"mul","","",54,[[]]],[11,"mul","","",55,[[]]],[11,"mul","","",55,[[]]],[11,"mul","","",57,[[]]],[11,"mul","","",57,[[]]],[11,"mul","","",58,[[]]],[11,"mul","","",58,[[]]],[11,"mul","","",60,[[]]],[11,"mul","","",60,[[]]],[11,"mul","","",61,[[]]],[11,"mul","","",61,[[]]],[11,"mul","","",62,[[]]],[11,"mul","","",62,[[]]],[11,"mul","","",64,[[]]],[11,"mul","","",64,[[]]],[11,"mul","","",65,[[]]],[11,"mul","","",65,[[]]],[11,"mul","","",66,[[]]],[11,"mul","","",66,[[]]],[11,"mul","","",68,[[]]],[11,"mul","","",68,[[]]],[11,"mul","","",69,[[]]],[11,"mul","","",69,[[]]],[11,"mul","","",74,[[]]],[11,"mul","","",74,[[]]],[11,"mul","","",75,[[]]],[11,"mul","","",75,[[]]],[11,"mul","","",77,[[]]],[11,"mul","","",77,[[]]],[11,"mul","","",78,[[]]],[11,"mul","","",78,[[]]],[11,"mul","","",80,[[]]],[11,"mul","","",80,[[]]],[11,"mul","","",81,[[]]],[11,"mul","","",81,[[]]],[11,"mul","","",82,[[]]],[11,"mul","","",82,[[]]],[11,"mul","","",84,[[]]],[11,"mul","","",84,[[]]],[11,"mul","","",85,[[]]],[11,"mul","","",85,[[]]],[11,"mul","","",86,[[]]],[11,"mul","","",86,[[]]],[11,"mul","","",88,[[]]],[11,"mul","","",88,[[]]],[11,"mul","","",89,[[]]],[11,"mul","","",89,[[]]],[11,"mul","","",48,[[]]],[11,"mul","","",48,[[]]],[11,"mul","","",49,[[]]],[11,"mul","","",49,[[]]],[11,"mul","","",71,[[]]],[11,"mul","","",71,[[]]],[11,"mul","","",72,[[]]],[11,"mul","","",72,[[]]],[11,"mul","","",91,[[]]],[11,"mul","","",91,[[]]],[11,"mul","","",92,[[]]],[11,"mul","","",92,[[]]],[11,"neg","","",15,[[]]],[11,"neg","","",18,[[]]],[11,"neg","","",21,[[]]],[11,"neg","","",24,[[]]],[11,"neg","","",27,[[]]],[11,"neg","","",30,[[]]],[11,"neg","","",32,[[]]],[11,"neg","","",34,[[]]],[11,"neg","","",37,[[]]],[11,"neg","","",40,[[]]],[11,"neg","","",42,[[]]],[11,"neg","","",44,[[]]],[11,"neg","","",46,[[]]],[11,"neg","","",51,[[]]],[11,"neg","","",54,[[]]],[11,"neg","","",57,[[]]],[11,"neg","","",60,[[]]],[11,"neg","","",62,[[]]],[11,"neg","","",64,[[]]],[11,"neg","","",66,[[]]],[11,"neg","","",68,[[]]],[11,"neg","","",74,[[]]],[11,"neg","","",77,[[]]],[11,"neg","","",80,[[]]],[11,"neg","","",82,[[]]],[11,"neg","","",84,[[]]],[11,"neg","","",86,[[]]],[11,"neg","","",88,[[]]],[11,"neg","","",48,[[]]],[11,"neg","","",71,[[]]],[11,"neg","","",91,[[]]],[11,"add_assign","","",15,[[]]],[11,"add_assign","","",15,[[]]],[11,"add_assign","","",16,[[]]],[11,"add_assign","","",16,[[]]],[11,"add_assign","","",18,[[]]],[11,"add_assign","","",18,[[]]],[11,"add_assign","","",19,[[]]],[11,"add_assign","","",19,[[]]],[11,"add_assign","","",21,[[]]],[11,"add_assign","","",21,[[]]],[11,"add_assign","","",22,[[]]],[11,"add_assign","","",22,[[]]],[11,"add_assign","","",24,[[]]],[11,"add_assign","","",24,[[]]],[11,"add_assign","","",25,[[]]],[11,"add_assign","","",25,[[]]],[11,"add_assign","","",27,[[]]],[11,"add_assign","","",27,[[]]],[11,"add_assign","","",28,[[]]],[11,"add_assign","","",28,[[]]],[11,"add_assign","","",30,[[]]],[11,"add_assign","","",30,[[]]],[11,"add_assign","","",31,[[]]],[11,"add_assign","","",31,[[]]],[11,"add_assign","","",32,[[]]],[11,"add_assign","","",32,[[]]],[11,"add_assign","","",34,[[]]],[11,"add_assign","","",34,[[]]],[11,"add_assign","","",35,[[]]],[11,"add_assign","","",35,[[]]],[11,"add_assign","","",37,[[]]],[11,"add_assign","","",37,[[]]],[11,"add_assign","","",38,[[]]],[11,"add_assign","","",38,[[]]],[11,"add_assign","","",40,[[]]],[11,"add_assign","","",40,[[]]],[11,"add_assign","","",41,[[]]],[11,"add_assign","","",41,[[]]],[11,"add_assign","","",42,[[]]],[11,"add_assign","","",42,[[]]],[11,"add_assign","","",44,[[]]],[11,"add_assign","","",44,[[]]],[11,"add_assign","","",45,[[]]],[11,"add_assign","","",45,[[]]],[11,"add_assign","","",46,[[]]],[11,"add_assign","","",46,[[]]],[11,"add_assign","","",51,[[]]],[11,"add_assign","","",51,[[]]],[11,"add_assign","","",52,[[]]],[11,"add_assign","","",52,[[]]],[11,"add_assign","","",54,[[]]],[11,"add_assign","","",54,[[]]],[11,"add_assign","","",55,[[]]],[11,"add_assign","","",55,[[]]],[11,"add_assign","","",57,[[]]],[11,"add_assign","","",57,[[]]],[11,"add_assign","","",58,[[]]],[11,"add_assign","","",58,[[]]],[11,"add_assign","","",60,[[]]],[11,"add_assign","","",60,[[]]],[11,"add_assign","","",61,[[]]],[11,"add_assign","","",61,[[]]],[11,"add_assign","","",62,[[]]],[11,"add_assign","","",62,[[]]],[11,"add_assign","","",64,[[]]],[11,"add_assign","","",64,[[]]],[11,"add_assign","","",65,[[]]],[11,"add_assign","","",65,[[]]],[11,"add_assign","","",66,[[]]],[11,"add_assign","","",66,[[]]],[11,"add_assign","","",68,[[]]],[11,"add_assign","","",68,[[]]],[11,"add_assign","","",69,[[]]],[11,"add_assign","","",69,[[]]],[11,"add_assign","","",74,[[]]],[11,"add_assign","","",74,[[]]],[11,"add_assign","","",75,[[]]],[11,"add_assign","","",75,[[]]],[11,"add_assign","","",77,[[]]],[11,"add_assign","","",77,[[]]],[11,"add_assign","","",78,[[]]],[11,"add_assign","","",78,[[]]],[11,"add_assign","","",80,[[]]],[11,"add_assign","","",80,[[]]],[11,"add_assign","","",81,[[]]],[11,"add_assign","","",81,[[]]],[11,"add_assign","","",82,[[]]],[11,"add_assign","","",82,[[]]],[11,"add_assign","","",84,[[]]],[11,"add_assign","","",84,[[]]],[11,"add_assign","","",85,[[]]],[11,"add_assign","","",85,[[]]],[11,"add_assign","","",86,[[]]],[11,"add_assign","","",86,[[]]],[11,"add_assign","","",88,[[]]],[11,"add_assign","","",88,[[]]],[11,"add_assign","","",89,[[]]],[11,"add_assign","","",89,[[]]],[11,"add_assign","","",48,[[]]],[11,"add_assign","","",48,[[]]],[11,"add_assign","","",49,[[]]],[11,"add_assign","","",49,[[]]],[11,"add_assign","","",71,[[]]],[11,"add_assign","","",71,[[]]],[11,"add_assign","","",72,[[]]],[11,"add_assign","","",72,[[]]],[11,"add_assign","","",91,[[]]],[11,"add_assign","","",91,[[]]],[11,"add_assign","","",92,[[]]],[11,"add_assign","","",92,[[]]],[11,"sub_assign","","",15,[[]]],[11,"sub_assign","","",15,[[]]],[11,"sub_assign","","",16,[[]]],[11,"sub_assign","","",16,[[]]],[11,"sub_assign","","",18,[[]]],[11,"sub_assign","","",18,[[]]],[11,"sub_assign","","",19,[[]]],[11,"sub_assign","","",19,[[]]],[11,"sub_assign","","",21,[[]]],[11,"sub_assign","","",21,[[]]],[11,"sub_assign","","",22,[[]]],[11,"sub_assign","","",22,[[]]],[11,"sub_assign","","",24,[[]]],[11,"sub_assign","","",24,[[]]],[11,"sub_assign","","",25,[[]]],[11,"sub_assign","","",25,[[]]],[11,"sub_assign","","",27,[[]]],[11,"sub_assign","","",27,[[]]],[11,"sub_assign","","",28,[[]]],[11,"sub_assign","","",28,[[]]],[11,"sub_assign","","",30,[[]]],[11,"sub_assign","","",30,[[]]],[11,"sub_assign","","",31,[[]]],[11,"sub_assign","","",31,[[]]],[11,"sub_assign","","",32,[[]]],[11,"sub_assign","","",32,[[]]],[11,"sub_assign","","",34,[[]]],[11,"sub_assign","","",34,[[]]],[11,"sub_assign","","",35,[[]]],[11,"sub_assign","","",35,[[]]],[11,"sub_assign","","",37,[[]]],[11,"sub_assign","","",37,[[]]],[11,"sub_assign","","",38,[[]]],[11,"sub_assign","","",38,[[]]],[11,"sub_assign","","",40,[[]]],[11,"sub_assign","","",40,[[]]],[11,"sub_assign","","",41,[[]]],[11,"sub_assign","","",41,[[]]],[11,"sub_assign","","",42,[[]]],[11,"sub_assign","","",42,[[]]],[11,"sub_assign","","",44,[[]]],[11,"sub_assign","","",44,[[]]],[11,"sub_assign","","",45,[[]]],[11,"sub_assign","","",45,[[]]],[11,"sub_assign","","",46,[[]]],[11,"sub_assign","","",46,[[]]],[11,"sub_assign","","",51,[[]]],[11,"sub_assign","","",51,[[]]],[11,"sub_assign","","",52,[[]]],[11,"sub_assign","","",52,[[]]],[11,"sub_assign","","",54,[[]]],[11,"sub_assign","","",54,[[]]],[11,"sub_assign","","",55,[[]]],[11,"sub_assign","","",55,[[]]],[11,"sub_assign","","",57,[[]]],[11,"sub_assign","","",57,[[]]],[11,"sub_assign","","",58,[[]]],[11,"sub_assign","","",58,[[]]],[11,"sub_assign","","",60,[[]]],[11,"sub_assign","","",60,[[]]],[11,"sub_assign","","",61,[[]]],[11,"sub_assign","","",61,[[]]],[11,"sub_assign","","",62,[[]]],[11,"sub_assign","","",62,[[]]],[11,"sub_assign","","",64,[[]]],[11,"sub_assign","","",64,[[]]],[11,"sub_assign","","",65,[[]]],[11,"sub_assign","","",65,[[]]],[11,"sub_assign","","",66,[[]]],[11,"sub_assign","","",66,[[]]],[11,"sub_assign","","",68,[[]]],[11,"sub_assign","","",68,[[]]],[11,"sub_assign","","",69,[[]]],[11,"sub_assign","","",69,[[]]],[11,"sub_assign","","",74,[[]]],[11,"sub_assign","","",74,[[]]],[11,"sub_assign","","",75,[[]]],[11,"sub_assign","","",75,[[]]],[11,"sub_assign","","",77,[[]]],[11,"sub_assign","","",77,[[]]],[11,"sub_assign","","",78,[[]]],[11,"sub_assign","","",78,[[]]],[11,"sub_assign","","",80,[[]]],[11,"sub_assign","","",80,[[]]],[11,"sub_assign","","",81,[[]]],[11,"sub_assign","","",81,[[]]],[11,"sub_assign","","",82,[[]]],[11,"sub_assign","","",82,[[]]],[11,"sub_assign","","",84,[[]]],[11,"sub_assign","","",84,[[]]],[11,"sub_assign","","",85,[[]]],[11,"sub_assign","","",85,[[]]],[11,"sub_assign","","",86,[[]]],[11,"sub_assign","","",86,[[]]],[11,"sub_assign","","",88,[[]]],[11,"sub_assign","","",88,[[]]],[11,"sub_assign","","",89,[[]]],[11,"sub_assign","","",89,[[]]],[11,"sub_assign","","",48,[[]]],[11,"sub_assign","","",48,[[]]],[11,"sub_assign","","",49,[[]]],[11,"sub_assign","","",49,[[]]],[11,"sub_assign","","",71,[[]]],[11,"sub_assign","","",71,[[]]],[11,"sub_assign","","",72,[[]]],[11,"sub_assign","","",72,[[]]],[11,"sub_assign","","",91,[[]]],[11,"sub_assign","","",91,[[]]],[11,"sub_assign","","",92,[[]]],[11,"sub_assign","","",92,[[]]],[11,"mul_assign","","",15,[[]]],[11,"mul_assign","","",15,[[]]],[11,"mul_assign","","",16,[[]]],[11,"mul_assign","","",16,[[]]],[11,"mul_assign","","",18,[[]]],[11,"mul_assign","","",18,[[]]],[11,"mul_assign","","",19,[[]]],[11,"mul_assign","","",19,[[]]],[11,"mul_assign","","",21,[[]]],[11,"mul_assign","","",21,[[]]],[11,"mul_assign","","",22,[[]]],[11,"mul_assign","","",22,[[]]],[11,"mul_assign","","",24,[[]]],[11,"mul_assign","","",24,[[]]],[11,"mul_assign","","",25,[[]]],[11,"mul_assign","","",25,[[]]],[11,"mul_assign","","",27,[[]]],[11,"mul_assign","","",27,[[]]],[11,"mul_assign","","",28,[[]]],[11,"mul_assign","","",28,[[]]],[11,"mul_assign","","",30,[[]]],[11,"mul_assign","","",30,[[]]],[11,"mul_assign","","",31,[[]]],[11,"mul_assign","","",31,[[]]],[11,"mul_assign","","",32,[[]]],[11,"mul_assign","","",32,[[]]],[11,"mul_assign","","",34,[[]]],[11,"mul_assign","","",34,[[]]],[11,"mul_assign","","",35,[[]]],[11,"mul_assign","","",35,[[]]],[11,"mul_assign","","",37,[[]]],[11,"mul_assign","","",37,[[]]],[11,"mul_assign","","",38,[[]]],[11,"mul_assign","","",38,[[]]],[11,"mul_assign","","",40,[[]]],[11,"mul_assign","","",40,[[]]],[11,"mul_assign","","",41,[[]]],[11,"mul_assign","","",41,[[]]],[11,"mul_assign","","",42,[[]]],[11,"mul_assign","","",42,[[]]],[11,"mul_assign","","",44,[[]]],[11,"mul_assign","","",44,[[]]],[11,"mul_assign","","",45,[[]]],[11,"mul_assign","","",45,[[]]],[11,"mul_assign","","",46,[[]]],[11,"mul_assign","","",46,[[]]],[11,"mul_assign","","",51,[[]]],[11,"mul_assign","","",51,[[]]],[11,"mul_assign","","",52,[[]]],[11,"mul_assign","","",52,[[]]],[11,"mul_assign","","",54,[[]]],[11,"mul_assign","","",54,[[]]],[11,"mul_assign","","",55,[[]]],[11,"mul_assign","","",55,[[]]],[11,"mul_assign","","",57,[[]]],[11,"mul_assign","","",57,[[]]],[11,"mul_assign","","",58,[[]]],[11,"mul_assign","","",58,[[]]],[11,"mul_assign","","",60,[[]]],[11,"mul_assign","","",60,[[]]],[11,"mul_assign","","",61,[[]]],[11,"mul_assign","","",61,[[]]],[11,"mul_assign","","",62,[[]]],[11,"mul_assign","","",62,[[]]],[11,"mul_assign","","",64,[[]]],[11,"mul_assign","","",64,[[]]],[11,"mul_assign","","",65,[[]]],[11,"mul_assign","","",65,[[]]],[11,"mul_assign","","",66,[[]]],[11,"mul_assign","","",66,[[]]],[11,"mul_assign","","",68,[[]]],[11,"mul_assign","","",68,[[]]],[11,"mul_assign","","",69,[[]]],[11,"mul_assign","","",69,[[]]],[11,"mul_assign","","",74,[[]]],[11,"mul_assign","","",74,[[]]],[11,"mul_assign","","",75,[[]]],[11,"mul_assign","","",75,[[]]],[11,"mul_assign","","",77,[[]]],[11,"mul_assign","","",77,[[]]],[11,"mul_assign","","",78,[[]]],[11,"mul_assign","","",78,[[]]],[11,"mul_assign","","",80,[[]]],[11,"mul_assign","","",80,[[]]],[11,"mul_assign","","",81,[[]]],[11,"mul_assign","","",81,[[]]],[11,"mul_assign","","",82,[[]]],[11,"mul_assign","","",82,[[]]],[11,"mul_assign","","",84,[[]]],[11,"mul_assign","","",84,[[]]],[11,"mul_assign","","",85,[[]]],[11,"mul_assign","","",85,[[]]],[11,"mul_assign","","",86,[[]]],[11,"mul_assign","","",86,[[]]],[11,"mul_assign","","",88,[[]]],[11,"mul_assign","","",88,[[]]],[11,"mul_assign","","",89,[[]]],[11,"mul_assign","","",89,[[]]],[11,"mul_assign","","",48,[[]]],[11,"mul_assign","","",48,[[]]],[11,"mul_assign","","",49,[[]]],[11,"mul_assign","","",49,[[]]],[11,"mul_assign","","",71,[[]]],[11,"mul_assign","","",71,[[]]],[11,"mul_assign","","",72,[[]]],[11,"mul_assign","","",72,[[]]],[11,"mul_assign","","",91,[[]]],[11,"mul_assign","","",91,[[]]],[11,"mul_assign","","",92,[[]]],[11,"mul_assign","","",92,[[]]],[11,"div_assign","","",15,[[]]],[11,"div_assign","","",15,[[]]],[11,"div_assign","","",16,[[]]],[11,"div_assign","","",16,[[]]],[11,"div_assign","","",18,[[]]],[11,"div_assign","","",18,[[]]],[11,"div_assign","","",19,[[]]],[11,"div_assign","","",19,[[]]],[11,"div_assign","","",21,[[]]],[11,"div_assign","","",21,[[]]],[11,"div_assign","","",22,[[]]],[11,"div_assign","","",22,[[]]],[11,"div_assign","","",24,[[]]],[11,"div_assign","","",24,[[]]],[11,"div_assign","","",25,[[]]],[11,"div_assign","","",25,[[]]],[11,"div_assign","","",27,[[]]],[11,"div_assign","","",27,[[]]],[11,"div_assign","","",28,[[]]],[11,"div_assign","","",28,[[]]],[11,"div_assign","","",30,[[]]],[11,"div_assign","","",30,[[]]],[11,"div_assign","","",31,[[]]],[11,"div_assign","","",31,[[]]],[11,"div_assign","","",32,[[]]],[11,"div_assign","","",32,[[]]],[11,"div_assign","","",34,[[]]],[11,"div_assign","","",34,[[]]],[11,"div_assign","","",35,[[]]],[11,"div_assign","","",35,[[]]],[11,"div_assign","","",37,[[]]],[11,"div_assign","","",37,[[]]],[11,"div_assign","","",38,[[]]],[11,"div_assign","","",38,[[]]],[11,"div_assign","","",40,[[]]],[11,"div_assign","","",40,[[]]],[11,"div_assign","","",41,[[]]],[11,"div_assign","","",41,[[]]],[11,"div_assign","","",42,[[]]],[11,"div_assign","","",42,[[]]],[11,"div_assign","","",44,[[]]],[11,"div_assign","","",44,[[]]],[11,"div_assign","","",45,[[]]],[11,"div_assign","","",45,[[]]],[11,"div_assign","","",46,[[]]],[11,"div_assign","","",46,[[]]],[11,"div_assign","","",51,[[]]],[11,"div_assign","","",51,[[]]],[11,"div_assign","","",52,[[]]],[11,"div_assign","","",52,[[]]],[11,"div_assign","","",54,[[]]],[11,"div_assign","","",54,[[]]],[11,"div_assign","","",55,[[]]],[11,"div_assign","","",55,[[]]],[11,"div_assign","","",57,[[]]],[11,"div_assign","","",57,[[]]],[11,"div_assign","","",58,[[]]],[11,"div_assign","","",58,[[]]],[11,"div_assign","","",60,[[]]],[11,"div_assign","","",60,[[]]],[11,"div_assign","","",61,[[]]],[11,"div_assign","","",61,[[]]],[11,"div_assign","","",62,[[]]],[11,"div_assign","","",62,[[]]],[11,"div_assign","","",64,[[]]],[11,"div_assign","","",64,[[]]],[11,"div_assign","","",65,[[]]],[11,"div_assign","","",65,[[]]],[11,"div_assign","","",66,[[]]],[11,"div_assign","","",66,[[]]],[11,"div_assign","","",68,[[]]],[11,"div_assign","","",68,[[]]],[11,"div_assign","","",69,[[]]],[11,"div_assign","","",69,[[]]],[11,"div_assign","","",74,[[]]],[11,"div_assign","","",74,[[]]],[11,"div_assign","","",75,[[]]],[11,"div_assign","","",75,[[]]],[11,"div_assign","","",77,[[]]],[11,"div_assign","","",77,[[]]],[11,"div_assign","","",78,[[]]],[11,"div_assign","","",78,[[]]],[11,"div_assign","","",80,[[]]],[11,"div_assign","","",80,[[]]],[11,"div_assign","","",81,[[]]],[11,"div_assign","","",81,[[]]],[11,"div_assign","","",82,[[]]],[11,"div_assign","","",82,[[]]],[11,"div_assign","","",84,[[]]],[11,"div_assign","","",84,[[]]],[11,"div_assign","","",85,[[]]],[11,"div_assign","","",85,[[]]],[11,"div_assign","","",86,[[]]],[11,"div_assign","","",86,[[]]],[11,"div_assign","","",88,[[]]],[11,"div_assign","","",88,[[]]],[11,"div_assign","","",89,[[]]],[11,"div_assign","","",89,[[]]],[11,"div_assign","","",48,[[]]],[11,"div_assign","","",48,[[]]],[11,"div_assign","","",49,[[]]],[11,"div_assign","","",49,[[]]],[11,"div_assign","","",71,[[]]],[11,"div_assign","","",71,[[]]],[11,"div_assign","","",72,[[]]],[11,"div_assign","","",72,[[]]],[11,"div_assign","","",91,[[]]],[11,"div_assign","","",91,[[]]],[11,"div_assign","","",92,[[]]],[11,"div_assign","","",92,[[]]],[11,"rem_assign","","",15,[[]]],[11,"rem_assign","","",15,[[]]],[11,"rem_assign","","",16,[[]]],[11,"rem_assign","","",16,[[]]],[11,"rem_assign","","",18,[[]]],[11,"rem_assign","","",18,[[]]],[11,"rem_assign","","",19,[[]]],[11,"rem_assign","","",19,[[]]],[11,"rem_assign","","",21,[[]]],[11,"rem_assign","","",21,[[]]],[11,"rem_assign","","",22,[[]]],[11,"rem_assign","","",22,[[]]],[11,"rem_assign","","",24,[[]]],[11,"rem_assign","","",24,[[]]],[11,"rem_assign","","",25,[[]]],[11,"rem_assign","","",25,[[]]],[11,"rem_assign","","",27,[[]]],[11,"rem_assign","","",27,[[]]],[11,"rem_assign","","",28,[[]]],[11,"rem_assign","","",28,[[]]],[11,"rem_assign","","",30,[[]]],[11,"rem_assign","","",30,[[]]],[11,"rem_assign","","",31,[[]]],[11,"rem_assign","","",31,[[]]],[11,"rem_assign","","",32,[[]]],[11,"rem_assign","","",32,[[]]],[11,"rem_assign","","",34,[[]]],[11,"rem_assign","","",34,[[]]],[11,"rem_assign","","",35,[[]]],[11,"rem_assign","","",35,[[]]],[11,"rem_assign","","",37,[[]]],[11,"rem_assign","","",37,[[]]],[11,"rem_assign","","",38,[[]]],[11,"rem_assign","","",38,[[]]],[11,"rem_assign","","",40,[[]]],[11,"rem_assign","","",40,[[]]],[11,"rem_assign","","",41,[[]]],[11,"rem_assign","","",41,[[]]],[11,"rem_assign","","",42,[[]]],[11,"rem_assign","","",42,[[]]],[11,"rem_assign","","",44,[[]]],[11,"rem_assign","","",44,[[]]],[11,"rem_assign","","",45,[[]]],[11,"rem_assign","","",45,[[]]],[11,"rem_assign","","",46,[[]]],[11,"rem_assign","","",46,[[]]],[11,"rem_assign","","",51,[[]]],[11,"rem_assign","","",51,[[]]],[11,"rem_assign","","",52,[[]]],[11,"rem_assign","","",52,[[]]],[11,"rem_assign","","",54,[[]]],[11,"rem_assign","","",54,[[]]],[11,"rem_assign","","",55,[[]]],[11,"rem_assign","","",55,[[]]],[11,"rem_assign","","",57,[[]]],[11,"rem_assign","","",57,[[]]],[11,"rem_assign","","",58,[[]]],[11,"rem_assign","","",58,[[]]],[11,"rem_assign","","",60,[[]]],[11,"rem_assign","","",60,[[]]],[11,"rem_assign","","",61,[[]]],[11,"rem_assign","","",61,[[]]],[11,"rem_assign","","",62,[[]]],[11,"rem_assign","","",62,[[]]],[11,"rem_assign","","",64,[[]]],[11,"rem_assign","","",64,[[]]],[11,"rem_assign","","",65,[[]]],[11,"rem_assign","","",65,[[]]],[11,"rem_assign","","",66,[[]]],[11,"rem_assign","","",66,[[]]],[11,"rem_assign","","",68,[[]]],[11,"rem_assign","","",68,[[]]],[11,"rem_assign","","",69,[[]]],[11,"rem_assign","","",69,[[]]],[11,"rem_assign","","",74,[[]]],[11,"rem_assign","","",74,[[]]],[11,"rem_assign","","",75,[[]]],[11,"rem_assign","","",75,[[]]],[11,"rem_assign","","",77,[[]]],[11,"rem_assign","","",77,[[]]],[11,"rem_assign","","",78,[[]]],[11,"rem_assign","","",78,[[]]],[11,"rem_assign","","",80,[[]]],[11,"rem_assign","","",80,[[]]],[11,"rem_assign","","",81,[[]]],[11,"rem_assign","","",81,[[]]],[11,"rem_assign","","",82,[[]]],[11,"rem_assign","","",82,[[]]],[11,"rem_assign","","",84,[[]]],[11,"rem_assign","","",84,[[]]],[11,"rem_assign","","",85,[[]]],[11,"rem_assign","","",85,[[]]],[11,"rem_assign","","",86,[[]]],[11,"rem_assign","","",86,[[]]],[11,"rem_assign","","",88,[[]]],[11,"rem_assign","","",88,[[]]],[11,"rem_assign","","",89,[[]]],[11,"rem_assign","","",89,[[]]],[11,"rem_assign","","",48,[[]]],[11,"rem_assign","","",48,[[]]],[11,"rem_assign","","",49,[[]]],[11,"rem_assign","","",49,[[]]],[11,"rem_assign","","",71,[[]]],[11,"rem_assign","","",71,[[]]],[11,"rem_assign","","",72,[[]]],[11,"rem_assign","","",72,[[]]],[11,"rem_assign","","",91,[[]]],[11,"rem_assign","","",91,[[]]],[11,"rem_assign","","",92,[[]]],[11,"rem_assign","","",92,[[]]],[11,"not","","",15,[[]]],[11,"not","","",16,[[]]],[11,"not","","",17,[[]]],[11,"not","","",18,[[]]],[11,"not","","",19,[[]]],[11,"not","","",20,[[]]],[11,"not","","",21,[[]]],[11,"not","","",22,[[]]],[11,"not","","",23,[[]]],[11,"not","","",24,[[]]],[11,"not","","",25,[[]]],[11,"not","","",26,[[]]],[11,"not","","",27,[[]]],[11,"not","","",28,[[]]],[11,"not","","",29,[[]]],[11,"not","","",30,[[]]],[11,"not","","",31,[[]]],[11,"not","","",33,[[]]],[11,"not","","",34,[[]]],[11,"not","","",35,[[]]],[11,"not","","",36,[[]]],[11,"not","","",37,[[]]],[11,"not","","",38,[[]]],[11,"not","","",39,[[]]],[11,"not","","",40,[[]]],[11,"not","","",41,[[]]],[11,"not","","",43,[[]]],[11,"not","","",44,[[]]],[11,"not","","",45,[[]]],[11,"not","","",47,[[]]],[11,"not","","",51,[[]]],[11,"not","","",52,[[]]],[11,"not","","",53,[[]]],[11,"not","","",54,[[]]],[11,"not","","",55,[[]]],[11,"not","","",56,[[]]],[11,"not","","",57,[[]]],[11,"not","","",58,[[]]],[11,"not","","",59,[[]]],[11,"not","","",60,[[]]],[11,"not","","",61,[[]]],[11,"not","","",63,[[]]],[11,"not","","",64,[[]]],[11,"not","","",65,[[]]],[11,"not","","",67,[[]]],[11,"not","","",68,[[]]],[11,"not","","",69,[[]]],[11,"not","","",70,[[]]],[11,"not","","",74,[[]]],[11,"not","","",75,[[]]],[11,"not","","",76,[[]]],[11,"not","","",77,[[]]],[11,"not","","",78,[[]]],[11,"not","","",79,[[]]],[11,"not","","",80,[[]]],[11,"not","","",81,[[]]],[11,"not","","",83,[[]]],[11,"not","","",84,[[]]],[11,"not","","",85,[[]]],[11,"not","","",87,[[]]],[11,"not","","",88,[[]]],[11,"not","","",89,[[]]],[11,"not","","",90,[[]]],[11,"not","","",48,[[]]],[11,"not","","",49,[[]]],[11,"not","","",50,[[]]],[11,"not","","",71,[[]]],[11,"not","","",72,[[]]],[11,"not","","",73,[[]]],[11,"not","","",91,[[]]],[11,"not","","",92,[[]]],[11,"not","","",93,[[]]],[11,"bitand","","",15,[[]]],[11,"bitand","","",15,[[]]],[11,"bitand","","",16,[[]]],[11,"bitand","","",16,[[]]],[11,"bitand","","",17,[[]]],[11,"bitand","","",17,[[]]],[11,"bitand","","",18,[[]]],[11,"bitand","","",18,[[]]],[11,"bitand","","",19,[[]]],[11,"bitand","","",19,[[]]],[11,"bitand","","",20,[[]]],[11,"bitand","","",20,[[]]],[11,"bitand","","",21,[[]]],[11,"bitand","","",21,[[]]],[11,"bitand","","",22,[[]]],[11,"bitand","","",22,[[]]],[11,"bitand","","",23,[[]]],[11,"bitand","","",23,[[]]],[11,"bitand","","",24,[[]]],[11,"bitand","","",24,[[]]],[11,"bitand","","",25,[[]]],[11,"bitand","","",25,[[]]],[11,"bitand","","",26,[[]]],[11,"bitand","","",26,[[]]],[11,"bitand","","",27,[[]]],[11,"bitand","","",27,[[]]],[11,"bitand","","",28,[[]]],[11,"bitand","","",28,[[]]],[11,"bitand","","",29,[[]]],[11,"bitand","","",29,[[]]],[11,"bitand","","",30,[[]]],[11,"bitand","","",30,[[]]],[11,"bitand","","",31,[[]]],[11,"bitand","","",31,[[]]],[11,"bitand","","",33,[[]]],[11,"bitand","","",33,[[]]],[11,"bitand","","",34,[[]]],[11,"bitand","","",34,[[]]],[11,"bitand","","",35,[[]]],[11,"bitand","","",35,[[]]],[11,"bitand","","",36,[[]]],[11,"bitand","","",36,[[]]],[11,"bitand","","",37,[[]]],[11,"bitand","","",37,[[]]],[11,"bitand","","",38,[[]]],[11,"bitand","","",38,[[]]],[11,"bitand","","",39,[[]]],[11,"bitand","","",39,[[]]],[11,"bitand","","",40,[[]]],[11,"bitand","","",40,[[]]],[11,"bitand","","",41,[[]]],[11,"bitand","","",41,[[]]],[11,"bitand","","",43,[[]]],[11,"bitand","","",43,[[]]],[11,"bitand","","",44,[[]]],[11,"bitand","","",44,[[]]],[11,"bitand","","",45,[[]]],[11,"bitand","","",45,[[]]],[11,"bitand","","",47,[[]]],[11,"bitand","","",47,[[]]],[11,"bitand","","",51,[[]]],[11,"bitand","","",51,[[]]],[11,"bitand","","",52,[[]]],[11,"bitand","","",52,[[]]],[11,"bitand","","",53,[[]]],[11,"bitand","","",53,[[]]],[11,"bitand","","",54,[[]]],[11,"bitand","","",54,[[]]],[11,"bitand","","",55,[[]]],[11,"bitand","","",55,[[]]],[11,"bitand","","",56,[[]]],[11,"bitand","","",56,[[]]],[11,"bitand","","",57,[[]]],[11,"bitand","","",57,[[]]],[11,"bitand","","",58,[[]]],[11,"bitand","","",58,[[]]],[11,"bitand","","",59,[[]]],[11,"bitand","","",59,[[]]],[11,"bitand","","",60,[[]]],[11,"bitand","","",60,[[]]],[11,"bitand","","",61,[[]]],[11,"bitand","","",61,[[]]],[11,"bitand","","",63,[[]]],[11,"bitand","","",63,[[]]],[11,"bitand","","",64,[[]]],[11,"bitand","","",64,[[]]],[11,"bitand","","",65,[[]]],[11,"bitand","","",65,[[]]],[11,"bitand","","",67,[[]]],[11,"bitand","","",67,[[]]],[11,"bitand","","",68,[[]]],[11,"bitand","","",68,[[]]],[11,"bitand","","",69,[[]]],[11,"bitand","","",69,[[]]],[11,"bitand","","",70,[[]]],[11,"bitand","","",70,[[]]],[11,"bitand","","",74,[[]]],[11,"bitand","","",74,[[]]],[11,"bitand","","",75,[[]]],[11,"bitand","","",75,[[]]],[11,"bitand","","",76,[[]]],[11,"bitand","","",76,[[]]],[11,"bitand","","",77,[[]]],[11,"bitand","","",77,[[]]],[11,"bitand","","",78,[[]]],[11,"bitand","","",78,[[]]],[11,"bitand","","",79,[[]]],[11,"bitand","","",79,[[]]],[11,"bitand","","",80,[[]]],[11,"bitand","","",80,[[]]],[11,"bitand","","",81,[[]]],[11,"bitand","","",81,[[]]],[11,"bitand","","",83,[[]]],[11,"bitand","","",83,[[]]],[11,"bitand","","",84,[[]]],[11,"bitand","","",84,[[]]],[11,"bitand","","",85,[[]]],[11,"bitand","","",85,[[]]],[11,"bitand","","",87,[[]]],[11,"bitand","","",87,[[]]],[11,"bitand","","",88,[[]]],[11,"bitand","","",88,[[]]],[11,"bitand","","",89,[[]]],[11,"bitand","","",89,[[]]],[11,"bitand","","",90,[[]]],[11,"bitand","","",90,[[]]],[11,"bitand","","",48,[[]]],[11,"bitand","","",48,[[]]],[11,"bitand","","",49,[[]]],[11,"bitand","","",49,[[]]],[11,"bitand","","",50,[[]]],[11,"bitand","","",50,[[]]],[11,"bitand","","",71,[[]]],[11,"bitand","","",71,[[]]],[11,"bitand","","",72,[[]]],[11,"bitand","","",72,[[]]],[11,"bitand","","",73,[[]]],[11,"bitand","","",73,[[]]],[11,"bitand","","",91,[[]]],[11,"bitand","","",91,[[]]],[11,"bitand","","",92,[[]]],[11,"bitand","","",92,[[]]],[11,"bitand","","",93,[[]]],[11,"bitand","","",93,[[]]],[11,"bitor","","",15,[[]]],[11,"bitor","","",15,[[]]],[11,"bitor","","",16,[[]]],[11,"bitor","","",16,[[]]],[11,"bitor","","",17,[[]]],[11,"bitor","","",17,[[]]],[11,"bitor","","",18,[[]]],[11,"bitor","","",18,[[]]],[11,"bitor","","",19,[[]]],[11,"bitor","","",19,[[]]],[11,"bitor","","",20,[[]]],[11,"bitor","","",20,[[]]],[11,"bitor","","",21,[[]]],[11,"bitor","","",21,[[]]],[11,"bitor","","",22,[[]]],[11,"bitor","","",22,[[]]],[11,"bitor","","",23,[[]]],[11,"bitor","","",23,[[]]],[11,"bitor","","",24,[[]]],[11,"bitor","","",24,[[]]],[11,"bitor","","",25,[[]]],[11,"bitor","","",25,[[]]],[11,"bitor","","",26,[[]]],[11,"bitor","","",26,[[]]],[11,"bitor","","",27,[[]]],[11,"bitor","","",27,[[]]],[11,"bitor","","",28,[[]]],[11,"bitor","","",28,[[]]],[11,"bitor","","",29,[[]]],[11,"bitor","","",29,[[]]],[11,"bitor","","",30,[[]]],[11,"bitor","","",30,[[]]],[11,"bitor","","",31,[[]]],[11,"bitor","","",31,[[]]],[11,"bitor","","",33,[[]]],[11,"bitor","","",33,[[]]],[11,"bitor","","",34,[[]]],[11,"bitor","","",34,[[]]],[11,"bitor","","",35,[[]]],[11,"bitor","","",35,[[]]],[11,"bitor","","",36,[[]]],[11,"bitor","","",36,[[]]],[11,"bitor","","",37,[[]]],[11,"bitor","","",37,[[]]],[11,"bitor","","",38,[[]]],[11,"bitor","","",38,[[]]],[11,"bitor","","",39,[[]]],[11,"bitor","","",39,[[]]],[11,"bitor","","",40,[[]]],[11,"bitor","","",40,[[]]],[11,"bitor","","",41,[[]]],[11,"bitor","","",41,[[]]],[11,"bitor","","",43,[[]]],[11,"bitor","","",43,[[]]],[11,"bitor","","",44,[[]]],[11,"bitor","","",44,[[]]],[11,"bitor","","",45,[[]]],[11,"bitor","","",45,[[]]],[11,"bitor","","",47,[[]]],[11,"bitor","","",47,[[]]],[11,"bitor","","",51,[[]]],[11,"bitor","","",51,[[]]],[11,"bitor","","",52,[[]]],[11,"bitor","","",52,[[]]],[11,"bitor","","",53,[[]]],[11,"bitor","","",53,[[]]],[11,"bitor","","",54,[[]]],[11,"bitor","","",54,[[]]],[11,"bitor","","",55,[[]]],[11,"bitor","","",55,[[]]],[11,"bitor","","",56,[[]]],[11,"bitor","","",56,[[]]],[11,"bitor","","",57,[[]]],[11,"bitor","","",57,[[]]],[11,"bitor","","",58,[[]]],[11,"bitor","","",58,[[]]],[11,"bitor","","",59,[[]]],[11,"bitor","","",59,[[]]],[11,"bitor","","",60,[[]]],[11,"bitor","","",60,[[]]],[11,"bitor","","",61,[[]]],[11,"bitor","","",61,[[]]],[11,"bitor","","",63,[[]]],[11,"bitor","","",63,[[]]],[11,"bitor","","",64,[[]]],[11,"bitor","","",64,[[]]],[11,"bitor","","",65,[[]]],[11,"bitor","","",65,[[]]],[11,"bitor","","",67,[[]]],[11,"bitor","","",67,[[]]],[11,"bitor","","",68,[[]]],[11,"bitor","","",68,[[]]],[11,"bitor","","",69,[[]]],[11,"bitor","","",69,[[]]],[11,"bitor","","",70,[[]]],[11,"bitor","","",70,[[]]],[11,"bitor","","",74,[[]]],[11,"bitor","","",74,[[]]],[11,"bitor","","",75,[[]]],[11,"bitor","","",75,[[]]],[11,"bitor","","",76,[[]]],[11,"bitor","","",76,[[]]],[11,"bitor","","",77,[[]]],[11,"bitor","","",77,[[]]],[11,"bitor","","",78,[[]]],[11,"bitor","","",78,[[]]],[11,"bitor","","",79,[[]]],[11,"bitor","","",79,[[]]],[11,"bitor","","",80,[[]]],[11,"bitor","","",80,[[]]],[11,"bitor","","",81,[[]]],[11,"bitor","","",81,[[]]],[11,"bitor","","",83,[[]]],[11,"bitor","","",83,[[]]],[11,"bitor","","",84,[[]]],[11,"bitor","","",84,[[]]],[11,"bitor","","",85,[[]]],[11,"bitor","","",85,[[]]],[11,"bitor","","",87,[[]]],[11,"bitor","","",87,[[]]],[11,"bitor","","",88,[[]]],[11,"bitor","","",88,[[]]],[11,"bitor","","",89,[[]]],[11,"bitor","","",89,[[]]],[11,"bitor","","",90,[[]]],[11,"bitor","","",90,[[]]],[11,"bitor","","",48,[[]]],[11,"bitor","","",48,[[]]],[11,"bitor","","",49,[[]]],[11,"bitor","","",49,[[]]],[11,"bitor","","",50,[[]]],[11,"bitor","","",50,[[]]],[11,"bitor","","",71,[[]]],[11,"bitor","","",71,[[]]],[11,"bitor","","",72,[[]]],[11,"bitor","","",72,[[]]],[11,"bitor","","",73,[[]]],[11,"bitor","","",73,[[]]],[11,"bitor","","",91,[[]]],[11,"bitor","","",91,[[]]],[11,"bitor","","",92,[[]]],[11,"bitor","","",92,[[]]],[11,"bitor","","",93,[[]]],[11,"bitor","","",93,[[]]],[11,"bitxor","","",15,[[]]],[11,"bitxor","","",15,[[]]],[11,"bitxor","","",16,[[]]],[11,"bitxor","","",16,[[]]],[11,"bitxor","","",17,[[]]],[11,"bitxor","","",17,[[]]],[11,"bitxor","","",18,[[]]],[11,"bitxor","","",18,[[]]],[11,"bitxor","","",19,[[]]],[11,"bitxor","","",19,[[]]],[11,"bitxor","","",20,[[]]],[11,"bitxor","","",20,[[]]],[11,"bitxor","","",21,[[]]],[11,"bitxor","","",21,[[]]],[11,"bitxor","","",22,[[]]],[11,"bitxor","","",22,[[]]],[11,"bitxor","","",23,[[]]],[11,"bitxor","","",23,[[]]],[11,"bitxor","","",24,[[]]],[11,"bitxor","","",24,[[]]],[11,"bitxor","","",25,[[]]],[11,"bitxor","","",25,[[]]],[11,"bitxor","","",26,[[]]],[11,"bitxor","","",26,[[]]],[11,"bitxor","","",27,[[]]],[11,"bitxor","","",27,[[]]],[11,"bitxor","","",28,[[]]],[11,"bitxor","","",28,[[]]],[11,"bitxor","","",29,[[]]],[11,"bitxor","","",29,[[]]],[11,"bitxor","","",30,[[]]],[11,"bitxor","","",30,[[]]],[11,"bitxor","","",31,[[]]],[11,"bitxor","","",31,[[]]],[11,"bitxor","","",33,[[]]],[11,"bitxor","","",33,[[]]],[11,"bitxor","","",34,[[]]],[11,"bitxor","","",34,[[]]],[11,"bitxor","","",35,[[]]],[11,"bitxor","","",35,[[]]],[11,"bitxor","","",36,[[]]],[11,"bitxor","","",36,[[]]],[11,"bitxor","","",37,[[]]],[11,"bitxor","","",37,[[]]],[11,"bitxor","","",38,[[]]],[11,"bitxor","","",38,[[]]],[11,"bitxor","","",39,[[]]],[11,"bitxor","","",39,[[]]],[11,"bitxor","","",40,[[]]],[11,"bitxor","","",40,[[]]],[11,"bitxor","","",41,[[]]],[11,"bitxor","","",41,[[]]],[11,"bitxor","","",43,[[]]],[11,"bitxor","","",43,[[]]],[11,"bitxor","","",44,[[]]],[11,"bitxor","","",44,[[]]],[11,"bitxor","","",45,[[]]],[11,"bitxor","","",45,[[]]],[11,"bitxor","","",47,[[]]],[11,"bitxor","","",47,[[]]],[11,"bitxor","","",51,[[]]],[11,"bitxor","","",51,[[]]],[11,"bitxor","","",52,[[]]],[11,"bitxor","","",52,[[]]],[11,"bitxor","","",53,[[]]],[11,"bitxor","","",53,[[]]],[11,"bitxor","","",54,[[]]],[11,"bitxor","","",54,[[]]],[11,"bitxor","","",55,[[]]],[11,"bitxor","","",55,[[]]],[11,"bitxor","","",56,[[]]],[11,"bitxor","","",56,[[]]],[11,"bitxor","","",57,[[]]],[11,"bitxor","","",57,[[]]],[11,"bitxor","","",58,[[]]],[11,"bitxor","","",58,[[]]],[11,"bitxor","","",59,[[]]],[11,"bitxor","","",59,[[]]],[11,"bitxor","","",60,[[]]],[11,"bitxor","","",60,[[]]],[11,"bitxor","","",61,[[]]],[11,"bitxor","","",61,[[]]],[11,"bitxor","","",63,[[]]],[11,"bitxor","","",63,[[]]],[11,"bitxor","","",64,[[]]],[11,"bitxor","","",64,[[]]],[11,"bitxor","","",65,[[]]],[11,"bitxor","","",65,[[]]],[11,"bitxor","","",67,[[]]],[11,"bitxor","","",67,[[]]],[11,"bitxor","","",68,[[]]],[11,"bitxor","","",68,[[]]],[11,"bitxor","","",69,[[]]],[11,"bitxor","","",69,[[]]],[11,"bitxor","","",70,[[]]],[11,"bitxor","","",70,[[]]],[11,"bitxor","","",74,[[]]],[11,"bitxor","","",74,[[]]],[11,"bitxor","","",75,[[]]],[11,"bitxor","","",75,[[]]],[11,"bitxor","","",76,[[]]],[11,"bitxor","","",76,[[]]],[11,"bitxor","","",77,[[]]],[11,"bitxor","","",77,[[]]],[11,"bitxor","","",78,[[]]],[11,"bitxor","","",78,[[]]],[11,"bitxor","","",79,[[]]],[11,"bitxor","","",79,[[]]],[11,"bitxor","","",80,[[]]],[11,"bitxor","","",80,[[]]],[11,"bitxor","","",81,[[]]],[11,"bitxor","","",81,[[]]],[11,"bitxor","","",83,[[]]],[11,"bitxor","","",83,[[]]],[11,"bitxor","","",84,[[]]],[11,"bitxor","","",84,[[]]],[11,"bitxor","","",85,[[]]],[11,"bitxor","","",85,[[]]],[11,"bitxor","","",87,[[]]],[11,"bitxor","","",87,[[]]],[11,"bitxor","","",88,[[]]],[11,"bitxor","","",88,[[]]],[11,"bitxor","","",89,[[]]],[11,"bitxor","","",89,[[]]],[11,"bitxor","","",90,[[]]],[11,"bitxor","","",90,[[]]],[11,"bitxor","","",48,[[]]],[11,"bitxor","","",48,[[]]],[11,"bitxor","","",49,[[]]],[11,"bitxor","","",49,[[]]],[11,"bitxor","","",50,[[]]],[11,"bitxor","","",50,[[]]],[11,"bitxor","","",71,[[]]],[11,"bitxor","","",71,[[]]],[11,"bitxor","","",72,[[]]],[11,"bitxor","","",72,[[]]],[11,"bitxor","","",73,[[]]],[11,"bitxor","","",73,[[]]],[11,"bitxor","","",91,[[]]],[11,"bitxor","","",91,[[]]],[11,"bitxor","","",92,[[]]],[11,"bitxor","","",92,[[]]],[11,"bitxor","","",93,[[]]],[11,"bitxor","","",93,[[]]],[11,"shl","","",15,[[]]],[11,"shl","","",15,[[]]],[11,"shl","","",16,[[]]],[11,"shl","","",16,[[]]],[11,"shl","","",18,[[]]],[11,"shl","","",18,[[]]],[11,"shl","","",19,[[]]],[11,"shl","","",19,[[]]],[11,"shl","","",21,[[]]],[11,"shl","","",21,[[]]],[11,"shl","","",22,[[]]],[11,"shl","","",22,[[]]],[11,"shl","","",24,[[]]],[11,"shl","","",24,[[]]],[11,"shl","","",25,[[]]],[11,"shl","","",25,[[]]],[11,"shl","","",27,[[]]],[11,"shl","","",27,[[]]],[11,"shl","","",28,[[]]],[11,"shl","","",28,[[]]],[11,"shl","","",30,[[]]],[11,"shl","","",30,[[]]],[11,"shl","","",31,[[]]],[11,"shl","","",31,[[]]],[11,"shl","","",34,[[]]],[11,"shl","","",34,[[]]],[11,"shl","","",35,[[]]],[11,"shl","","",35,[[]]],[11,"shl","","",37,[[]]],[11,"shl","","",37,[[]]],[11,"shl","","",38,[[]]],[11,"shl","","",38,[[]]],[11,"shl","","",40,[[]]],[11,"shl","","",40,[[]]],[11,"shl","","",41,[[]]],[11,"shl","","",41,[[]]],[11,"shl","","",44,[[]]],[11,"shl","","",44,[[]]],[11,"shl","","",45,[[]]],[11,"shl","","",45,[[]]],[11,"shl","","",51,[[]]],[11,"shl","","",51,[[]]],[11,"shl","","",52,[[]]],[11,"shl","","",52,[[]]],[11,"shl","","",54,[[]]],[11,"shl","","",54,[[]]],[11,"shl","","",55,[[]]],[11,"shl","","",55,[[]]],[11,"shl","","",57,[[]]],[11,"shl","","",57,[[]]],[11,"shl","","",58,[[]]],[11,"shl","","",58,[[]]],[11,"shl","","",60,[[]]],[11,"shl","","",60,[[]]],[11,"shl","","",61,[[]]],[11,"shl","","",61,[[]]],[11,"shl","","",64,[[]]],[11,"shl","","",64,[[]]],[11,"shl","","",65,[[]]],[11,"shl","","",65,[[]]],[11,"shl","","",68,[[]]],[11,"shl","","",68,[[]]],[11,"shl","","",69,[[]]],[11,"shl","","",69,[[]]],[11,"shl","","",74,[[]]],[11,"shl","","",74,[[]]],[11,"shl","","",75,[[]]],[11,"shl","","",75,[[]]],[11,"shl","","",77,[[]]],[11,"shl","","",77,[[]]],[11,"shl","","",78,[[]]],[11,"shl","","",78,[[]]],[11,"shl","","",80,[[]]],[11,"shl","","",80,[[]]],[11,"shl","","",81,[[]]],[11,"shl","","",81,[[]]],[11,"shl","","",84,[[]]],[11,"shl","","",84,[[]]],[11,"shl","","",85,[[]]],[11,"shl","","",85,[[]]],[11,"shl","","",88,[[]]],[11,"shl","","",88,[[]]],[11,"shl","","",89,[[]]],[11,"shl","","",89,[[]]],[11,"shl","","",48,[[]]],[11,"shl","","",48,[[]]],[11,"shl","","",49,[[]]],[11,"shl","","",49,[[]]],[11,"shl","","",71,[[]]],[11,"shl","","",71,[[]]],[11,"shl","","",72,[[]]],[11,"shl","","",72,[[]]],[11,"shl","","",91,[[]]],[11,"shl","","",91,[[]]],[11,"shl","","",92,[[]]],[11,"shl","","",92,[[]]],[11,"shr","","",15,[[]]],[11,"shr","","",15,[[]]],[11,"shr","","",16,[[]]],[11,"shr","","",16,[[]]],[11,"shr","","",18,[[]]],[11,"shr","","",18,[[]]],[11,"shr","","",19,[[]]],[11,"shr","","",19,[[]]],[11,"shr","","",21,[[]]],[11,"shr","","",21,[[]]],[11,"shr","","",22,[[]]],[11,"shr","","",22,[[]]],[11,"shr","","",24,[[]]],[11,"shr","","",24,[[]]],[11,"shr","","",25,[[]]],[11,"shr","","",25,[[]]],[11,"shr","","",27,[[]]],[11,"shr","","",27,[[]]],[11,"shr","","",28,[[]]],[11,"shr","","",28,[[]]],[11,"shr","","",30,[[]]],[11,"shr","","",30,[[]]],[11,"shr","","",31,[[]]],[11,"shr","","",31,[[]]],[11,"shr","","",34,[[]]],[11,"shr","","",34,[[]]],[11,"shr","","",35,[[]]],[11,"shr","","",35,[[]]],[11,"shr","","",37,[[]]],[11,"shr","","",37,[[]]],[11,"shr","","",38,[[]]],[11,"shr","","",38,[[]]],[11,"shr","","",40,[[]]],[11,"shr","","",40,[[]]],[11,"shr","","",41,[[]]],[11,"shr","","",41,[[]]],[11,"shr","","",44,[[]]],[11,"shr","","",44,[[]]],[11,"shr","","",45,[[]]],[11,"shr","","",45,[[]]],[11,"shr","","",51,[[]]],[11,"shr","","",51,[[]]],[11,"shr","","",52,[[]]],[11,"shr","","",52,[[]]],[11,"shr","","",54,[[]]],[11,"shr","","",54,[[]]],[11,"shr","","",55,[[]]],[11,"shr","","",55,[[]]],[11,"shr","","",57,[[]]],[11,"shr","","",57,[[]]],[11,"shr","","",58,[[]]],[11,"shr","","",58,[[]]],[11,"shr","","",60,[[]]],[11,"shr","","",60,[[]]],[11,"shr","","",61,[[]]],[11,"shr","","",61,[[]]],[11,"shr","","",64,[[]]],[11,"shr","","",64,[[]]],[11,"shr","","",65,[[]]],[11,"shr","","",65,[[]]],[11,"shr","","",68,[[]]],[11,"shr","","",68,[[]]],[11,"shr","","",69,[[]]],[11,"shr","","",69,[[]]],[11,"shr","","",74,[[]]],[11,"shr","","",74,[[]]],[11,"shr","","",75,[[]]],[11,"shr","","",75,[[]]],[11,"shr","","",77,[[]]],[11,"shr","","",77,[[]]],[11,"shr","","",78,[[]]],[11,"shr","","",78,[[]]],[11,"shr","","",80,[[]]],[11,"shr","","",80,[[]]],[11,"shr","","",81,[[]]],[11,"shr","","",81,[[]]],[11,"shr","","",84,[[]]],[11,"shr","","",84,[[]]],[11,"shr","","",85,[[]]],[11,"shr","","",85,[[]]],[11,"shr","","",88,[[]]],[11,"shr","","",88,[[]]],[11,"shr","","",89,[[]]],[11,"shr","","",89,[[]]],[11,"shr","","",48,[[]]],[11,"shr","","",48,[[]]],[11,"shr","","",49,[[]]],[11,"shr","","",49,[[]]],[11,"shr","","",71,[[]]],[11,"shr","","",71,[[]]],[11,"shr","","",72,[[]]],[11,"shr","","",72,[[]]],[11,"shr","","",91,[[]]],[11,"shr","","",91,[[]]],[11,"shr","","",92,[[]]],[11,"shr","","",92,[[]]],[11,"bitand_assign","","",15,[[]]],[11,"bitand_assign","","",15,[[]]],[11,"bitand_assign","","",16,[[]]],[11,"bitand_assign","","",16,[[]]],[11,"bitand_assign","","",17,[[]]],[11,"bitand_assign","","",17,[[]]],[11,"bitand_assign","","",18,[[]]],[11,"bitand_assign","","",18,[[]]],[11,"bitand_assign","","",19,[[]]],[11,"bitand_assign","","",19,[[]]],[11,"bitand_assign","","",20,[[]]],[11,"bitand_assign","","",20,[[]]],[11,"bitand_assign","","",21,[[]]],[11,"bitand_assign","","",21,[[]]],[11,"bitand_assign","","",22,[[]]],[11,"bitand_assign","","",22,[[]]],[11,"bitand_assign","","",23,[[]]],[11,"bitand_assign","","",23,[[]]],[11,"bitand_assign","","",24,[[]]],[11,"bitand_assign","","",24,[[]]],[11,"bitand_assign","","",25,[[]]],[11,"bitand_assign","","",25,[[]]],[11,"bitand_assign","","",26,[[]]],[11,"bitand_assign","","",26,[[]]],[11,"bitand_assign","","",27,[[]]],[11,"bitand_assign","","",27,[[]]],[11,"bitand_assign","","",28,[[]]],[11,"bitand_assign","","",28,[[]]],[11,"bitand_assign","","",29,[[]]],[11,"bitand_assign","","",29,[[]]],[11,"bitand_assign","","",30,[[]]],[11,"bitand_assign","","",30,[[]]],[11,"bitand_assign","","",31,[[]]],[11,"bitand_assign","","",31,[[]]],[11,"bitand_assign","","",33,[[]]],[11,"bitand_assign","","",33,[[]]],[11,"bitand_assign","","",34,[[]]],[11,"bitand_assign","","",34,[[]]],[11,"bitand_assign","","",35,[[]]],[11,"bitand_assign","","",35,[[]]],[11,"bitand_assign","","",36,[[]]],[11,"bitand_assign","","",36,[[]]],[11,"bitand_assign","","",37,[[]]],[11,"bitand_assign","","",37,[[]]],[11,"bitand_assign","","",38,[[]]],[11,"bitand_assign","","",38,[[]]],[11,"bitand_assign","","",39,[[]]],[11,"bitand_assign","","",39,[[]]],[11,"bitand_assign","","",40,[[]]],[11,"bitand_assign","","",40,[[]]],[11,"bitand_assign","","",41,[[]]],[11,"bitand_assign","","",41,[[]]],[11,"bitand_assign","","",43,[[]]],[11,"bitand_assign","","",43,[[]]],[11,"bitand_assign","","",44,[[]]],[11,"bitand_assign","","",44,[[]]],[11,"bitand_assign","","",45,[[]]],[11,"bitand_assign","","",45,[[]]],[11,"bitand_assign","","",47,[[]]],[11,"bitand_assign","","",47,[[]]],[11,"bitand_assign","","",51,[[]]],[11,"bitand_assign","","",51,[[]]],[11,"bitand_assign","","",52,[[]]],[11,"bitand_assign","","",52,[[]]],[11,"bitand_assign","","",53,[[]]],[11,"bitand_assign","","",53,[[]]],[11,"bitand_assign","","",54,[[]]],[11,"bitand_assign","","",54,[[]]],[11,"bitand_assign","","",55,[[]]],[11,"bitand_assign","","",55,[[]]],[11,"bitand_assign","","",56,[[]]],[11,"bitand_assign","","",56,[[]]],[11,"bitand_assign","","",57,[[]]],[11,"bitand_assign","","",57,[[]]],[11,"bitand_assign","","",58,[[]]],[11,"bitand_assign","","",58,[[]]],[11,"bitand_assign","","",59,[[]]],[11,"bitand_assign","","",59,[[]]],[11,"bitand_assign","","",60,[[]]],[11,"bitand_assign","","",60,[[]]],[11,"bitand_assign","","",61,[[]]],[11,"bitand_assign","","",61,[[]]],[11,"bitand_assign","","",63,[[]]],[11,"bitand_assign","","",63,[[]]],[11,"bitand_assign","","",64,[[]]],[11,"bitand_assign","","",64,[[]]],[11,"bitand_assign","","",65,[[]]],[11,"bitand_assign","","",65,[[]]],[11,"bitand_assign","","",67,[[]]],[11,"bitand_assign","","",67,[[]]],[11,"bitand_assign","","",68,[[]]],[11,"bitand_assign","","",68,[[]]],[11,"bitand_assign","","",69,[[]]],[11,"bitand_assign","","",69,[[]]],[11,"bitand_assign","","",70,[[]]],[11,"bitand_assign","","",70,[[]]],[11,"bitand_assign","","",74,[[]]],[11,"bitand_assign","","",74,[[]]],[11,"bitand_assign","","",75,[[]]],[11,"bitand_assign","","",75,[[]]],[11,"bitand_assign","","",76,[[]]],[11,"bitand_assign","","",76,[[]]],[11,"bitand_assign","","",77,[[]]],[11,"bitand_assign","","",77,[[]]],[11,"bitand_assign","","",78,[[]]],[11,"bitand_assign","","",78,[[]]],[11,"bitand_assign","","",79,[[]]],[11,"bitand_assign","","",79,[[]]],[11,"bitand_assign","","",80,[[]]],[11,"bitand_assign","","",80,[[]]],[11,"bitand_assign","","",81,[[]]],[11,"bitand_assign","","",81,[[]]],[11,"bitand_assign","","",83,[[]]],[11,"bitand_assign","","",83,[[]]],[11,"bitand_assign","","",84,[[]]],[11,"bitand_assign","","",84,[[]]],[11,"bitand_assign","","",85,[[]]],[11,"bitand_assign","","",85,[[]]],[11,"bitand_assign","","",87,[[]]],[11,"bitand_assign","","",87,[[]]],[11,"bitand_assign","","",88,[[]]],[11,"bitand_assign","","",88,[[]]],[11,"bitand_assign","","",89,[[]]],[11,"bitand_assign","","",89,[[]]],[11,"bitand_assign","","",90,[[]]],[11,"bitand_assign","","",90,[[]]],[11,"bitand_assign","","",48,[[]]],[11,"bitand_assign","","",48,[[]]],[11,"bitand_assign","","",49,[[]]],[11,"bitand_assign","","",49,[[]]],[11,"bitand_assign","","",50,[[]]],[11,"bitand_assign","","",50,[[]]],[11,"bitand_assign","","",71,[[]]],[11,"bitand_assign","","",71,[[]]],[11,"bitand_assign","","",72,[[]]],[11,"bitand_assign","","",72,[[]]],[11,"bitand_assign","","",73,[[]]],[11,"bitand_assign","","",73,[[]]],[11,"bitand_assign","","",91,[[]]],[11,"bitand_assign","","",91,[[]]],[11,"bitand_assign","","",92,[[]]],[11,"bitand_assign","","",92,[[]]],[11,"bitand_assign","","",93,[[]]],[11,"bitand_assign","","",93,[[]]],[11,"bitor_assign","","",15,[[]]],[11,"bitor_assign","","",15,[[]]],[11,"bitor_assign","","",16,[[]]],[11,"bitor_assign","","",16,[[]]],[11,"bitor_assign","","",17,[[]]],[11,"bitor_assign","","",17,[[]]],[11,"bitor_assign","","",18,[[]]],[11,"bitor_assign","","",18,[[]]],[11,"bitor_assign","","",19,[[]]],[11,"bitor_assign","","",19,[[]]],[11,"bitor_assign","","",20,[[]]],[11,"bitor_assign","","",20,[[]]],[11,"bitor_assign","","",21,[[]]],[11,"bitor_assign","","",21,[[]]],[11,"bitor_assign","","",22,[[]]],[11,"bitor_assign","","",22,[[]]],[11,"bitor_assign","","",23,[[]]],[11,"bitor_assign","","",23,[[]]],[11,"bitor_assign","","",24,[[]]],[11,"bitor_assign","","",24,[[]]],[11,"bitor_assign","","",25,[[]]],[11,"bitor_assign","","",25,[[]]],[11,"bitor_assign","","",26,[[]]],[11,"bitor_assign","","",26,[[]]],[11,"bitor_assign","","",27,[[]]],[11,"bitor_assign","","",27,[[]]],[11,"bitor_assign","","",28,[[]]],[11,"bitor_assign","","",28,[[]]],[11,"bitor_assign","","",29,[[]]],[11,"bitor_assign","","",29,[[]]],[11,"bitor_assign","","",30,[[]]],[11,"bitor_assign","","",30,[[]]],[11,"bitor_assign","","",31,[[]]],[11,"bitor_assign","","",31,[[]]],[11,"bitor_assign","","",33,[[]]],[11,"bitor_assign","","",33,[[]]],[11,"bitor_assign","","",34,[[]]],[11,"bitor_assign","","",34,[[]]],[11,"bitor_assign","","",35,[[]]],[11,"bitor_assign","","",35,[[]]],[11,"bitor_assign","","",36,[[]]],[11,"bitor_assign","","",36,[[]]],[11,"bitor_assign","","",37,[[]]],[11,"bitor_assign","","",37,[[]]],[11,"bitor_assign","","",38,[[]]],[11,"bitor_assign","","",38,[[]]],[11,"bitor_assign","","",39,[[]]],[11,"bitor_assign","","",39,[[]]],[11,"bitor_assign","","",40,[[]]],[11,"bitor_assign","","",40,[[]]],[11,"bitor_assign","","",41,[[]]],[11,"bitor_assign","","",41,[[]]],[11,"bitor_assign","","",43,[[]]],[11,"bitor_assign","","",43,[[]]],[11,"bitor_assign","","",44,[[]]],[11,"bitor_assign","","",44,[[]]],[11,"bitor_assign","","",45,[[]]],[11,"bitor_assign","","",45,[[]]],[11,"bitor_assign","","",47,[[]]],[11,"bitor_assign","","",47,[[]]],[11,"bitor_assign","","",51,[[]]],[11,"bitor_assign","","",51,[[]]],[11,"bitor_assign","","",52,[[]]],[11,"bitor_assign","","",52,[[]]],[11,"bitor_assign","","",53,[[]]],[11,"bitor_assign","","",53,[[]]],[11,"bitor_assign","","",54,[[]]],[11,"bitor_assign","","",54,[[]]],[11,"bitor_assign","","",55,[[]]],[11,"bitor_assign","","",55,[[]]],[11,"bitor_assign","","",56,[[]]],[11,"bitor_assign","","",56,[[]]],[11,"bitor_assign","","",57,[[]]],[11,"bitor_assign","","",57,[[]]],[11,"bitor_assign","","",58,[[]]],[11,"bitor_assign","","",58,[[]]],[11,"bitor_assign","","",59,[[]]],[11,"bitor_assign","","",59,[[]]],[11,"bitor_assign","","",60,[[]]],[11,"bitor_assign","","",60,[[]]],[11,"bitor_assign","","",61,[[]]],[11,"bitor_assign","","",61,[[]]],[11,"bitor_assign","","",63,[[]]],[11,"bitor_assign","","",63,[[]]],[11,"bitor_assign","","",64,[[]]],[11,"bitor_assign","","",64,[[]]],[11,"bitor_assign","","",65,[[]]],[11,"bitor_assign","","",65,[[]]],[11,"bitor_assign","","",67,[[]]],[11,"bitor_assign","","",67,[[]]],[11,"bitor_assign","","",68,[[]]],[11,"bitor_assign","","",68,[[]]],[11,"bitor_assign","","",69,[[]]],[11,"bitor_assign","","",69,[[]]],[11,"bitor_assign","","",70,[[]]],[11,"bitor_assign","","",70,[[]]],[11,"bitor_assign","","",74,[[]]],[11,"bitor_assign","","",74,[[]]],[11,"bitor_assign","","",75,[[]]],[11,"bitor_assign","","",75,[[]]],[11,"bitor_assign","","",76,[[]]],[11,"bitor_assign","","",76,[[]]],[11,"bitor_assign","","",77,[[]]],[11,"bitor_assign","","",77,[[]]],[11,"bitor_assign","","",78,[[]]],[11,"bitor_assign","","",78,[[]]],[11,"bitor_assign","","",79,[[]]],[11,"bitor_assign","","",79,[[]]],[11,"bitor_assign","","",80,[[]]],[11,"bitor_assign","","",80,[[]]],[11,"bitor_assign","","",81,[[]]],[11,"bitor_assign","","",81,[[]]],[11,"bitor_assign","","",83,[[]]],[11,"bitor_assign","","",83,[[]]],[11,"bitor_assign","","",84,[[]]],[11,"bitor_assign","","",84,[[]]],[11,"bitor_assign","","",85,[[]]],[11,"bitor_assign","","",85,[[]]],[11,"bitor_assign","","",87,[[]]],[11,"bitor_assign","","",87,[[]]],[11,"bitor_assign","","",88,[[]]],[11,"bitor_assign","","",88,[[]]],[11,"bitor_assign","","",89,[[]]],[11,"bitor_assign","","",89,[[]]],[11,"bitor_assign","","",90,[[]]],[11,"bitor_assign","","",90,[[]]],[11,"bitor_assign","","",48,[[]]],[11,"bitor_assign","","",48,[[]]],[11,"bitor_assign","","",49,[[]]],[11,"bitor_assign","","",49,[[]]],[11,"bitor_assign","","",50,[[]]],[11,"bitor_assign","","",50,[[]]],[11,"bitor_assign","","",71,[[]]],[11,"bitor_assign","","",71,[[]]],[11,"bitor_assign","","",72,[[]]],[11,"bitor_assign","","",72,[[]]],[11,"bitor_assign","","",73,[[]]],[11,"bitor_assign","","",73,[[]]],[11,"bitor_assign","","",91,[[]]],[11,"bitor_assign","","",91,[[]]],[11,"bitor_assign","","",92,[[]]],[11,"bitor_assign","","",92,[[]]],[11,"bitor_assign","","",93,[[]]],[11,"bitor_assign","","",93,[[]]],[11,"bitxor_assign","","",15,[[]]],[11,"bitxor_assign","","",15,[[]]],[11,"bitxor_assign","","",16,[[]]],[11,"bitxor_assign","","",16,[[]]],[11,"bitxor_assign","","",17,[[]]],[11,"bitxor_assign","","",17,[[]]],[11,"bitxor_assign","","",18,[[]]],[11,"bitxor_assign","","",18,[[]]],[11,"bitxor_assign","","",19,[[]]],[11,"bitxor_assign","","",19,[[]]],[11,"bitxor_assign","","",20,[[]]],[11,"bitxor_assign","","",20,[[]]],[11,"bitxor_assign","","",21,[[]]],[11,"bitxor_assign","","",21,[[]]],[11,"bitxor_assign","","",22,[[]]],[11,"bitxor_assign","","",22,[[]]],[11,"bitxor_assign","","",23,[[]]],[11,"bitxor_assign","","",23,[[]]],[11,"bitxor_assign","","",24,[[]]],[11,"bitxor_assign","","",24,[[]]],[11,"bitxor_assign","","",25,[[]]],[11,"bitxor_assign","","",25,[[]]],[11,"bitxor_assign","","",26,[[]]],[11,"bitxor_assign","","",26,[[]]],[11,"bitxor_assign","","",27,[[]]],[11,"bitxor_assign","","",27,[[]]],[11,"bitxor_assign","","",28,[[]]],[11,"bitxor_assign","","",28,[[]]],[11,"bitxor_assign","","",29,[[]]],[11,"bitxor_assign","","",29,[[]]],[11,"bitxor_assign","","",30,[[]]],[11,"bitxor_assign","","",30,[[]]],[11,"bitxor_assign","","",31,[[]]],[11,"bitxor_assign","","",31,[[]]],[11,"bitxor_assign","","",33,[[]]],[11,"bitxor_assign","","",33,[[]]],[11,"bitxor_assign","","",34,[[]]],[11,"bitxor_assign","","",34,[[]]],[11,"bitxor_assign","","",35,[[]]],[11,"bitxor_assign","","",35,[[]]],[11,"bitxor_assign","","",36,[[]]],[11,"bitxor_assign","","",36,[[]]],[11,"bitxor_assign","","",37,[[]]],[11,"bitxor_assign","","",37,[[]]],[11,"bitxor_assign","","",38,[[]]],[11,"bitxor_assign","","",38,[[]]],[11,"bitxor_assign","","",39,[[]]],[11,"bitxor_assign","","",39,[[]]],[11,"bitxor_assign","","",40,[[]]],[11,"bitxor_assign","","",40,[[]]],[11,"bitxor_assign","","",41,[[]]],[11,"bitxor_assign","","",41,[[]]],[11,"bitxor_assign","","",43,[[]]],[11,"bitxor_assign","","",43,[[]]],[11,"bitxor_assign","","",44,[[]]],[11,"bitxor_assign","","",44,[[]]],[11,"bitxor_assign","","",45,[[]]],[11,"bitxor_assign","","",45,[[]]],[11,"bitxor_assign","","",47,[[]]],[11,"bitxor_assign","","",47,[[]]],[11,"bitxor_assign","","",51,[[]]],[11,"bitxor_assign","","",51,[[]]],[11,"bitxor_assign","","",52,[[]]],[11,"bitxor_assign","","",52,[[]]],[11,"bitxor_assign","","",53,[[]]],[11,"bitxor_assign","","",53,[[]]],[11,"bitxor_assign","","",54,[[]]],[11,"bitxor_assign","","",54,[[]]],[11,"bitxor_assign","","",55,[[]]],[11,"bitxor_assign","","",55,[[]]],[11,"bitxor_assign","","",56,[[]]],[11,"bitxor_assign","","",56,[[]]],[11,"bitxor_assign","","",57,[[]]],[11,"bitxor_assign","","",57,[[]]],[11,"bitxor_assign","","",58,[[]]],[11,"bitxor_assign","","",58,[[]]],[11,"bitxor_assign","","",59,[[]]],[11,"bitxor_assign","","",59,[[]]],[11,"bitxor_assign","","",60,[[]]],[11,"bitxor_assign","","",60,[[]]],[11,"bitxor_assign","","",61,[[]]],[11,"bitxor_assign","","",61,[[]]],[11,"bitxor_assign","","",63,[[]]],[11,"bitxor_assign","","",63,[[]]],[11,"bitxor_assign","","",64,[[]]],[11,"bitxor_assign","","",64,[[]]],[11,"bitxor_assign","","",65,[[]]],[11,"bitxor_assign","","",65,[[]]],[11,"bitxor_assign","","",67,[[]]],[11,"bitxor_assign","","",67,[[]]],[11,"bitxor_assign","","",68,[[]]],[11,"bitxor_assign","","",68,[[]]],[11,"bitxor_assign","","",69,[[]]],[11,"bitxor_assign","","",69,[[]]],[11,"bitxor_assign","","",70,[[]]],[11,"bitxor_assign","","",70,[[]]],[11,"bitxor_assign","","",74,[[]]],[11,"bitxor_assign","","",74,[[]]],[11,"bitxor_assign","","",75,[[]]],[11,"bitxor_assign","","",75,[[]]],[11,"bitxor_assign","","",76,[[]]],[11,"bitxor_assign","","",76,[[]]],[11,"bitxor_assign","","",77,[[]]],[11,"bitxor_assign","","",77,[[]]],[11,"bitxor_assign","","",78,[[]]],[11,"bitxor_assign","","",78,[[]]],[11,"bitxor_assign","","",79,[[]]],[11,"bitxor_assign","","",79,[[]]],[11,"bitxor_assign","","",80,[[]]],[11,"bitxor_assign","","",80,[[]]],[11,"bitxor_assign","","",81,[[]]],[11,"bitxor_assign","","",81,[[]]],[11,"bitxor_assign","","",83,[[]]],[11,"bitxor_assign","","",83,[[]]],[11,"bitxor_assign","","",84,[[]]],[11,"bitxor_assign","","",84,[[]]],[11,"bitxor_assign","","",85,[[]]],[11,"bitxor_assign","","",85,[[]]],[11,"bitxor_assign","","",87,[[]]],[11,"bitxor_assign","","",87,[[]]],[11,"bitxor_assign","","",88,[[]]],[11,"bitxor_assign","","",88,[[]]],[11,"bitxor_assign","","",89,[[]]],[11,"bitxor_assign","","",89,[[]]],[11,"bitxor_assign","","",90,[[]]],[11,"bitxor_assign","","",90,[[]]],[11,"bitxor_assign","","",48,[[]]],[11,"bitxor_assign","","",48,[[]]],[11,"bitxor_assign","","",49,[[]]],[11,"bitxor_assign","","",49,[[]]],[11,"bitxor_assign","","",50,[[]]],[11,"bitxor_assign","","",50,[[]]],[11,"bitxor_assign","","",71,[[]]],[11,"bitxor_assign","","",71,[[]]],[11,"bitxor_assign","","",72,[[]]],[11,"bitxor_assign","","",72,[[]]],[11,"bitxor_assign","","",73,[[]]],[11,"bitxor_assign","","",73,[[]]],[11,"bitxor_assign","","",91,[[]]],[11,"bitxor_assign","","",91,[[]]],[11,"bitxor_assign","","",92,[[]]],[11,"bitxor_assign","","",92,[[]]],[11,"bitxor_assign","","",93,[[]]],[11,"bitxor_assign","","",93,[[]]],[11,"shl_assign","","",15,[[]]],[11,"shl_assign","","",15,[[]]],[11,"shl_assign","","",16,[[]]],[11,"shl_assign","","",16,[[]]],[11,"shl_assign","","",18,[[]]],[11,"shl_assign","","",18,[[]]],[11,"shl_assign","","",19,[[]]],[11,"shl_assign","","",19,[[]]],[11,"shl_assign","","",21,[[]]],[11,"shl_assign","","",21,[[]]],[11,"shl_assign","","",22,[[]]],[11,"shl_assign","","",22,[[]]],[11,"shl_assign","","",24,[[]]],[11,"shl_assign","","",24,[[]]],[11,"shl_assign","","",25,[[]]],[11,"shl_assign","","",25,[[]]],[11,"shl_assign","","",27,[[]]],[11,"shl_assign","","",27,[[]]],[11,"shl_assign","","",28,[[]]],[11,"shl_assign","","",28,[[]]],[11,"shl_assign","","",30,[[]]],[11,"shl_assign","","",30,[[]]],[11,"shl_assign","","",31,[[]]],[11,"shl_assign","","",31,[[]]],[11,"shl_assign","","",34,[[]]],[11,"shl_assign","","",34,[[]]],[11,"shl_assign","","",35,[[]]],[11,"shl_assign","","",35,[[]]],[11,"shl_assign","","",37,[[]]],[11,"shl_assign","","",37,[[]]],[11,"shl_assign","","",38,[[]]],[11,"shl_assign","","",38,[[]]],[11,"shl_assign","","",40,[[]]],[11,"shl_assign","","",40,[[]]],[11,"shl_assign","","",41,[[]]],[11,"shl_assign","","",41,[[]]],[11,"shl_assign","","",44,[[]]],[11,"shl_assign","","",44,[[]]],[11,"shl_assign","","",45,[[]]],[11,"shl_assign","","",45,[[]]],[11,"shl_assign","","",51,[[]]],[11,"shl_assign","","",51,[[]]],[11,"shl_assign","","",52,[[]]],[11,"shl_assign","","",52,[[]]],[11,"shl_assign","","",54,[[]]],[11,"shl_assign","","",54,[[]]],[11,"shl_assign","","",55,[[]]],[11,"shl_assign","","",55,[[]]],[11,"shl_assign","","",57,[[]]],[11,"shl_assign","","",57,[[]]],[11,"shl_assign","","",58,[[]]],[11,"shl_assign","","",58,[[]]],[11,"shl_assign","","",60,[[]]],[11,"shl_assign","","",60,[[]]],[11,"shl_assign","","",61,[[]]],[11,"shl_assign","","",61,[[]]],[11,"shl_assign","","",64,[[]]],[11,"shl_assign","","",64,[[]]],[11,"shl_assign","","",65,[[]]],[11,"shl_assign","","",65,[[]]],[11,"shl_assign","","",68,[[]]],[11,"shl_assign","","",68,[[]]],[11,"shl_assign","","",69,[[]]],[11,"shl_assign","","",69,[[]]],[11,"shl_assign","","",74,[[]]],[11,"shl_assign","","",74,[[]]],[11,"shl_assign","","",75,[[]]],[11,"shl_assign","","",75,[[]]],[11,"shl_assign","","",77,[[]]],[11,"shl_assign","","",77,[[]]],[11,"shl_assign","","",78,[[]]],[11,"shl_assign","","",78,[[]]],[11,"shl_assign","","",80,[[]]],[11,"shl_assign","","",80,[[]]],[11,"shl_assign","","",81,[[]]],[11,"shl_assign","","",81,[[]]],[11,"shl_assign","","",84,[[]]],[11,"shl_assign","","",84,[[]]],[11,"shl_assign","","",85,[[]]],[11,"shl_assign","","",85,[[]]],[11,"shl_assign","","",88,[[]]],[11,"shl_assign","","",88,[[]]],[11,"shl_assign","","",89,[[]]],[11,"shl_assign","","",89,[[]]],[11,"shl_assign","","",48,[[]]],[11,"shl_assign","","",48,[[]]],[11,"shl_assign","","",49,[[]]],[11,"shl_assign","","",49,[[]]],[11,"shl_assign","","",71,[[]]],[11,"shl_assign","","",71,[[]]],[11,"shl_assign","","",72,[[]]],[11,"shl_assign","","",72,[[]]],[11,"shl_assign","","",91,[[]]],[11,"shl_assign","","",91,[[]]],[11,"shl_assign","","",92,[[]]],[11,"shl_assign","","",92,[[]]],[11,"shr_assign","","",15,[[]]],[11,"shr_assign","","",15,[[]]],[11,"shr_assign","","",16,[[]]],[11,"shr_assign","","",16,[[]]],[11,"shr_assign","","",18,[[]]],[11,"shr_assign","","",18,[[]]],[11,"shr_assign","","",19,[[]]],[11,"shr_assign","","",19,[[]]],[11,"shr_assign","","",21,[[]]],[11,"shr_assign","","",21,[[]]],[11,"shr_assign","","",22,[[]]],[11,"shr_assign","","",22,[[]]],[11,"shr_assign","","",24,[[]]],[11,"shr_assign","","",24,[[]]],[11,"shr_assign","","",25,[[]]],[11,"shr_assign","","",25,[[]]],[11,"shr_assign","","",27,[[]]],[11,"shr_assign","","",27,[[]]],[11,"shr_assign","","",28,[[]]],[11,"shr_assign","","",28,[[]]],[11,"shr_assign","","",30,[[]]],[11,"shr_assign","","",30,[[]]],[11,"shr_assign","","",31,[[]]],[11,"shr_assign","","",31,[[]]],[11,"shr_assign","","",34,[[]]],[11,"shr_assign","","",34,[[]]],[11,"shr_assign","","",35,[[]]],[11,"shr_assign","","",35,[[]]],[11,"shr_assign","","",37,[[]]],[11,"shr_assign","","",37,[[]]],[11,"shr_assign","","",38,[[]]],[11,"shr_assign","","",38,[[]]],[11,"shr_assign","","",40,[[]]],[11,"shr_assign","","",40,[[]]],[11,"shr_assign","","",41,[[]]],[11,"shr_assign","","",41,[[]]],[11,"shr_assign","","",44,[[]]],[11,"shr_assign","","",44,[[]]],[11,"shr_assign","","",45,[[]]],[11,"shr_assign","","",45,[[]]],[11,"shr_assign","","",51,[[]]],[11,"shr_assign","","",51,[[]]],[11,"shr_assign","","",52,[[]]],[11,"shr_assign","","",52,[[]]],[11,"shr_assign","","",54,[[]]],[11,"shr_assign","","",54,[[]]],[11,"shr_assign","","",55,[[]]],[11,"shr_assign","","",55,[[]]],[11,"shr_assign","","",57,[[]]],[11,"shr_assign","","",57,[[]]],[11,"shr_assign","","",58,[[]]],[11,"shr_assign","","",58,[[]]],[11,"shr_assign","","",60,[[]]],[11,"shr_assign","","",60,[[]]],[11,"shr_assign","","",61,[[]]],[11,"shr_assign","","",61,[[]]],[11,"shr_assign","","",64,[[]]],[11,"shr_assign","","",64,[[]]],[11,"shr_assign","","",65,[[]]],[11,"shr_assign","","",65,[[]]],[11,"shr_assign","","",68,[[]]],[11,"shr_assign","","",68,[[]]],[11,"shr_assign","","",69,[[]]],[11,"shr_assign","","",69,[[]]],[11,"shr_assign","","",74,[[]]],[11,"shr_assign","","",74,[[]]],[11,"shr_assign","","",75,[[]]],[11,"shr_assign","","",75,[[]]],[11,"shr_assign","","",77,[[]]],[11,"shr_assign","","",77,[[]]],[11,"shr_assign","","",78,[[]]],[11,"shr_assign","","",78,[[]]],[11,"shr_assign","","",80,[[]]],[11,"shr_assign","","",80,[[]]],[11,"shr_assign","","",81,[[]]],[11,"shr_assign","","",81,[[]]],[11,"shr_assign","","",84,[[]]],[11,"shr_assign","","",84,[[]]],[11,"shr_assign","","",85,[[]]],[11,"shr_assign","","",85,[[]]],[11,"shr_assign","","",88,[[]]],[11,"shr_assign","","",88,[[]]],[11,"shr_assign","","",89,[[]]],[11,"shr_assign","","",89,[[]]],[11,"shr_assign","","",48,[[]]],[11,"shr_assign","","",48,[[]]],[11,"shr_assign","","",49,[[]]],[11,"shr_assign","","",49,[[]]],[11,"shr_assign","","",71,[[]]],[11,"shr_assign","","",71,[[]]],[11,"shr_assign","","",72,[[]]],[11,"shr_assign","","",72,[[]]],[11,"shr_assign","","",91,[[]]],[11,"shr_assign","","",91,[[]]],[11,"shr_assign","","",92,[[]]],[11,"shr_assign","","",92,[[]]],[11,"hash","","",0,[[]]],[11,"hash","","",1,[[]]],[11,"hash","","",2,[[]]],[11,"hash","","",3,[[]]],[11,"hash","","",4,[[]]],[11,"hash","","",5,[[]]],[11,"hash","","",15,[[]]],[11,"hash","","",16,[[]]],[11,"hash","","",18,[[]]],[11,"hash","","",19,[[]]],[11,"hash","","",21,[[]]],[11,"hash","","",22,[[]]],[11,"hash","","",24,[[]]],[11,"hash","","",25,[[]]],[11,"hash","","",27,[[]]],[11,"hash","","",28,[[]]],[11,"hash","","",30,[[]]],[11,"hash","","",31,[[]]],[11,"hash","","",34,[[]]],[11,"hash","","",35,[[]]],[11,"hash","","",37,[[]]],[11,"hash","","",38,[[]]],[11,"hash","","",40,[[]]],[11,"hash","","",41,[[]]],[11,"hash","","",44,[[]]],[11,"hash","","",45,[[]]],[11,"hash","","",51,[[]]],[11,"hash","","",52,[[]]],[11,"hash","","",54,[[]]],[11,"hash","","",55,[[]]],[11,"hash","","",57,[[]]],[11,"hash","","",58,[[]]],[11,"hash","","",60,[[]]],[11,"hash","","",61,[[]]],[11,"hash","","",64,[[]]],[11,"hash","","",65,[[]]],[11,"hash","","",68,[[]]],[11,"hash","","",69,[[]]],[11,"hash","","",74,[[]]],[11,"hash","","",75,[[]]],[11,"hash","","",77,[[]]],[11,"hash","","",78,[[]]],[11,"hash","","",80,[[]]],[11,"hash","","",81,[[]]],[11,"hash","","",84,[[]]],[11,"hash","","",85,[[]]],[11,"hash","","",88,[[]]],[11,"hash","","",89,[[]]],[11,"hash","","",48,[[]]],[11,"hash","","",49,[[]]],[11,"hash","","",71,[[]]],[11,"hash","","",72,[[]]],[11,"hash","","",91,[[]]],[11,"hash","","",92,[[]]],[11,"hash","","",94,[[]]],[11,"hash","","",95,[[]]],[11,"hash","","",96,[[]]],[11,"hash","","",97,[[]]],[11,"hash","","",98,[[]]],[11,"hash","","",99,[[]]],[11,"into","","",94,[[]]],[11,"into","","",95,[[]]],[11,"into","","",96,[[]]],[11,"into","","",97,[[]]],[11,"into","","",98,[[]]],[11,"into","","",99,[[]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","","",31,[[["formatter",3]],["result",6]]],[11,"fmt","","",34,[[["formatter",3]],["result",6]]],[11,"fmt","","",35,[[["formatter",3]],["result",6]]],[11,"fmt","","",37,[[["formatter",3]],["result",6]]],[11,"fmt","","",38,[[["formatter",3]],["result",6]]],[11,"fmt","","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",41,[[["formatter",3]],["result",6]]],[11,"fmt","","",44,[[["formatter",3]],["result",6]]],[11,"fmt","","",45,[[["formatter",3]],["result",6]]],[11,"fmt","","",51,[[["formatter",3]],["result",6]]],[11,"fmt","","",52,[[["formatter",3]],["result",6]]],[11,"fmt","","",54,[[["formatter",3]],["result",6]]],[11,"fmt","","",55,[[["formatter",3]],["result",6]]],[11,"fmt","","",57,[[["formatter",3]],["result",6]]],[11,"fmt","","",58,[[["formatter",3]],["result",6]]],[11,"fmt","","",60,[[["formatter",3]],["result",6]]],[11,"fmt","","",61,[[["formatter",3]],["result",6]]],[11,"fmt","","",64,[[["formatter",3]],["result",6]]],[11,"fmt","","",65,[[["formatter",3]],["result",6]]],[11,"fmt","","",68,[[["formatter",3]],["result",6]]],[11,"fmt","","",69,[[["formatter",3]],["result",6]]],[11,"fmt","","",74,[[["formatter",3]],["result",6]]],[11,"fmt","","",75,[[["formatter",3]],["result",6]]],[11,"fmt","","",77,[[["formatter",3]],["result",6]]],[11,"fmt","","",78,[[["formatter",3]],["result",6]]],[11,"fmt","","",80,[[["formatter",3]],["result",6]]],[11,"fmt","","",81,[[["formatter",3]],["result",6]]],[11,"fmt","","",84,[[["formatter",3]],["result",6]]],[11,"fmt","","",85,[[["formatter",3]],["result",6]]],[11,"fmt","","",88,[[["formatter",3]],["result",6]]],[11,"fmt","","",89,[[["formatter",3]],["result",6]]],[11,"fmt","","",48,[[["formatter",3]],["result",6]]],[11,"fmt","","",49,[[["formatter",3]],["result",6]]],[11,"fmt","","",71,[[["formatter",3]],["result",6]]],[11,"fmt","","",72,[[["formatter",3]],["result",6]]],[11,"fmt","","",91,[[["formatter",3]],["result",6]]],[11,"fmt","","",92,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","","",31,[[["formatter",3]],["result",6]]],[11,"fmt","","",34,[[["formatter",3]],["result",6]]],[11,"fmt","","",35,[[["formatter",3]],["result",6]]],[11,"fmt","","",37,[[["formatter",3]],["result",6]]],[11,"fmt","","",38,[[["formatter",3]],["result",6]]],[11,"fmt","","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",41,[[["formatter",3]],["result",6]]],[11,"fmt","","",44,[[["formatter",3]],["result",6]]],[11,"fmt","","",45,[[["formatter",3]],["result",6]]],[11,"fmt","","",51,[[["formatter",3]],["result",6]]],[11,"fmt","","",52,[[["formatter",3]],["result",6]]],[11,"fmt","","",54,[[["formatter",3]],["result",6]]],[11,"fmt","","",55,[[["formatter",3]],["result",6]]],[11,"fmt","","",57,[[["formatter",3]],["result",6]]],[11,"fmt","","",58,[[["formatter",3]],["result",6]]],[11,"fmt","","",60,[[["formatter",3]],["result",6]]],[11,"fmt","","",61,[[["formatter",3]],["result",6]]],[11,"fmt","","",64,[[["formatter",3]],["result",6]]],[11,"fmt","","",65,[[["formatter",3]],["result",6]]],[11,"fmt","","",68,[[["formatter",3]],["result",6]]],[11,"fmt","","",69,[[["formatter",3]],["result",6]]],[11,"fmt","","",74,[[["formatter",3]],["result",6]]],[11,"fmt","","",75,[[["formatter",3]],["result",6]]],[11,"fmt","","",77,[[["formatter",3]],["result",6]]],[11,"fmt","","",78,[[["formatter",3]],["result",6]]],[11,"fmt","","",80,[[["formatter",3]],["result",6]]],[11,"fmt","","",81,[[["formatter",3]],["result",6]]],[11,"fmt","","",84,[[["formatter",3]],["result",6]]],[11,"fmt","","",85,[[["formatter",3]],["result",6]]],[11,"fmt","","",88,[[["formatter",3]],["result",6]]],[11,"fmt","","",89,[[["formatter",3]],["result",6]]],[11,"fmt","","",48,[[["formatter",3]],["result",6]]],[11,"fmt","","",49,[[["formatter",3]],["result",6]]],[11,"fmt","","",71,[[["formatter",3]],["result",6]]],[11,"fmt","","",72,[[["formatter",3]],["result",6]]],[11,"fmt","","",91,[[["formatter",3]],["result",6]]],[11,"fmt","","",92,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","","",31,[[["formatter",3]],["result",6]]],[11,"fmt","","",34,[[["formatter",3]],["result",6]]],[11,"fmt","","",35,[[["formatter",3]],["result",6]]],[11,"fmt","","",37,[[["formatter",3]],["result",6]]],[11,"fmt","","",38,[[["formatter",3]],["result",6]]],[11,"fmt","","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",41,[[["formatter",3]],["result",6]]],[11,"fmt","","",44,[[["formatter",3]],["result",6]]],[11,"fmt","","",45,[[["formatter",3]],["result",6]]],[11,"fmt","","",51,[[["formatter",3]],["result",6]]],[11,"fmt","","",52,[[["formatter",3]],["result",6]]],[11,"fmt","","",54,[[["formatter",3]],["result",6]]],[11,"fmt","","",55,[[["formatter",3]],["result",6]]],[11,"fmt","","",57,[[["formatter",3]],["result",6]]],[11,"fmt","","",58,[[["formatter",3]],["result",6]]],[11,"fmt","","",60,[[["formatter",3]],["result",6]]],[11,"fmt","","",61,[[["formatter",3]],["result",6]]],[11,"fmt","","",64,[[["formatter",3]],["result",6]]],[11,"fmt","","",65,[[["formatter",3]],["result",6]]],[11,"fmt","","",68,[[["formatter",3]],["result",6]]],[11,"fmt","","",69,[[["formatter",3]],["result",6]]],[11,"fmt","","",74,[[["formatter",3]],["result",6]]],[11,"fmt","","",75,[[["formatter",3]],["result",6]]],[11,"fmt","","",77,[[["formatter",3]],["result",6]]],[11,"fmt","","",78,[[["formatter",3]],["result",6]]],[11,"fmt","","",80,[[["formatter",3]],["result",6]]],[11,"fmt","","",81,[[["formatter",3]],["result",6]]],[11,"fmt","","",84,[[["formatter",3]],["result",6]]],[11,"fmt","","",85,[[["formatter",3]],["result",6]]],[11,"fmt","","",88,[[["formatter",3]],["result",6]]],[11,"fmt","","",89,[[["formatter",3]],["result",6]]],[11,"fmt","","",48,[[["formatter",3]],["result",6]]],[11,"fmt","","",49,[[["formatter",3]],["result",6]]],[11,"fmt","","",71,[[["formatter",3]],["result",6]]],[11,"fmt","","",72,[[["formatter",3]],["result",6]]],[11,"fmt","","",91,[[["formatter",3]],["result",6]]],[11,"fmt","","",92,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","","",31,[[["formatter",3]],["result",6]]],[11,"fmt","","",34,[[["formatter",3]],["result",6]]],[11,"fmt","","",35,[[["formatter",3]],["result",6]]],[11,"fmt","","",37,[[["formatter",3]],["result",6]]],[11,"fmt","","",38,[[["formatter",3]],["result",6]]],[11,"fmt","","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",41,[[["formatter",3]],["result",6]]],[11,"fmt","","",44,[[["formatter",3]],["result",6]]],[11,"fmt","","",45,[[["formatter",3]],["result",6]]],[11,"fmt","","",51,[[["formatter",3]],["result",6]]],[11,"fmt","","",52,[[["formatter",3]],["result",6]]],[11,"fmt","","",54,[[["formatter",3]],["result",6]]],[11,"fmt","","",55,[[["formatter",3]],["result",6]]],[11,"fmt","","",57,[[["formatter",3]],["result",6]]],[11,"fmt","","",58,[[["formatter",3]],["result",6]]],[11,"fmt","","",60,[[["formatter",3]],["result",6]]],[11,"fmt","","",61,[[["formatter",3]],["result",6]]],[11,"fmt","","",64,[[["formatter",3]],["result",6]]],[11,"fmt","","",65,[[["formatter",3]],["result",6]]],[11,"fmt","","",68,[[["formatter",3]],["result",6]]],[11,"fmt","","",69,[[["formatter",3]],["result",6]]],[11,"fmt","","",74,[[["formatter",3]],["result",6]]],[11,"fmt","","",75,[[["formatter",3]],["result",6]]],[11,"fmt","","",77,[[["formatter",3]],["result",6]]],[11,"fmt","","",78,[[["formatter",3]],["result",6]]],[11,"fmt","","",80,[[["formatter",3]],["result",6]]],[11,"fmt","","",81,[[["formatter",3]],["result",6]]],[11,"fmt","","",84,[[["formatter",3]],["result",6]]],[11,"fmt","","",85,[[["formatter",3]],["result",6]]],[11,"fmt","","",88,[[["formatter",3]],["result",6]]],[11,"fmt","","",89,[[["formatter",3]],["result",6]]],[11,"fmt","","",48,[[["formatter",3]],["result",6]]],[11,"fmt","","",49,[[["formatter",3]],["result",6]]],[11,"fmt","","",71,[[["formatter",3]],["result",6]]],[11,"fmt","","",72,[[["formatter",3]],["result",6]]],[11,"fmt","","",91,[[["formatter",3]],["result",6]]],[11,"fmt","","",92,[[["formatter",3]],["result",6]]],[11,"sum","","",15,[[["iterator",8]],["i8x2",6]]],[11,"sum","","",15,[[["iterator",8]],["i8x2",6]]],[11,"sum","","",16,[[["iterator",8]],["u8x2",6]]],[11,"sum","","",16,[[["iterator",8]],["u8x2",6]]],[11,"sum","","",18,[[["iterator",8]],["i8x4",6]]],[11,"sum","","",18,[[["iterator",8]],["i8x4",6]]],[11,"sum","","",19,[[["iterator",8]],["u8x4",6]]],[11,"sum","","",19,[[["iterator",8]],["u8x4",6]]],[11,"sum","","",21,[[["iterator",8]],["i16x2",6]]],[11,"sum","","",21,[[["iterator",8]],["i16x2",6]]],[11,"sum","","",22,[[["iterator",8]],["u16x2",6]]],[11,"sum","","",22,[[["iterator",8]],["u16x2",6]]],[11,"sum","","",24,[[["iterator",8]],["i8x8",6]]],[11,"sum","","",24,[[["iterator",8]],["i8x8",6]]],[11,"sum","","",25,[[["iterator",8]],["u8x8",6]]],[11,"sum","","",25,[[["iterator",8]],["u8x8",6]]],[11,"sum","","",27,[[["iterator",8]],["i16x4",6]]],[11,"sum","","",27,[[["iterator",8]],["i16x4",6]]],[11,"sum","","",28,[[["iterator",8]],["u16x4",6]]],[11,"sum","","",28,[[["iterator",8]],["u16x4",6]]],[11,"sum","","",30,[[["iterator",8]],["i32x2",6]]],[11,"sum","","",30,[[["iterator",8]],["i32x2",6]]],[11,"sum","","",31,[[["iterator",8]],["u32x2",6]]],[11,"sum","","",31,[[["iterator",8]],["u32x2",6]]],[11,"sum","","",32,[[["iterator",8]],["f32x2",6]]],[11,"sum","","",32,[[["iterator",8]],["f32x2",6]]],[11,"sum","","",34,[[["iterator",8]],["i8x16",6]]],[11,"sum","","",34,[[["iterator",8]],["i8x16",6]]],[11,"sum","","",35,[[["iterator",8]],["u8x16",6]]],[11,"sum","","",35,[[["iterator",8]],["u8x16",6]]],[11,"sum","","",37,[[["iterator",8]],["i16x8",6]]],[11,"sum","","",37,[[["iterator",8]],["i16x8",6]]],[11,"sum","","",38,[[["iterator",8]],["u16x8",6]]],[11,"sum","","",38,[[["iterator",8]],["u16x8",6]]],[11,"sum","","",40,[[["iterator",8]],["i32x4",6]]],[11,"sum","","",40,[[["iterator",8]],["i32x4",6]]],[11,"sum","","",41,[[["iterator",8]],["u32x4",6]]],[11,"sum","","",41,[[["iterator",8]],["u32x4",6]]],[11,"sum","","",42,[[["iterator",8]],["f32x4",6]]],[11,"sum","","",42,[[["iterator",8]],["f32x4",6]]],[11,"sum","","",44,[[["iterator",8]],["i64x2",6]]],[11,"sum","","",44,[[["iterator",8]],["i64x2",6]]],[11,"sum","","",45,[[["iterator",8]],["u64x2",6]]],[11,"sum","","",45,[[["iterator",8]],["u64x2",6]]],[11,"sum","","",46,[[["iterator",8]],["f64x2",6]]],[11,"sum","","",46,[[["iterator",8]],["f64x2",6]]],[11,"sum","","",51,[[["iterator",8]],["i128x1",6]]],[11,"sum","","",51,[[["iterator",8]],["i128x1",6]]],[11,"sum","","",52,[[["iterator",8]],["u128x1",6]]],[11,"sum","","",52,[[["iterator",8]],["u128x1",6]]],[11,"sum","","",54,[[["iterator",8]],["i8x32",6]]],[11,"sum","","",54,[[["iterator",8]],["i8x32",6]]],[11,"sum","","",55,[[["iterator",8]],["u8x32",6]]],[11,"sum","","",55,[[["iterator",8]],["u8x32",6]]],[11,"sum","","",57,[[["iterator",8]],["i16x16",6]]],[11,"sum","","",57,[[["iterator",8]],["i16x16",6]]],[11,"sum","","",58,[[["iterator",8]],["u16x16",6]]],[11,"sum","","",58,[[["iterator",8]],["u16x16",6]]],[11,"sum","","",60,[[["iterator",8]],["i32x8",6]]],[11,"sum","","",60,[[["iterator",8]],["i32x8",6]]],[11,"sum","","",61,[[["iterator",8]],["u32x8",6]]],[11,"sum","","",61,[[["iterator",8]],["u32x8",6]]],[11,"sum","","",62,[[["iterator",8]],["f32x8",6]]],[11,"sum","","",62,[[["iterator",8]],["f32x8",6]]],[11,"sum","","",64,[[["iterator",8]],["i64x4",6]]],[11,"sum","","",64,[[["iterator",8]],["i64x4",6]]],[11,"sum","","",65,[[["iterator",8]],["u64x4",6]]],[11,"sum","","",65,[[["iterator",8]],["u64x4",6]]],[11,"sum","","",66,[[["iterator",8]],["f64x4",6]]],[11,"sum","","",66,[[["iterator",8]],["f64x4",6]]],[11,"sum","","",68,[[["iterator",8]],["i128x2",6]]],[11,"sum","","",68,[[["iterator",8]],["i128x2",6]]],[11,"sum","","",69,[[["iterator",8]],["u128x2",6]]],[11,"sum","","",69,[[["iterator",8]],["u128x2",6]]],[11,"sum","","",74,[[["iterator",8]],["i8x64",6]]],[11,"sum","","",74,[[["iterator",8]],["i8x64",6]]],[11,"sum","","",75,[[["iterator",8]],["u8x64",6]]],[11,"sum","","",75,[[["iterator",8]],["u8x64",6]]],[11,"sum","","",77,[[["iterator",8]],["i16x32",6]]],[11,"sum","","",77,[[["iterator",8]],["i16x32",6]]],[11,"sum","","",78,[[["iterator",8]],["u16x32",6]]],[11,"sum","","",78,[[["iterator",8]],["u16x32",6]]],[11,"sum","","",80,[[["iterator",8]],["i32x16",6]]],[11,"sum","","",80,[[["iterator",8]],["i32x16",6]]],[11,"sum","","",81,[[["iterator",8]],["u32x16",6]]],[11,"sum","","",81,[[["iterator",8]],["u32x16",6]]],[11,"sum","","",82,[[["iterator",8]],["f32x16",6]]],[11,"sum","","",82,[[["iterator",8]],["f32x16",6]]],[11,"sum","","",84,[[["iterator",8]],["i64x8",6]]],[11,"sum","","",84,[[["iterator",8]],["i64x8",6]]],[11,"sum","","",85,[[["iterator",8]],["u64x8",6]]],[11,"sum","","",85,[[["iterator",8]],["u64x8",6]]],[11,"sum","","",86,[[["iterator",8]],["f64x8",6]]],[11,"sum","","",86,[[["iterator",8]],["f64x8",6]]],[11,"sum","","",88,[[["iterator",8]],["i128x4",6]]],[11,"sum","","",88,[[["iterator",8]],["i128x4",6]]],[11,"sum","","",89,[[["iterator",8]],["u128x4",6]]],[11,"sum","","",89,[[["iterator",8]],["u128x4",6]]],[11,"sum","","",48,[[["iterator",8]],["isizex2",6]]],[11,"sum","","",48,[[["iterator",8]],["isizex2",6]]],[11,"sum","","",49,[[["iterator",8]],["usizex2",6]]],[11,"sum","","",49,[[["iterator",8]],["usizex2",6]]],[11,"sum","","",71,[[["iterator",8]],["isizex4",6]]],[11,"sum","","",71,[[["iterator",8]],["isizex4",6]]],[11,"sum","","",72,[[["iterator",8]],["usizex4",6]]],[11,"sum","","",72,[[["iterator",8]],["usizex4",6]]],[11,"sum","","",91,[[["iterator",8]],["isizex8",6]]],[11,"sum","","",91,[[["iterator",8]],["isizex8",6]]],[11,"sum","","",92,[[["iterator",8]],["usizex8",6]]],[11,"sum","","",92,[[["iterator",8]],["usizex8",6]]],[11,"product","","",15,[[["iterator",8]],["i8x2",6]]],[11,"product","","",15,[[["iterator",8]],["i8x2",6]]],[11,"product","","",16,[[["iterator",8]],["u8x2",6]]],[11,"product","","",16,[[["iterator",8]],["u8x2",6]]],[11,"product","","",18,[[["iterator",8]],["i8x4",6]]],[11,"product","","",18,[[["iterator",8]],["i8x4",6]]],[11,"product","","",19,[[["iterator",8]],["u8x4",6]]],[11,"product","","",19,[[["iterator",8]],["u8x4",6]]],[11,"product","","",21,[[["iterator",8]],["i16x2",6]]],[11,"product","","",21,[[["iterator",8]],["i16x2",6]]],[11,"product","","",22,[[["iterator",8]],["u16x2",6]]],[11,"product","","",22,[[["iterator",8]],["u16x2",6]]],[11,"product","","",24,[[["iterator",8]],["i8x8",6]]],[11,"product","","",24,[[["iterator",8]],["i8x8",6]]],[11,"product","","",25,[[["iterator",8]],["u8x8",6]]],[11,"product","","",25,[[["iterator",8]],["u8x8",6]]],[11,"product","","",27,[[["iterator",8]],["i16x4",6]]],[11,"product","","",27,[[["iterator",8]],["i16x4",6]]],[11,"product","","",28,[[["iterator",8]],["u16x4",6]]],[11,"product","","",28,[[["iterator",8]],["u16x4",6]]],[11,"product","","",30,[[["iterator",8]],["i32x2",6]]],[11,"product","","",30,[[["iterator",8]],["i32x2",6]]],[11,"product","","",31,[[["iterator",8]],["u32x2",6]]],[11,"product","","",31,[[["iterator",8]],["u32x2",6]]],[11,"product","","",32,[[["iterator",8]],["f32x2",6]]],[11,"product","","",32,[[["iterator",8]],["f32x2",6]]],[11,"product","","",34,[[["iterator",8]],["i8x16",6]]],[11,"product","","",34,[[["iterator",8]],["i8x16",6]]],[11,"product","","",35,[[["iterator",8]],["u8x16",6]]],[11,"product","","",35,[[["iterator",8]],["u8x16",6]]],[11,"product","","",37,[[["iterator",8]],["i16x8",6]]],[11,"product","","",37,[[["iterator",8]],["i16x8",6]]],[11,"product","","",38,[[["iterator",8]],["u16x8",6]]],[11,"product","","",38,[[["iterator",8]],["u16x8",6]]],[11,"product","","",40,[[["iterator",8]],["i32x4",6]]],[11,"product","","",40,[[["iterator",8]],["i32x4",6]]],[11,"product","","",41,[[["iterator",8]],["u32x4",6]]],[11,"product","","",41,[[["iterator",8]],["u32x4",6]]],[11,"product","","",42,[[["iterator",8]],["f32x4",6]]],[11,"product","","",42,[[["iterator",8]],["f32x4",6]]],[11,"product","","",44,[[["iterator",8]],["i64x2",6]]],[11,"product","","",44,[[["iterator",8]],["i64x2",6]]],[11,"product","","",45,[[["iterator",8]],["u64x2",6]]],[11,"product","","",45,[[["iterator",8]],["u64x2",6]]],[11,"product","","",46,[[["iterator",8]],["f64x2",6]]],[11,"product","","",46,[[["iterator",8]],["f64x2",6]]],[11,"product","","",51,[[["iterator",8]],["i128x1",6]]],[11,"product","","",51,[[["iterator",8]],["i128x1",6]]],[11,"product","","",52,[[["iterator",8]],["u128x1",6]]],[11,"product","","",52,[[["iterator",8]],["u128x1",6]]],[11,"product","","",54,[[["iterator",8]],["i8x32",6]]],[11,"product","","",54,[[["iterator",8]],["i8x32",6]]],[11,"product","","",55,[[["iterator",8]],["u8x32",6]]],[11,"product","","",55,[[["iterator",8]],["u8x32",6]]],[11,"product","","",57,[[["iterator",8]],["i16x16",6]]],[11,"product","","",57,[[["iterator",8]],["i16x16",6]]],[11,"product","","",58,[[["iterator",8]],["u16x16",6]]],[11,"product","","",58,[[["iterator",8]],["u16x16",6]]],[11,"product","","",60,[[["iterator",8]],["i32x8",6]]],[11,"product","","",60,[[["iterator",8]],["i32x8",6]]],[11,"product","","",61,[[["iterator",8]],["u32x8",6]]],[11,"product","","",61,[[["iterator",8]],["u32x8",6]]],[11,"product","","",62,[[["iterator",8]],["f32x8",6]]],[11,"product","","",62,[[["iterator",8]],["f32x8",6]]],[11,"product","","",64,[[["iterator",8]],["i64x4",6]]],[11,"product","","",64,[[["iterator",8]],["i64x4",6]]],[11,"product","","",65,[[["iterator",8]],["u64x4",6]]],[11,"product","","",65,[[["iterator",8]],["u64x4",6]]],[11,"product","","",66,[[["iterator",8]],["f64x4",6]]],[11,"product","","",66,[[["iterator",8]],["f64x4",6]]],[11,"product","","",68,[[["iterator",8]],["i128x2",6]]],[11,"product","","",68,[[["iterator",8]],["i128x2",6]]],[11,"product","","",69,[[["iterator",8]],["u128x2",6]]],[11,"product","","",69,[[["iterator",8]],["u128x2",6]]],[11,"product","","",74,[[["iterator",8]],["i8x64",6]]],[11,"product","","",74,[[["iterator",8]],["i8x64",6]]],[11,"product","","",75,[[["iterator",8]],["u8x64",6]]],[11,"product","","",75,[[["iterator",8]],["u8x64",6]]],[11,"product","","",77,[[["iterator",8]],["i16x32",6]]],[11,"product","","",77,[[["iterator",8]],["i16x32",6]]],[11,"product","","",78,[[["iterator",8]],["u16x32",6]]],[11,"product","","",78,[[["iterator",8]],["u16x32",6]]],[11,"product","","",80,[[["iterator",8]],["i32x16",6]]],[11,"product","","",80,[[["iterator",8]],["i32x16",6]]],[11,"product","","",81,[[["iterator",8]],["u32x16",6]]],[11,"product","","",81,[[["iterator",8]],["u32x16",6]]],[11,"product","","",82,[[["iterator",8]],["f32x16",6]]],[11,"product","","",82,[[["iterator",8]],["f32x16",6]]],[11,"product","","",84,[[["iterator",8]],["i64x8",6]]],[11,"product","","",84,[[["iterator",8]],["i64x8",6]]],[11,"product","","",85,[[["iterator",8]],["u64x8",6]]],[11,"product","","",85,[[["iterator",8]],["u64x8",6]]],[11,"product","","",86,[[["iterator",8]],["f64x8",6]]],[11,"product","","",86,[[["iterator",8]],["f64x8",6]]],[11,"product","","",88,[[["iterator",8]],["i128x4",6]]],[11,"product","","",88,[[["iterator",8]],["i128x4",6]]],[11,"product","","",89,[[["iterator",8]],["u128x4",6]]],[11,"product","","",89,[[["iterator",8]],["u128x4",6]]],[11,"product","","",48,[[["iterator",8]],["isizex2",6]]],[11,"product","","",48,[[["iterator",8]],["isizex2",6]]],[11,"product","","",49,[[["iterator",8]],["usizex2",6]]],[11,"product","","",49,[[["iterator",8]],["usizex2",6]]],[11,"product","","",71,[[["iterator",8]],["isizex4",6]]],[11,"product","","",71,[[["iterator",8]],["isizex4",6]]],[11,"product","","",72,[[["iterator",8]],["usizex4",6]]],[11,"product","","",72,[[["iterator",8]],["usizex4",6]]],[11,"product","","",91,[[["iterator",8]],["isizex8",6]]],[11,"product","","",91,[[["iterator",8]],["isizex8",6]]],[11,"product","","",92,[[["iterator",8]],["usizex8",6]]],[11,"product","","",92,[[["iterator",8]],["usizex8",6]]],[11,"clone","","",6,[[],["simd",3]]],[11,"clone","","",14,[[],["lexicographicallyordered",3]]],[11,"clone","","",0,[[],["m8",3]]],[11,"clone","","",1,[[],["m16",3]]],[11,"clone","","",2,[[],["m32",3]]],[11,"clone","","",3,[[],["m64",3]]],[11,"clone","","",4,[[],["m128",3]]],[11,"clone","","",5,[[],["msize",3]]],[11,"default","","",0,[[]]],[11,"default","","",1,[[]]],[11,"default","","",2,[[]]],[11,"default","","",3,[[]]],[11,"default","","",4,[[]]],[11,"default","","",5,[[]]],[11,"default","","",15,[[]]],[11,"default","","",16,[[]]],[11,"default","","",17,[[]]],[11,"default","","",18,[[]]],[11,"default","","",19,[[]]],[11,"default","","",20,[[]]],[11,"default","","",21,[[]]],[11,"default","","",22,[[]]],[11,"default","","",23,[[]]],[11,"default","","",24,[[]]],[11,"default","","",25,[[]]],[11,"default","","",26,[[]]],[11,"default","","",27,[[]]],[11,"default","","",28,[[]]],[11,"default","","",29,[[]]],[11,"default","","",30,[[]]],[11,"default","","",31,[[]]],[11,"default","","",33,[[]]],[11,"default","","",32,[[]]],[11,"default","","",34,[[]]],[11,"default","","",35,[[]]],[11,"default","","",36,[[]]],[11,"default","","",37,[[]]],[11,"default","","",38,[[]]],[11,"default","","",39,[[]]],[11,"default","","",40,[[]]],[11,"default","","",41,[[]]],[11,"default","","",42,[[]]],[11,"default","","",43,[[]]],[11,"default","","",44,[[]]],[11,"default","","",45,[[]]],[11,"default","","",46,[[]]],[11,"default","","",47,[[]]],[11,"default","","",51,[[]]],[11,"default","","",52,[[]]],[11,"default","","",53,[[]]],[11,"default","","",54,[[]]],[11,"default","","",55,[[]]],[11,"default","","",56,[[]]],[11,"default","","",57,[[]]],[11,"default","","",58,[[]]],[11,"default","","",59,[[]]],[11,"default","","",60,[[]]],[11,"default","","",61,[[]]],[11,"default","","",62,[[]]],[11,"default","","",63,[[]]],[11,"default","","",64,[[]]],[11,"default","","",65,[[]]],[11,"default","","",66,[[]]],[11,"default","","",67,[[]]],[11,"default","","",68,[[]]],[11,"default","","",69,[[]]],[11,"default","","",70,[[]]],[11,"default","","",74,[[]]],[11,"default","","",75,[[]]],[11,"default","","",76,[[]]],[11,"default","","",77,[[]]],[11,"default","","",78,[[]]],[11,"default","","",79,[[]]],[11,"default","","",80,[[]]],[11,"default","","",81,[[]]],[11,"default","","",82,[[]]],[11,"default","","",83,[[]]],[11,"default","","",84,[[]]],[11,"default","","",85,[[]]],[11,"default","","",86,[[]]],[11,"default","","",87,[[]]],[11,"default","","",88,[[]]],[11,"default","","",89,[[]]],[11,"default","","",90,[[]]],[11,"default","","",48,[[]]],[11,"default","","",49,[[]]],[11,"default","","",50,[[]]],[11,"default","","",71,[[]]],[11,"default","","",72,[[]]],[11,"default","","",73,[[]]],[11,"default","","",91,[[]]],[11,"default","","",92,[[]]],[11,"default","","",93,[[]]],[11,"default","","",94,[[]]],[11,"default","","",95,[[]]],[11,"default","","",96,[[]]],[11,"default","","",97,[[]]],[11,"default","","",98,[[]]],[11,"default","","",99,[[]]],[18,"N","","The number of elements in the array.",8,null],[18,"LANES","","The number of elements in the SIMD vector.",7,null],[11,"new","","Creates a new instance with each vector elements…",15,[[]]],[11,"lanes","","Returns the number of vector lanes.",15,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",15,[[]]],[11,"extract","","Extracts the value at `index`.",15,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",15,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",15,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",15,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",15,[[["i8x2",6]],["i8x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",15,[[["i8x2",6]],["i8x2",6]]],[11,"min","","Minimum of two vectors.",15,[[]]],[11,"max","","Maximum of two vectors.",15,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",15,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",15,[[]]],[11,"max_element","","Largest vector element value.",15,[[]]],[11,"min_element","","Smallest vector element value.",15,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",15,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",15,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",15,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",15,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",15,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",15,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",15,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",15,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",15,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",15,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",15,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",15,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",15,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",15,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",15,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",15,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",15,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",15,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",15,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",15,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",15,[[]]],[11,"eq","","Lane-wise equality comparison.",15,[[],["m8x2",6]]],[11,"ne","","Lane-wise inequality comparison.",15,[[],["m8x2",6]]],[11,"lt","","Lane-wise less-than comparison.",15,[[],["m8x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",15,[[],["m8x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",15,[[],["m8x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",15,[[],["m8x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",15,[[],[["lexicographicallyordered",3],["i8x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",15,[[],[["lexicographicallyordered",3],["i8x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",15,[[]]],[11,"new","","Creates a new instance with each vector elements…",16,[[]]],[11,"lanes","","Returns the number of vector lanes.",16,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",16,[[]]],[11,"extract","","Extracts the value at `index`.",16,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",16,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",16,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",16,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",16,[[["u8x2",6]],["u8x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",16,[[["u8x2",6]],["u8x2",6]]],[11,"min","","Minimum of two vectors.",16,[[]]],[11,"max","","Maximum of two vectors.",16,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",16,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",16,[[]]],[11,"max_element","","Largest vector element value.",16,[[]]],[11,"min_element","","Smallest vector element value.",16,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",16,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",16,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",16,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",16,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",16,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",16,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",16,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",16,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",16,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",16,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",16,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",16,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",16,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",16,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",16,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",16,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",16,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",16,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",16,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",16,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",16,[[]]],[11,"eq","","Lane-wise equality comparison.",16,[[],["m8x2",6]]],[11,"ne","","Lane-wise inequality comparison.",16,[[],["m8x2",6]]],[11,"lt","","Lane-wise less-than comparison.",16,[[],["m8x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",16,[[],["m8x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",16,[[],["m8x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",16,[[],["m8x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",16,[[],[["u8x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",16,[[],[["u8x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",16,[[]]],[11,"new","","Creates a new instance with each vector elements…",17,[[]]],[11,"lanes","","Returns the number of vector lanes.",17,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",17,[[]]],[11,"extract","","Extracts the value at `index`.",17,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",17,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",17,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",17,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",17,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",17,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",17,[[]]],[11,"all","","Are `all` vector lanes `true`?",17,[[]]],[11,"any","","Is `any` vector lane `true`?",17,[[]]],[11,"none","","Are `all` vector lanes `false`?",17,[[]]],[11,"eq","","Lane-wise equality comparison.",17,[[],["m8x2",6]]],[11,"ne","","Lane-wise inequality comparison.",17,[[],["m8x2",6]]],[11,"lt","","Lane-wise less-than comparison.",17,[[],["m8x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",17,[[],["m8x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",17,[[],["m8x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",17,[[],["m8x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",17,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",17,[[],[["m8x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",17,[[],[["m8x2",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",17,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",17,[[]]],[11,"new","","Creates a new instance with each vector elements…",18,[[]]],[11,"lanes","","Returns the number of vector lanes.",18,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",18,[[]]],[11,"extract","","Extracts the value at `index`.",18,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",18,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",18,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",18,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",18,[[["i8x4",6]],["i8x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",18,[[["i8x4",6]],["i8x4",6]]],[11,"min","","Minimum of two vectors.",18,[[]]],[11,"max","","Maximum of two vectors.",18,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",18,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",18,[[]]],[11,"max_element","","Largest vector element value.",18,[[]]],[11,"min_element","","Smallest vector element value.",18,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",18,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",18,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",18,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",18,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",18,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",18,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",18,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",18,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",18,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",18,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",18,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",18,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",18,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",18,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",18,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",18,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",18,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",18,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",18,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",18,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",18,[[]]],[11,"eq","","Lane-wise equality comparison.",18,[[],["m8x4",6]]],[11,"ne","","Lane-wise inequality comparison.",18,[[],["m8x4",6]]],[11,"lt","","Lane-wise less-than comparison.",18,[[],["m8x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",18,[[],["m8x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",18,[[],["m8x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",18,[[],["m8x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",18,[[],[["lexicographicallyordered",3],["i8x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",18,[[],[["lexicographicallyordered",3],["i8x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",18,[[]]],[11,"new","","Creates a new instance with each vector elements…",19,[[]]],[11,"lanes","","Returns the number of vector lanes.",19,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",19,[[]]],[11,"extract","","Extracts the value at `index`.",19,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",19,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",19,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",19,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",19,[[["u8x4",6]],["u8x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",19,[[["u8x4",6]],["u8x4",6]]],[11,"min","","Minimum of two vectors.",19,[[]]],[11,"max","","Maximum of two vectors.",19,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",19,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",19,[[]]],[11,"max_element","","Largest vector element value.",19,[[]]],[11,"min_element","","Smallest vector element value.",19,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",19,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",19,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",19,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",19,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",19,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",19,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",19,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",19,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",19,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",19,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",19,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",19,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",19,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",19,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",19,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",19,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",19,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",19,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",19,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",19,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",19,[[]]],[11,"eq","","Lane-wise equality comparison.",19,[[],["m8x4",6]]],[11,"ne","","Lane-wise inequality comparison.",19,[[],["m8x4",6]]],[11,"lt","","Lane-wise less-than comparison.",19,[[],["m8x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",19,[[],["m8x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",19,[[],["m8x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",19,[[],["m8x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",19,[[],[["u8x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",19,[[],[["u8x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",19,[[]]],[11,"new","","Creates a new instance with each vector elements…",20,[[]]],[11,"lanes","","Returns the number of vector lanes.",20,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",20,[[]]],[11,"extract","","Extracts the value at `index`.",20,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",20,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",20,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",20,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",20,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",20,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",20,[[]]],[11,"all","","Are `all` vector lanes `true`?",20,[[]]],[11,"any","","Is `any` vector lane `true`?",20,[[]]],[11,"none","","Are `all` vector lanes `false`?",20,[[]]],[11,"eq","","Lane-wise equality comparison.",20,[[],["m8x4",6]]],[11,"ne","","Lane-wise inequality comparison.",20,[[],["m8x4",6]]],[11,"lt","","Lane-wise less-than comparison.",20,[[],["m8x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",20,[[],["m8x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",20,[[],["m8x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",20,[[],["m8x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",20,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",20,[[],[["lexicographicallyordered",3],["m8x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",20,[[],[["lexicographicallyordered",3],["m8x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",20,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",20,[[]]],[11,"new","","Creates a new instance with each vector elements…",21,[[]]],[11,"lanes","","Returns the number of vector lanes.",21,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",21,[[]]],[11,"extract","","Extracts the value at `index`.",21,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",21,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",21,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",21,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",21,[[["i16x2",6]],["i16x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",21,[[["i16x2",6]],["i16x2",6]]],[11,"min","","Minimum of two vectors.",21,[[]]],[11,"max","","Maximum of two vectors.",21,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",21,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",21,[[]]],[11,"max_element","","Largest vector element value.",21,[[]]],[11,"min_element","","Smallest vector element value.",21,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",21,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",21,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",21,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",21,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",21,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",21,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",21,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",21,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",21,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",21,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",21,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",21,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",21,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",21,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",21,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",21,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",21,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",21,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",21,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",21,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",21,[[]]],[11,"eq","","Lane-wise equality comparison.",21,[[],["m16x2",6]]],[11,"ne","","Lane-wise inequality comparison.",21,[[],["m16x2",6]]],[11,"lt","","Lane-wise less-than comparison.",21,[[],["m16x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",21,[[],["m16x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",21,[[],["m16x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",21,[[],["m16x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",21,[[],[["lexicographicallyordered",3],["i16x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",21,[[],[["lexicographicallyordered",3],["i16x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",21,[[]]],[11,"new","","Creates a new instance with each vector elements…",22,[[]]],[11,"lanes","","Returns the number of vector lanes.",22,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",22,[[]]],[11,"extract","","Extracts the value at `index`.",22,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",22,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",22,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",22,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",22,[[["u16x2",6]],["u16x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",22,[[["u16x2",6]],["u16x2",6]]],[11,"min","","Minimum of two vectors.",22,[[]]],[11,"max","","Maximum of two vectors.",22,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",22,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",22,[[]]],[11,"max_element","","Largest vector element value.",22,[[]]],[11,"min_element","","Smallest vector element value.",22,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",22,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",22,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",22,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",22,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",22,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",22,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",22,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",22,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",22,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",22,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",22,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",22,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",22,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",22,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",22,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",22,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",22,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",22,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",22,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",22,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",22,[[]]],[11,"eq","","Lane-wise equality comparison.",22,[[],["m16x2",6]]],[11,"ne","","Lane-wise inequality comparison.",22,[[],["m16x2",6]]],[11,"lt","","Lane-wise less-than comparison.",22,[[],["m16x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",22,[[],["m16x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",22,[[],["m16x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",22,[[],["m16x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",22,[[],[["u16x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",22,[[],[["u16x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",22,[[]]],[11,"new","","Creates a new instance with each vector elements…",23,[[]]],[11,"lanes","","Returns the number of vector lanes.",23,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",23,[[]]],[11,"extract","","Extracts the value at `index`.",23,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",23,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",23,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",23,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",23,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",23,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",23,[[]]],[11,"all","","Are `all` vector lanes `true`?",23,[[]]],[11,"any","","Is `any` vector lane `true`?",23,[[]]],[11,"none","","Are `all` vector lanes `false`?",23,[[]]],[11,"eq","","Lane-wise equality comparison.",23,[[],["m16x2",6]]],[11,"ne","","Lane-wise inequality comparison.",23,[[],["m16x2",6]]],[11,"lt","","Lane-wise less-than comparison.",23,[[],["m16x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",23,[[],["m16x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",23,[[],["m16x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",23,[[],["m16x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",23,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",23,[[],[["lexicographicallyordered",3],["m16x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",23,[[],[["lexicographicallyordered",3],["m16x2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",23,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",23,[[]]],[11,"new","","Creates a new instance with each vector elements…",24,[[]]],[11,"lanes","","Returns the number of vector lanes.",24,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",24,[[]]],[11,"extract","","Extracts the value at `index`.",24,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",24,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",24,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",24,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",24,[[["i8x8",6]],["i8x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",24,[[["i8x8",6]],["i8x8",6]]],[11,"min","","Minimum of two vectors.",24,[[]]],[11,"max","","Maximum of two vectors.",24,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",24,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",24,[[]]],[11,"max_element","","Largest vector element value.",24,[[]]],[11,"min_element","","Smallest vector element value.",24,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",24,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",24,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",24,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",24,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",24,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",24,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",24,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",24,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",24,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",24,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",24,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",24,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",24,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",24,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",24,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",24,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",24,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",24,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",24,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",24,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",24,[[]]],[11,"eq","","Lane-wise equality comparison.",24,[[],["m8x8",6]]],[11,"ne","","Lane-wise inequality comparison.",24,[[],["m8x8",6]]],[11,"lt","","Lane-wise less-than comparison.",24,[[],["m8x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",24,[[],["m8x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",24,[[],["m8x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",24,[[],["m8x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",24,[[],[["i8x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",24,[[],[["i8x8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",24,[[]]],[11,"new","","Creates a new instance with each vector elements…",25,[[]]],[11,"lanes","","Returns the number of vector lanes.",25,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",25,[[]]],[11,"extract","","Extracts the value at `index`.",25,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",25,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",25,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",25,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",25,[[["u8x8",6]],["u8x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",25,[[["u8x8",6]],["u8x8",6]]],[11,"min","","Minimum of two vectors.",25,[[]]],[11,"max","","Maximum of two vectors.",25,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",25,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",25,[[]]],[11,"max_element","","Largest vector element value.",25,[[]]],[11,"min_element","","Smallest vector element value.",25,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",25,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",25,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",25,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",25,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",25,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",25,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",25,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",25,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",25,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",25,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",25,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",25,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",25,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",25,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",25,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",25,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",25,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",25,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",25,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",25,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",25,[[]]],[11,"eq","","Lane-wise equality comparison.",25,[[],["m8x8",6]]],[11,"ne","","Lane-wise inequality comparison.",25,[[],["m8x8",6]]],[11,"lt","","Lane-wise less-than comparison.",25,[[],["m8x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",25,[[],["m8x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",25,[[],["m8x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",25,[[],["m8x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",25,[[],[["lexicographicallyordered",3],["u8x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",25,[[],[["lexicographicallyordered",3],["u8x8",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",25,[[]]],[11,"new","","Creates a new instance with each vector elements…",26,[[]]],[11,"lanes","","Returns the number of vector lanes.",26,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",26,[[]]],[11,"extract","","Extracts the value at `index`.",26,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",26,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",26,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",26,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",26,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",26,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",26,[[]]],[11,"all","","Are `all` vector lanes `true`?",26,[[]]],[11,"any","","Is `any` vector lane `true`?",26,[[]]],[11,"none","","Are `all` vector lanes `false`?",26,[[]]],[11,"eq","","Lane-wise equality comparison.",26,[[],["m8x8",6]]],[11,"ne","","Lane-wise inequality comparison.",26,[[],["m8x8",6]]],[11,"lt","","Lane-wise less-than comparison.",26,[[],["m8x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",26,[[],["m8x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",26,[[],["m8x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",26,[[],["m8x8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",26,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",26,[[],[["m8x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",26,[[],[["m8x8",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",26,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",26,[[]]],[11,"new","","Creates a new instance with each vector elements…",27,[[]]],[11,"lanes","","Returns the number of vector lanes.",27,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",27,[[]]],[11,"extract","","Extracts the value at `index`.",27,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",27,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",27,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",27,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",27,[[["i16x4",6]],["i16x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",27,[[["i16x4",6]],["i16x4",6]]],[11,"min","","Minimum of two vectors.",27,[[]]],[11,"max","","Maximum of two vectors.",27,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",27,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",27,[[]]],[11,"max_element","","Largest vector element value.",27,[[]]],[11,"min_element","","Smallest vector element value.",27,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",27,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",27,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",27,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",27,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",27,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",27,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",27,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",27,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",27,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",27,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",27,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",27,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",27,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",27,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",27,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",27,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",27,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",27,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",27,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",27,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",27,[[]]],[11,"eq","","Lane-wise equality comparison.",27,[[],["m16x4",6]]],[11,"ne","","Lane-wise inequality comparison.",27,[[],["m16x4",6]]],[11,"lt","","Lane-wise less-than comparison.",27,[[],["m16x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",27,[[],["m16x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",27,[[],["m16x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",27,[[],["m16x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",27,[[],[["i16x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",27,[[],[["i16x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",27,[[]]],[11,"new","","Creates a new instance with each vector elements…",28,[[]]],[11,"lanes","","Returns the number of vector lanes.",28,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",28,[[]]],[11,"extract","","Extracts the value at `index`.",28,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",28,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",28,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",28,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",28,[[["u16x4",6]],["u16x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",28,[[["u16x4",6]],["u16x4",6]]],[11,"min","","Minimum of two vectors.",28,[[]]],[11,"max","","Maximum of two vectors.",28,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",28,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",28,[[]]],[11,"max_element","","Largest vector element value.",28,[[]]],[11,"min_element","","Smallest vector element value.",28,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",28,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",28,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",28,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",28,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",28,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",28,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",28,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",28,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",28,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",28,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",28,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",28,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",28,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",28,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",28,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",28,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",28,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",28,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",28,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",28,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",28,[[]]],[11,"eq","","Lane-wise equality comparison.",28,[[],["m16x4",6]]],[11,"ne","","Lane-wise inequality comparison.",28,[[],["m16x4",6]]],[11,"lt","","Lane-wise less-than comparison.",28,[[],["m16x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",28,[[],["m16x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",28,[[],["m16x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",28,[[],["m16x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",28,[[],[["lexicographicallyordered",3],["u16x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",28,[[],[["lexicographicallyordered",3],["u16x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",28,[[]]],[11,"new","","Creates a new instance with each vector elements…",29,[[]]],[11,"lanes","","Returns the number of vector lanes.",29,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",29,[[]]],[11,"extract","","Extracts the value at `index`.",29,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",29,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",29,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",29,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",29,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",29,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",29,[[]]],[11,"all","","Are `all` vector lanes `true`?",29,[[]]],[11,"any","","Is `any` vector lane `true`?",29,[[]]],[11,"none","","Are `all` vector lanes `false`?",29,[[]]],[11,"eq","","Lane-wise equality comparison.",29,[[],["m16x4",6]]],[11,"ne","","Lane-wise inequality comparison.",29,[[],["m16x4",6]]],[11,"lt","","Lane-wise less-than comparison.",29,[[],["m16x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",29,[[],["m16x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",29,[[],["m16x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",29,[[],["m16x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",29,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",29,[[],[["lexicographicallyordered",3],["m16x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",29,[[],[["lexicographicallyordered",3],["m16x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",29,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",29,[[]]],[11,"new","","Creates a new instance with each vector elements…",30,[[]]],[11,"lanes","","Returns the number of vector lanes.",30,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",30,[[]]],[11,"extract","","Extracts the value at `index`.",30,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",30,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",30,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",30,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",30,[[["i32x2",6]],["i32x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",30,[[["i32x2",6]],["i32x2",6]]],[11,"min","","Minimum of two vectors.",30,[[]]],[11,"max","","Maximum of two vectors.",30,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",30,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",30,[[]]],[11,"max_element","","Largest vector element value.",30,[[]]],[11,"min_element","","Smallest vector element value.",30,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",30,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",30,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",30,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",30,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",30,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",30,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",30,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",30,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",30,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",30,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",30,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",30,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",30,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",30,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",30,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",30,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",30,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",30,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",30,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",30,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",30,[[]]],[11,"eq","","Lane-wise equality comparison.",30,[[],["m32x2",6]]],[11,"ne","","Lane-wise inequality comparison.",30,[[],["m32x2",6]]],[11,"lt","","Lane-wise less-than comparison.",30,[[],["m32x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",30,[[],["m32x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",30,[[],["m32x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",30,[[],["m32x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",30,[[],[["i32x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",30,[[],[["i32x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",30,[[]]],[11,"new","","Creates a new instance with each vector elements…",31,[[]]],[11,"lanes","","Returns the number of vector lanes.",31,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",31,[[]]],[11,"extract","","Extracts the value at `index`.",31,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",31,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",31,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",31,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",31,[[["u32x2",6]],["u32x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",31,[[["u32x2",6]],["u32x2",6]]],[11,"min","","Minimum of two vectors.",31,[[]]],[11,"max","","Maximum of two vectors.",31,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",31,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",31,[[]]],[11,"max_element","","Largest vector element value.",31,[[]]],[11,"min_element","","Smallest vector element value.",31,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",31,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",31,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",31,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",31,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",31,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",31,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",31,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",31,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",31,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",31,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",31,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",31,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",31,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",31,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",31,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",31,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",31,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",31,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",31,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",31,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",31,[[]]],[11,"eq","","Lane-wise equality comparison.",31,[[],["m32x2",6]]],[11,"ne","","Lane-wise inequality comparison.",31,[[],["m32x2",6]]],[11,"lt","","Lane-wise less-than comparison.",31,[[],["m32x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",31,[[],["m32x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",31,[[],["m32x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",31,[[],["m32x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",31,[[],[["u32x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",31,[[],[["u32x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",31,[[]]],[11,"new","","Creates a new instance with each vector elements…",33,[[]]],[11,"lanes","","Returns the number of vector lanes.",33,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",33,[[]]],[11,"extract","","Extracts the value at `index`.",33,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",33,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",33,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",33,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",33,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",33,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",33,[[]]],[11,"all","","Are `all` vector lanes `true`?",33,[[]]],[11,"any","","Is `any` vector lane `true`?",33,[[]]],[11,"none","","Are `all` vector lanes `false`?",33,[[]]],[11,"eq","","Lane-wise equality comparison.",33,[[],["m32x2",6]]],[11,"ne","","Lane-wise inequality comparison.",33,[[],["m32x2",6]]],[11,"lt","","Lane-wise less-than comparison.",33,[[],["m32x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",33,[[],["m32x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",33,[[],["m32x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",33,[[],["m32x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",33,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",33,[[],[["lexicographicallyordered",3],["m32x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",33,[[],[["lexicographicallyordered",3],["m32x2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",33,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",33,[[]]],[11,"new","","Creates a new instance with each vector elements…",32,[[]]],[11,"lanes","","Returns the number of vector lanes.",32,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",32,[[]]],[11,"extract","","Extracts the value at `index`.",32,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",32,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",32,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",32,[[]]],[11,"min","","Minimum of two vectors.",32,[[]]],[11,"max","","Maximum of two vectors.",32,[[]]],[11,"sum","","Horizontal sum of the vector elements.",32,[[]]],[11,"product","","Horizontal product of the vector elements.",32,[[]]],[11,"max_element","","Largest vector element value.",32,[[]]],[11,"min_element","","Smallest vector element value.",32,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",32,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",32,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",32,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",32,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",32,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",32,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",32,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",32,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",32,[[]]],[18,"EPSILON","","Machine epsilon value.",32,null],[18,"MIN","","Smallest finite value.",32,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",32,null],[18,"MAX","","Largest finite value.",32,null],[18,"NAN","","Not a Number (NaN).",32,null],[18,"INFINITY","","Infinity (∞).",32,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",32,null],[18,"PI","","Archimedes\' constant (π)",32,null],[18,"FRAC_PI_2","","π/2",32,null],[18,"FRAC_PI_3","","π/3",32,null],[18,"FRAC_PI_4","","π/4",32,null],[18,"FRAC_PI_6","","π/6",32,null],[18,"FRAC_PI_8","","π/8",32,null],[18,"FRAC_1_PI","","1/π",32,null],[18,"FRAC_2_PI","","2/π",32,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",32,null],[18,"SQRT_2","","sqrt(2)",32,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",32,null],[18,"E","","Euler\'s number (e)",32,null],[18,"LOG2_E","","log2(e)",32,null],[18,"LOG10_E","","log10(e)",32,null],[18,"LN_2","","ln(2)",32,null],[18,"LN_10","","ln(10)",32,null],[11,"is_nan","","",32,[[],["m32x2",6]]],[11,"is_infinite","","",32,[[],["m32x2",6]]],[11,"is_finite","","",32,[[],["m32x2",6]]],[11,"abs","","Absolute value.",32,[[]]],[11,"cos","","Cosine.",32,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",32,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",32,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",32,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",32,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",32,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",32,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",32,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",32,[[]]],[11,"sin","","Sine.",32,[[]]],[11,"sin_pi","","Sine of `self * PI`.",32,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",32,[[]]],[11,"sqrt","","",32,[[]]],[11,"sqrte","","Square-root estimate.",32,[[]]],[11,"tanh","","Tanh.",32,[[]]],[11,"eq","","Lane-wise equality comparison.",32,[[],["m32x2",6]]],[11,"ne","","Lane-wise inequality comparison.",32,[[],["m32x2",6]]],[11,"lt","","Lane-wise less-than comparison.",32,[[],["m32x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",32,[[],["m32x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",32,[[],["m32x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",32,[[],["m32x2",6]]],[11,"new","","Creates a new instance with each vector elements…",34,[[]]],[11,"lanes","","Returns the number of vector lanes.",34,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",34,[[]]],[11,"extract","","Extracts the value at `index`.",34,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",34,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",34,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",34,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",34,[[["i8x16",6]],["i8x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",34,[[["i8x16",6]],["i8x16",6]]],[11,"min","","Minimum of two vectors.",34,[[]]],[11,"max","","Maximum of two vectors.",34,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",34,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",34,[[]]],[11,"max_element","","Largest vector element value.",34,[[]]],[11,"min_element","","Smallest vector element value.",34,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",34,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",34,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",34,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",34,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",34,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",34,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",34,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",34,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",34,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",34,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",34,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",34,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",34,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",34,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",34,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",34,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",34,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",34,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",34,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",34,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",34,[[]]],[11,"eq","","Lane-wise equality comparison.",34,[[],["m8x16",6]]],[11,"ne","","Lane-wise inequality comparison.",34,[[],["m8x16",6]]],[11,"lt","","Lane-wise less-than comparison.",34,[[],["m8x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",34,[[],["m8x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",34,[[],["m8x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",34,[[],["m8x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",34,[[],[["i8x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",34,[[],[["i8x16",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",34,[[]]],[11,"new","","Creates a new instance with each vector elements…",35,[[]]],[11,"lanes","","Returns the number of vector lanes.",35,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",35,[[]]],[11,"extract","","Extracts the value at `index`.",35,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",35,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",35,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",35,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",35,[[["u8x16",6]],["u8x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",35,[[["u8x16",6]],["u8x16",6]]],[11,"min","","Minimum of two vectors.",35,[[]]],[11,"max","","Maximum of two vectors.",35,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",35,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",35,[[]]],[11,"max_element","","Largest vector element value.",35,[[]]],[11,"min_element","","Smallest vector element value.",35,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",35,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",35,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",35,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",35,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",35,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",35,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",35,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",35,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",35,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",35,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",35,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",35,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",35,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",35,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",35,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",35,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",35,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",35,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",35,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",35,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",35,[[]]],[11,"eq","","Lane-wise equality comparison.",35,[[],["m8x16",6]]],[11,"ne","","Lane-wise inequality comparison.",35,[[],["m8x16",6]]],[11,"lt","","Lane-wise less-than comparison.",35,[[],["m8x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",35,[[],["m8x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",35,[[],["m8x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",35,[[],["m8x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",35,[[],[["lexicographicallyordered",3],["u8x16",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",35,[[],[["lexicographicallyordered",3],["u8x16",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",35,[[]]],[11,"new","","Creates a new instance with each vector elements…",36,[[]]],[11,"lanes","","Returns the number of vector lanes.",36,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",36,[[]]],[11,"extract","","Extracts the value at `index`.",36,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",36,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",36,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",36,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",36,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",36,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",36,[[]]],[11,"all","","Are `all` vector lanes `true`?",36,[[]]],[11,"any","","Is `any` vector lane `true`?",36,[[]]],[11,"none","","Are `all` vector lanes `false`?",36,[[]]],[11,"eq","","Lane-wise equality comparison.",36,[[],["m8x16",6]]],[11,"ne","","Lane-wise inequality comparison.",36,[[],["m8x16",6]]],[11,"lt","","Lane-wise less-than comparison.",36,[[],["m8x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",36,[[],["m8x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",36,[[],["m8x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",36,[[],["m8x16",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",36,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",36,[[],[["lexicographicallyordered",3],["m8x16",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",36,[[],[["lexicographicallyordered",3],["m8x16",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",36,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",36,[[]]],[11,"new","","Creates a new instance with each vector elements…",37,[[]]],[11,"lanes","","Returns the number of vector lanes.",37,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",37,[[]]],[11,"extract","","Extracts the value at `index`.",37,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",37,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",37,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",37,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",37,[[["i16x8",6]],["i16x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",37,[[["i16x8",6]],["i16x8",6]]],[11,"min","","Minimum of two vectors.",37,[[]]],[11,"max","","Maximum of two vectors.",37,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",37,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",37,[[]]],[11,"max_element","","Largest vector element value.",37,[[]]],[11,"min_element","","Smallest vector element value.",37,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",37,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",37,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",37,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",37,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",37,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",37,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",37,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",37,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",37,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",37,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",37,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",37,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",37,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",37,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",37,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",37,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",37,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",37,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",37,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",37,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",37,[[]]],[11,"eq","","Lane-wise equality comparison.",37,[[],["m16x8",6]]],[11,"ne","","Lane-wise inequality comparison.",37,[[],["m16x8",6]]],[11,"lt","","Lane-wise less-than comparison.",37,[[],["m16x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",37,[[],["m16x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",37,[[],["m16x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",37,[[],["m16x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",37,[[],[["i16x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",37,[[],[["i16x8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",37,[[]]],[11,"new","","Creates a new instance with each vector elements…",38,[[]]],[11,"lanes","","Returns the number of vector lanes.",38,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",38,[[]]],[11,"extract","","Extracts the value at `index`.",38,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",38,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",38,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",38,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",38,[[["u16x8",6]],["u16x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",38,[[["u16x8",6]],["u16x8",6]]],[11,"min","","Minimum of two vectors.",38,[[]]],[11,"max","","Maximum of two vectors.",38,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",38,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",38,[[]]],[11,"max_element","","Largest vector element value.",38,[[]]],[11,"min_element","","Smallest vector element value.",38,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",38,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",38,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",38,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",38,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",38,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",38,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",38,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",38,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",38,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",38,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",38,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",38,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",38,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",38,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",38,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",38,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",38,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",38,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",38,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",38,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",38,[[]]],[11,"eq","","Lane-wise equality comparison.",38,[[],["m16x8",6]]],[11,"ne","","Lane-wise inequality comparison.",38,[[],["m16x8",6]]],[11,"lt","","Lane-wise less-than comparison.",38,[[],["m16x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",38,[[],["m16x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",38,[[],["m16x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",38,[[],["m16x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",38,[[],[["lexicographicallyordered",3],["u16x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",38,[[],[["lexicographicallyordered",3],["u16x8",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",38,[[]]],[11,"new","","Creates a new instance with each vector elements…",39,[[]]],[11,"lanes","","Returns the number of vector lanes.",39,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",39,[[]]],[11,"extract","","Extracts the value at `index`.",39,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",39,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",39,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",39,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",39,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",39,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",39,[[]]],[11,"all","","Are `all` vector lanes `true`?",39,[[]]],[11,"any","","Is `any` vector lane `true`?",39,[[]]],[11,"none","","Are `all` vector lanes `false`?",39,[[]]],[11,"eq","","Lane-wise equality comparison.",39,[[],["m16x8",6]]],[11,"ne","","Lane-wise inequality comparison.",39,[[],["m16x8",6]]],[11,"lt","","Lane-wise less-than comparison.",39,[[],["m16x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",39,[[],["m16x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",39,[[],["m16x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",39,[[],["m16x8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",39,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",39,[[],[["lexicographicallyordered",3],["m16x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",39,[[],[["lexicographicallyordered",3],["m16x8",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",39,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",39,[[]]],[11,"new","","Creates a new instance with each vector elements…",40,[[]]],[11,"lanes","","Returns the number of vector lanes.",40,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",40,[[]]],[11,"extract","","Extracts the value at `index`.",40,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",40,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",40,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",40,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",40,[[["i32x4",6]],["i32x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",40,[[["i32x4",6]],["i32x4",6]]],[11,"min","","Minimum of two vectors.",40,[[]]],[11,"max","","Maximum of two vectors.",40,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",40,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",40,[[]]],[11,"max_element","","Largest vector element value.",40,[[]]],[11,"min_element","","Smallest vector element value.",40,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",40,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",40,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",40,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",40,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",40,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",40,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",40,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",40,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",40,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",40,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",40,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",40,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",40,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",40,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",40,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",40,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",40,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",40,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",40,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",40,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",40,[[]]],[11,"eq","","Lane-wise equality comparison.",40,[[],["m32x4",6]]],[11,"ne","","Lane-wise inequality comparison.",40,[[],["m32x4",6]]],[11,"lt","","Lane-wise less-than comparison.",40,[[],["m32x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",40,[[],["m32x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",40,[[],["m32x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",40,[[],["m32x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",40,[[],[["lexicographicallyordered",3],["i32x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",40,[[],[["lexicographicallyordered",3],["i32x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",40,[[]]],[11,"new","","Creates a new instance with each vector elements…",41,[[]]],[11,"lanes","","Returns the number of vector lanes.",41,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",41,[[]]],[11,"extract","","Extracts the value at `index`.",41,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",41,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",41,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",41,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",41,[[["u32x4",6]],["u32x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",41,[[["u32x4",6]],["u32x4",6]]],[11,"min","","Minimum of two vectors.",41,[[]]],[11,"max","","Maximum of two vectors.",41,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",41,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",41,[[]]],[11,"max_element","","Largest vector element value.",41,[[]]],[11,"min_element","","Smallest vector element value.",41,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",41,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",41,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",41,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",41,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",41,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",41,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",41,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",41,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",41,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",41,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",41,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",41,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",41,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",41,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",41,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",41,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",41,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",41,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",41,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",41,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",41,[[]]],[11,"eq","","Lane-wise equality comparison.",41,[[],["m32x4",6]]],[11,"ne","","Lane-wise inequality comparison.",41,[[],["m32x4",6]]],[11,"lt","","Lane-wise less-than comparison.",41,[[],["m32x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",41,[[],["m32x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",41,[[],["m32x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",41,[[],["m32x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",41,[[],[["u32x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",41,[[],[["u32x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",41,[[]]],[11,"new","","Creates a new instance with each vector elements…",42,[[]]],[11,"lanes","","Returns the number of vector lanes.",42,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",42,[[]]],[11,"extract","","Extracts the value at `index`.",42,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",42,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",42,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",42,[[]]],[11,"min","","Minimum of two vectors.",42,[[]]],[11,"max","","Maximum of two vectors.",42,[[]]],[11,"sum","","Horizontal sum of the vector elements.",42,[[]]],[11,"product","","Horizontal product of the vector elements.",42,[[]]],[11,"max_element","","Largest vector element value.",42,[[]]],[11,"min_element","","Smallest vector element value.",42,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",42,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",42,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",42,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",42,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",42,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",42,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",42,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",42,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",42,[[]]],[18,"EPSILON","","Machine epsilon value.",42,null],[18,"MIN","","Smallest finite value.",42,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",42,null],[18,"MAX","","Largest finite value.",42,null],[18,"NAN","","Not a Number (NaN).",42,null],[18,"INFINITY","","Infinity (∞).",42,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",42,null],[18,"PI","","Archimedes\' constant (π)",42,null],[18,"FRAC_PI_2","","π/2",42,null],[18,"FRAC_PI_3","","π/3",42,null],[18,"FRAC_PI_4","","π/4",42,null],[18,"FRAC_PI_6","","π/6",42,null],[18,"FRAC_PI_8","","π/8",42,null],[18,"FRAC_1_PI","","1/π",42,null],[18,"FRAC_2_PI","","2/π",42,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",42,null],[18,"SQRT_2","","sqrt(2)",42,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",42,null],[18,"E","","Euler\'s number (e)",42,null],[18,"LOG2_E","","log2(e)",42,null],[18,"LOG10_E","","log10(e)",42,null],[18,"LN_2","","ln(2)",42,null],[18,"LN_10","","ln(10)",42,null],[11,"is_nan","","",42,[[],["m32x4",6]]],[11,"is_infinite","","",42,[[],["m32x4",6]]],[11,"is_finite","","",42,[[],["m32x4",6]]],[11,"abs","","Absolute value.",42,[[]]],[11,"cos","","Cosine.",42,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",42,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",42,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",42,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",42,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",42,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",42,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",42,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",42,[[]]],[11,"sin","","Sine.",42,[[]]],[11,"sin_pi","","Sine of `self * PI`.",42,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",42,[[]]],[11,"sqrt","","",42,[[]]],[11,"sqrte","","Square-root estimate.",42,[[]]],[11,"tanh","","Tanh.",42,[[]]],[11,"eq","","Lane-wise equality comparison.",42,[[],["m32x4",6]]],[11,"ne","","Lane-wise inequality comparison.",42,[[],["m32x4",6]]],[11,"lt","","Lane-wise less-than comparison.",42,[[],["m32x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",42,[[],["m32x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",42,[[],["m32x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",42,[[],["m32x4",6]]],[11,"new","","Creates a new instance with each vector elements…",43,[[]]],[11,"lanes","","Returns the number of vector lanes.",43,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",43,[[]]],[11,"extract","","Extracts the value at `index`.",43,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",43,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",43,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",43,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",43,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",43,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",43,[[]]],[11,"all","","Are `all` vector lanes `true`?",43,[[]]],[11,"any","","Is `any` vector lane `true`?",43,[[]]],[11,"none","","Are `all` vector lanes `false`?",43,[[]]],[11,"eq","","Lane-wise equality comparison.",43,[[],["m32x4",6]]],[11,"ne","","Lane-wise inequality comparison.",43,[[],["m32x4",6]]],[11,"lt","","Lane-wise less-than comparison.",43,[[],["m32x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",43,[[],["m32x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",43,[[],["m32x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",43,[[],["m32x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",43,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",43,[[],[["lexicographicallyordered",3],["m32x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",43,[[],[["lexicographicallyordered",3],["m32x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",43,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",43,[[]]],[11,"new","","Creates a new instance with each vector elements…",44,[[]]],[11,"lanes","","Returns the number of vector lanes.",44,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",44,[[]]],[11,"extract","","Extracts the value at `index`.",44,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",44,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",44,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",44,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",44,[[["i64x2",6]],["i64x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",44,[[["i64x2",6]],["i64x2",6]]],[11,"min","","Minimum of two vectors.",44,[[]]],[11,"max","","Maximum of two vectors.",44,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",44,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",44,[[]]],[11,"max_element","","Largest vector element value.",44,[[]]],[11,"min_element","","Smallest vector element value.",44,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",44,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",44,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",44,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",44,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",44,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",44,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",44,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",44,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",44,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",44,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",44,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",44,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",44,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",44,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",44,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",44,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",44,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",44,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",44,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",44,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",44,[[]]],[11,"eq","","Lane-wise equality comparison.",44,[[],["m64x2",6]]],[11,"ne","","Lane-wise inequality comparison.",44,[[],["m64x2",6]]],[11,"lt","","Lane-wise less-than comparison.",44,[[],["m64x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",44,[[],["m64x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",44,[[],["m64x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",44,[[],["m64x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",44,[[],[["lexicographicallyordered",3],["i64x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",44,[[],[["lexicographicallyordered",3],["i64x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",44,[[]]],[11,"new","","Creates a new instance with each vector elements…",45,[[]]],[11,"lanes","","Returns the number of vector lanes.",45,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",45,[[]]],[11,"extract","","Extracts the value at `index`.",45,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",45,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",45,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",45,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",45,[[["u64x2",6]],["u64x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",45,[[["u64x2",6]],["u64x2",6]]],[11,"min","","Minimum of two vectors.",45,[[]]],[11,"max","","Maximum of two vectors.",45,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",45,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",45,[[]]],[11,"max_element","","Largest vector element value.",45,[[]]],[11,"min_element","","Smallest vector element value.",45,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",45,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",45,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",45,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",45,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",45,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",45,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",45,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",45,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",45,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",45,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",45,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",45,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",45,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",45,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",45,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",45,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",45,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",45,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",45,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",45,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",45,[[]]],[11,"eq","","Lane-wise equality comparison.",45,[[],["m64x2",6]]],[11,"ne","","Lane-wise inequality comparison.",45,[[],["m64x2",6]]],[11,"lt","","Lane-wise less-than comparison.",45,[[],["m64x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",45,[[],["m64x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",45,[[],["m64x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",45,[[],["m64x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",45,[[],[["u64x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",45,[[],[["u64x2",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",45,[[]]],[11,"new","","Creates a new instance with each vector elements…",46,[[]]],[11,"lanes","","Returns the number of vector lanes.",46,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",46,[[]]],[11,"extract","","Extracts the value at `index`.",46,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",46,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",46,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",46,[[]]],[11,"min","","Minimum of two vectors.",46,[[]]],[11,"max","","Maximum of two vectors.",46,[[]]],[11,"sum","","Horizontal sum of the vector elements.",46,[[]]],[11,"product","","Horizontal product of the vector elements.",46,[[]]],[11,"max_element","","Largest vector element value.",46,[[]]],[11,"min_element","","Smallest vector element value.",46,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",46,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",46,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",46,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",46,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",46,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",46,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",46,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",46,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",46,[[]]],[18,"EPSILON","","Machine epsilon value.",46,null],[18,"MIN","","Smallest finite value.",46,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",46,null],[18,"MAX","","Largest finite value.",46,null],[18,"NAN","","Not a Number (NaN).",46,null],[18,"INFINITY","","Infinity (∞).",46,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",46,null],[18,"PI","","Archimedes\' constant (π)",46,null],[18,"FRAC_PI_2","","π/2",46,null],[18,"FRAC_PI_3","","π/3",46,null],[18,"FRAC_PI_4","","π/4",46,null],[18,"FRAC_PI_6","","π/6",46,null],[18,"FRAC_PI_8","","π/8",46,null],[18,"FRAC_1_PI","","1/π",46,null],[18,"FRAC_2_PI","","2/π",46,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",46,null],[18,"SQRT_2","","sqrt(2)",46,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",46,null],[18,"E","","Euler\'s number (e)",46,null],[18,"LOG2_E","","log2(e)",46,null],[18,"LOG10_E","","log10(e)",46,null],[18,"LN_2","","ln(2)",46,null],[18,"LN_10","","ln(10)",46,null],[11,"is_nan","","",46,[[],["m64x2",6]]],[11,"is_infinite","","",46,[[],["m64x2",6]]],[11,"is_finite","","",46,[[],["m64x2",6]]],[11,"abs","","Absolute value.",46,[[]]],[11,"cos","","Cosine.",46,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",46,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",46,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",46,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",46,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",46,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",46,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",46,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",46,[[]]],[11,"sin","","Sine.",46,[[]]],[11,"sin_pi","","Sine of `self * PI`.",46,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",46,[[]]],[11,"sqrt","","",46,[[]]],[11,"sqrte","","Square-root estimate.",46,[[]]],[11,"tanh","","Tanh.",46,[[]]],[11,"eq","","Lane-wise equality comparison.",46,[[],["m64x2",6]]],[11,"ne","","Lane-wise inequality comparison.",46,[[],["m64x2",6]]],[11,"lt","","Lane-wise less-than comparison.",46,[[],["m64x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",46,[[],["m64x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",46,[[],["m64x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",46,[[],["m64x2",6]]],[11,"new","","Creates a new instance with each vector elements…",47,[[]]],[11,"lanes","","Returns the number of vector lanes.",47,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",47,[[]]],[11,"extract","","Extracts the value at `index`.",47,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",47,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",47,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",47,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",47,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",47,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",47,[[]]],[11,"all","","Are `all` vector lanes `true`?",47,[[]]],[11,"any","","Is `any` vector lane `true`?",47,[[]]],[11,"none","","Are `all` vector lanes `false`?",47,[[]]],[11,"eq","","Lane-wise equality comparison.",47,[[],["m64x2",6]]],[11,"ne","","Lane-wise inequality comparison.",47,[[],["m64x2",6]]],[11,"lt","","Lane-wise less-than comparison.",47,[[],["m64x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",47,[[],["m64x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",47,[[],["m64x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",47,[[],["m64x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",47,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",47,[[],[["m64x2",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",47,[[],[["m64x2",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",47,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",47,[[]]],[11,"new","","Creates a new instance with each vector elements…",51,[[]]],[11,"lanes","","Returns the number of vector lanes.",51,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",51,[[]]],[11,"extract","","Extracts the value at `index`.",51,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",51,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",51,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",51,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",51,[[["i128x1",6]],["i128x1",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",51,[[["i128x1",6]],["i128x1",6]]],[11,"min","","Minimum of two vectors.",51,[[]]],[11,"max","","Maximum of two vectors.",51,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",51,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",51,[[]]],[11,"max_element","","Largest vector element value.",51,[[]]],[11,"min_element","","Smallest vector element value.",51,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",51,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",51,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",51,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",51,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",51,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",51,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",51,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",51,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",51,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",51,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",51,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",51,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",51,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",51,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",51,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",51,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",51,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",51,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",51,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",51,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",51,[[]]],[11,"eq","","Lane-wise equality comparison.",51,[[],["m128x1",6]]],[11,"ne","","Lane-wise inequality comparison.",51,[[],["m128x1",6]]],[11,"lt","","Lane-wise less-than comparison.",51,[[],["m128x1",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",51,[[],["m128x1",6]]],[11,"gt","","Lane-wise greater-than comparison.",51,[[],["m128x1",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",51,[[],["m128x1",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",51,[[],[["i128x1",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",51,[[],[["i128x1",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",51,[[]]],[11,"new","","Creates a new instance with each vector elements…",52,[[]]],[11,"lanes","","Returns the number of vector lanes.",52,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",52,[[]]],[11,"extract","","Extracts the value at `index`.",52,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",52,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",52,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",52,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",52,[[["u128x1",6]],["u128x1",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",52,[[["u128x1",6]],["u128x1",6]]],[11,"min","","Minimum of two vectors.",52,[[]]],[11,"max","","Maximum of two vectors.",52,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",52,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",52,[[]]],[11,"max_element","","Largest vector element value.",52,[[]]],[11,"min_element","","Smallest vector element value.",52,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",52,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",52,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",52,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",52,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",52,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",52,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",52,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",52,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",52,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",52,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",52,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",52,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",52,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",52,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",52,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",52,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",52,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",52,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",52,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",52,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",52,[[]]],[11,"eq","","Lane-wise equality comparison.",52,[[],["m128x1",6]]],[11,"ne","","Lane-wise inequality comparison.",52,[[],["m128x1",6]]],[11,"lt","","Lane-wise less-than comparison.",52,[[],["m128x1",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",52,[[],["m128x1",6]]],[11,"gt","","Lane-wise greater-than comparison.",52,[[],["m128x1",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",52,[[],["m128x1",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",52,[[],[["lexicographicallyordered",3],["u128x1",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",52,[[],[["lexicographicallyordered",3],["u128x1",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",52,[[]]],[11,"new","","Creates a new instance with each vector elements…",53,[[]]],[11,"lanes","","Returns the number of vector lanes.",53,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",53,[[]]],[11,"extract","","Extracts the value at `index`.",53,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",53,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",53,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",53,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",53,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",53,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",53,[[]]],[11,"all","","Are `all` vector lanes `true`?",53,[[]]],[11,"any","","Is `any` vector lane `true`?",53,[[]]],[11,"none","","Are `all` vector lanes `false`?",53,[[]]],[11,"eq","","Lane-wise equality comparison.",53,[[],["m128x1",6]]],[11,"ne","","Lane-wise inequality comparison.",53,[[],["m128x1",6]]],[11,"lt","","Lane-wise less-than comparison.",53,[[],["m128x1",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",53,[[],["m128x1",6]]],[11,"gt","","Lane-wise greater-than comparison.",53,[[],["m128x1",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",53,[[],["m128x1",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",53,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",53,[[],[["lexicographicallyordered",3],["m128x1",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",53,[[],[["lexicographicallyordered",3],["m128x1",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",53,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",53,[[]]],[11,"new","","Creates a new instance with each vector elements…",54,[[]]],[11,"lanes","","Returns the number of vector lanes.",54,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",54,[[]]],[11,"extract","","Extracts the value at `index`.",54,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",54,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",54,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",54,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",54,[[["i8x32",6]],["i8x32",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",54,[[["i8x32",6]],["i8x32",6]]],[11,"min","","Minimum of two vectors.",54,[[]]],[11,"max","","Maximum of two vectors.",54,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",54,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",54,[[]]],[11,"max_element","","Largest vector element value.",54,[[]]],[11,"min_element","","Smallest vector element value.",54,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",54,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",54,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",54,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",54,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",54,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",54,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",54,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",54,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",54,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",54,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",54,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",54,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",54,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",54,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",54,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",54,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",54,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",54,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",54,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",54,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",54,[[]]],[11,"eq","","Lane-wise equality comparison.",54,[[],["m8x32",6]]],[11,"ne","","Lane-wise inequality comparison.",54,[[],["m8x32",6]]],[11,"lt","","Lane-wise less-than comparison.",54,[[],["m8x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",54,[[],["m8x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",54,[[],["m8x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",54,[[],["m8x32",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",54,[[],[["i8x32",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",54,[[],[["i8x32",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",54,[[]]],[11,"new","","Creates a new instance with each vector elements…",55,[[]]],[11,"lanes","","Returns the number of vector lanes.",55,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",55,[[]]],[11,"extract","","Extracts the value at `index`.",55,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",55,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",55,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",55,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",55,[[["u8x32",6]],["u8x32",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",55,[[["u8x32",6]],["u8x32",6]]],[11,"min","","Minimum of two vectors.",55,[[]]],[11,"max","","Maximum of two vectors.",55,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",55,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",55,[[]]],[11,"max_element","","Largest vector element value.",55,[[]]],[11,"min_element","","Smallest vector element value.",55,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",55,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",55,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",55,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",55,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",55,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",55,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",55,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",55,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",55,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",55,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",55,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",55,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",55,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",55,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",55,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",55,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",55,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",55,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",55,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",55,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",55,[[]]],[11,"eq","","Lane-wise equality comparison.",55,[[],["m8x32",6]]],[11,"ne","","Lane-wise inequality comparison.",55,[[],["m8x32",6]]],[11,"lt","","Lane-wise less-than comparison.",55,[[],["m8x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",55,[[],["m8x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",55,[[],["m8x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",55,[[],["m8x32",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",55,[[],[["lexicographicallyordered",3],["u8x32",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",55,[[],[["lexicographicallyordered",3],["u8x32",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",55,[[]]],[11,"new","","Creates a new instance with each vector elements…",56,[[]]],[11,"lanes","","Returns the number of vector lanes.",56,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",56,[[]]],[11,"extract","","Extracts the value at `index`.",56,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",56,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",56,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",56,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",56,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",56,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",56,[[]]],[11,"all","","Are `all` vector lanes `true`?",56,[[]]],[11,"any","","Is `any` vector lane `true`?",56,[[]]],[11,"none","","Are `all` vector lanes `false`?",56,[[]]],[11,"eq","","Lane-wise equality comparison.",56,[[],["m8x32",6]]],[11,"ne","","Lane-wise inequality comparison.",56,[[],["m8x32",6]]],[11,"lt","","Lane-wise less-than comparison.",56,[[],["m8x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",56,[[],["m8x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",56,[[],["m8x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",56,[[],["m8x32",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",56,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",56,[[],[["m8x32",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",56,[[],[["m8x32",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",56,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",56,[[]]],[11,"new","","Creates a new instance with each vector elements…",57,[[]]],[11,"lanes","","Returns the number of vector lanes.",57,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",57,[[]]],[11,"extract","","Extracts the value at `index`.",57,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",57,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",57,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",57,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",57,[[["i16x16",6]],["i16x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",57,[[["i16x16",6]],["i16x16",6]]],[11,"min","","Minimum of two vectors.",57,[[]]],[11,"max","","Maximum of two vectors.",57,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",57,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",57,[[]]],[11,"max_element","","Largest vector element value.",57,[[]]],[11,"min_element","","Smallest vector element value.",57,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",57,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",57,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",57,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",57,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",57,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",57,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",57,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",57,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",57,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",57,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",57,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",57,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",57,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",57,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",57,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",57,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",57,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",57,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",57,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",57,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",57,[[]]],[11,"eq","","Lane-wise equality comparison.",57,[[],["m16x16",6]]],[11,"ne","","Lane-wise inequality comparison.",57,[[],["m16x16",6]]],[11,"lt","","Lane-wise less-than comparison.",57,[[],["m16x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",57,[[],["m16x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",57,[[],["m16x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",57,[[],["m16x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",57,[[],[["i16x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",57,[[],[["i16x16",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",57,[[]]],[11,"new","","Creates a new instance with each vector elements…",58,[[]]],[11,"lanes","","Returns the number of vector lanes.",58,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",58,[[]]],[11,"extract","","Extracts the value at `index`.",58,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",58,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",58,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",58,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",58,[[["u16x16",6]],["u16x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",58,[[["u16x16",6]],["u16x16",6]]],[11,"min","","Minimum of two vectors.",58,[[]]],[11,"max","","Maximum of two vectors.",58,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",58,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",58,[[]]],[11,"max_element","","Largest vector element value.",58,[[]]],[11,"min_element","","Smallest vector element value.",58,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",58,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",58,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",58,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",58,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",58,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",58,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",58,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",58,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",58,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",58,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",58,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",58,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",58,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",58,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",58,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",58,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",58,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",58,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",58,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",58,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",58,[[]]],[11,"eq","","Lane-wise equality comparison.",58,[[],["m16x16",6]]],[11,"ne","","Lane-wise inequality comparison.",58,[[],["m16x16",6]]],[11,"lt","","Lane-wise less-than comparison.",58,[[],["m16x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",58,[[],["m16x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",58,[[],["m16x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",58,[[],["m16x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",58,[[],[["u16x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",58,[[],[["u16x16",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",58,[[]]],[11,"new","","Creates a new instance with each vector elements…",59,[[]]],[11,"lanes","","Returns the number of vector lanes.",59,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",59,[[]]],[11,"extract","","Extracts the value at `index`.",59,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",59,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",59,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",59,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",59,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",59,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",59,[[]]],[11,"all","","Are `all` vector lanes `true`?",59,[[]]],[11,"any","","Is `any` vector lane `true`?",59,[[]]],[11,"none","","Are `all` vector lanes `false`?",59,[[]]],[11,"eq","","Lane-wise equality comparison.",59,[[],["m16x16",6]]],[11,"ne","","Lane-wise inequality comparison.",59,[[],["m16x16",6]]],[11,"lt","","Lane-wise less-than comparison.",59,[[],["m16x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",59,[[],["m16x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",59,[[],["m16x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",59,[[],["m16x16",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",59,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",59,[[],[["m16x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",59,[[],[["m16x16",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",59,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",59,[[]]],[11,"new","","Creates a new instance with each vector elements…",60,[[]]],[11,"lanes","","Returns the number of vector lanes.",60,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",60,[[]]],[11,"extract","","Extracts the value at `index`.",60,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",60,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",60,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",60,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",60,[[["i32x8",6]],["i32x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",60,[[["i32x8",6]],["i32x8",6]]],[11,"min","","Minimum of two vectors.",60,[[]]],[11,"max","","Maximum of two vectors.",60,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",60,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",60,[[]]],[11,"max_element","","Largest vector element value.",60,[[]]],[11,"min_element","","Smallest vector element value.",60,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",60,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",60,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",60,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",60,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",60,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",60,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",60,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",60,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",60,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",60,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",60,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",60,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",60,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",60,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",60,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",60,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",60,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",60,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",60,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",60,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",60,[[]]],[11,"eq","","Lane-wise equality comparison.",60,[[],["m32x8",6]]],[11,"ne","","Lane-wise inequality comparison.",60,[[],["m32x8",6]]],[11,"lt","","Lane-wise less-than comparison.",60,[[],["m32x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",60,[[],["m32x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",60,[[],["m32x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",60,[[],["m32x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",60,[[],[["lexicographicallyordered",3],["i32x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",60,[[],[["lexicographicallyordered",3],["i32x8",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",60,[[]]],[11,"new","","Creates a new instance with each vector elements…",61,[[]]],[11,"lanes","","Returns the number of vector lanes.",61,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",61,[[]]],[11,"extract","","Extracts the value at `index`.",61,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",61,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",61,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",61,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",61,[[["u32x8",6]],["u32x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",61,[[["u32x8",6]],["u32x8",6]]],[11,"min","","Minimum of two vectors.",61,[[]]],[11,"max","","Maximum of two vectors.",61,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",61,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",61,[[]]],[11,"max_element","","Largest vector element value.",61,[[]]],[11,"min_element","","Smallest vector element value.",61,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",61,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",61,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",61,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",61,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",61,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",61,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",61,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",61,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",61,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",61,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",61,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",61,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",61,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",61,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",61,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",61,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",61,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",61,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",61,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",61,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",61,[[]]],[11,"eq","","Lane-wise equality comparison.",61,[[],["m32x8",6]]],[11,"ne","","Lane-wise inequality comparison.",61,[[],["m32x8",6]]],[11,"lt","","Lane-wise less-than comparison.",61,[[],["m32x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",61,[[],["m32x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",61,[[],["m32x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",61,[[],["m32x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",61,[[],[["u32x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",61,[[],[["u32x8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",61,[[]]],[11,"new","","Creates a new instance with each vector elements…",62,[[]]],[11,"lanes","","Returns the number of vector lanes.",62,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",62,[[]]],[11,"extract","","Extracts the value at `index`.",62,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",62,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",62,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",62,[[]]],[11,"min","","Minimum of two vectors.",62,[[]]],[11,"max","","Maximum of two vectors.",62,[[]]],[11,"sum","","Horizontal sum of the vector elements.",62,[[]]],[11,"product","","Horizontal product of the vector elements.",62,[[]]],[11,"max_element","","Largest vector element value.",62,[[]]],[11,"min_element","","Smallest vector element value.",62,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",62,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",62,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",62,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",62,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",62,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",62,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",62,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",62,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",62,[[]]],[18,"EPSILON","","Machine epsilon value.",62,null],[18,"MIN","","Smallest finite value.",62,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",62,null],[18,"MAX","","Largest finite value.",62,null],[18,"NAN","","Not a Number (NaN).",62,null],[18,"INFINITY","","Infinity (∞).",62,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",62,null],[18,"PI","","Archimedes\' constant (π)",62,null],[18,"FRAC_PI_2","","π/2",62,null],[18,"FRAC_PI_3","","π/3",62,null],[18,"FRAC_PI_4","","π/4",62,null],[18,"FRAC_PI_6","","π/6",62,null],[18,"FRAC_PI_8","","π/8",62,null],[18,"FRAC_1_PI","","1/π",62,null],[18,"FRAC_2_PI","","2/π",62,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",62,null],[18,"SQRT_2","","sqrt(2)",62,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",62,null],[18,"E","","Euler\'s number (e)",62,null],[18,"LOG2_E","","log2(e)",62,null],[18,"LOG10_E","","log10(e)",62,null],[18,"LN_2","","ln(2)",62,null],[18,"LN_10","","ln(10)",62,null],[11,"is_nan","","",62,[[],["m32x8",6]]],[11,"is_infinite","","",62,[[],["m32x8",6]]],[11,"is_finite","","",62,[[],["m32x8",6]]],[11,"abs","","Absolute value.",62,[[]]],[11,"cos","","Cosine.",62,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",62,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",62,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",62,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",62,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",62,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",62,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",62,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",62,[[]]],[11,"sin","","Sine.",62,[[]]],[11,"sin_pi","","Sine of `self * PI`.",62,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",62,[[]]],[11,"sqrt","","",62,[[]]],[11,"sqrte","","Square-root estimate.",62,[[]]],[11,"tanh","","Tanh.",62,[[]]],[11,"eq","","Lane-wise equality comparison.",62,[[],["m32x8",6]]],[11,"ne","","Lane-wise inequality comparison.",62,[[],["m32x8",6]]],[11,"lt","","Lane-wise less-than comparison.",62,[[],["m32x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",62,[[],["m32x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",62,[[],["m32x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",62,[[],["m32x8",6]]],[11,"new","","Creates a new instance with each vector elements…",63,[[]]],[11,"lanes","","Returns the number of vector lanes.",63,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",63,[[]]],[11,"extract","","Extracts the value at `index`.",63,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",63,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",63,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",63,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",63,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",63,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",63,[[]]],[11,"all","","Are `all` vector lanes `true`?",63,[[]]],[11,"any","","Is `any` vector lane `true`?",63,[[]]],[11,"none","","Are `all` vector lanes `false`?",63,[[]]],[11,"eq","","Lane-wise equality comparison.",63,[[],["m32x8",6]]],[11,"ne","","Lane-wise inequality comparison.",63,[[],["m32x8",6]]],[11,"lt","","Lane-wise less-than comparison.",63,[[],["m32x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",63,[[],["m32x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",63,[[],["m32x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",63,[[],["m32x8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",63,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",63,[[],[["m32x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",63,[[],[["m32x8",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",63,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",63,[[]]],[11,"new","","Creates a new instance with each vector elements…",64,[[]]],[11,"lanes","","Returns the number of vector lanes.",64,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",64,[[]]],[11,"extract","","Extracts the value at `index`.",64,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",64,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",64,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",64,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",64,[[["i64x4",6]],["i64x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",64,[[["i64x4",6]],["i64x4",6]]],[11,"min","","Minimum of two vectors.",64,[[]]],[11,"max","","Maximum of two vectors.",64,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",64,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",64,[[]]],[11,"max_element","","Largest vector element value.",64,[[]]],[11,"min_element","","Smallest vector element value.",64,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",64,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",64,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",64,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",64,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",64,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",64,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",64,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",64,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",64,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",64,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",64,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",64,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",64,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",64,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",64,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",64,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",64,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",64,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",64,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",64,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",64,[[]]],[11,"eq","","Lane-wise equality comparison.",64,[[],["m64x4",6]]],[11,"ne","","Lane-wise inequality comparison.",64,[[],["m64x4",6]]],[11,"lt","","Lane-wise less-than comparison.",64,[[],["m64x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",64,[[],["m64x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",64,[[],["m64x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",64,[[],["m64x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",64,[[],[["i64x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",64,[[],[["i64x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",64,[[]]],[11,"new","","Creates a new instance with each vector elements…",65,[[]]],[11,"lanes","","Returns the number of vector lanes.",65,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",65,[[]]],[11,"extract","","Extracts the value at `index`.",65,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",65,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",65,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",65,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",65,[[["u64x4",6]],["u64x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",65,[[["u64x4",6]],["u64x4",6]]],[11,"min","","Minimum of two vectors.",65,[[]]],[11,"max","","Maximum of two vectors.",65,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",65,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",65,[[]]],[11,"max_element","","Largest vector element value.",65,[[]]],[11,"min_element","","Smallest vector element value.",65,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",65,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",65,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",65,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",65,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",65,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",65,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",65,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",65,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",65,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",65,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",65,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",65,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",65,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",65,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",65,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",65,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",65,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",65,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",65,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",65,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",65,[[]]],[11,"eq","","Lane-wise equality comparison.",65,[[],["m64x4",6]]],[11,"ne","","Lane-wise inequality comparison.",65,[[],["m64x4",6]]],[11,"lt","","Lane-wise less-than comparison.",65,[[],["m64x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",65,[[],["m64x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",65,[[],["m64x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",65,[[],["m64x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",65,[[],[["lexicographicallyordered",3],["u64x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",65,[[],[["lexicographicallyordered",3],["u64x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",65,[[]]],[11,"new","","Creates a new instance with each vector elements…",66,[[]]],[11,"lanes","","Returns the number of vector lanes.",66,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",66,[[]]],[11,"extract","","Extracts the value at `index`.",66,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",66,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",66,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",66,[[]]],[11,"min","","Minimum of two vectors.",66,[[]]],[11,"max","","Maximum of two vectors.",66,[[]]],[11,"sum","","Horizontal sum of the vector elements.",66,[[]]],[11,"product","","Horizontal product of the vector elements.",66,[[]]],[11,"max_element","","Largest vector element value.",66,[[]]],[11,"min_element","","Smallest vector element value.",66,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",66,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",66,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",66,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",66,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",66,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",66,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",66,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",66,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",66,[[]]],[18,"EPSILON","","Machine epsilon value.",66,null],[18,"MIN","","Smallest finite value.",66,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",66,null],[18,"MAX","","Largest finite value.",66,null],[18,"NAN","","Not a Number (NaN).",66,null],[18,"INFINITY","","Infinity (∞).",66,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",66,null],[18,"PI","","Archimedes\' constant (π)",66,null],[18,"FRAC_PI_2","","π/2",66,null],[18,"FRAC_PI_3","","π/3",66,null],[18,"FRAC_PI_4","","π/4",66,null],[18,"FRAC_PI_6","","π/6",66,null],[18,"FRAC_PI_8","","π/8",66,null],[18,"FRAC_1_PI","","1/π",66,null],[18,"FRAC_2_PI","","2/π",66,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",66,null],[18,"SQRT_2","","sqrt(2)",66,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",66,null],[18,"E","","Euler\'s number (e)",66,null],[18,"LOG2_E","","log2(e)",66,null],[18,"LOG10_E","","log10(e)",66,null],[18,"LN_2","","ln(2)",66,null],[18,"LN_10","","ln(10)",66,null],[11,"is_nan","","",66,[[],["m64x4",6]]],[11,"is_infinite","","",66,[[],["m64x4",6]]],[11,"is_finite","","",66,[[],["m64x4",6]]],[11,"abs","","Absolute value.",66,[[]]],[11,"cos","","Cosine.",66,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",66,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",66,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",66,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",66,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",66,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",66,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",66,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",66,[[]]],[11,"sin","","Sine.",66,[[]]],[11,"sin_pi","","Sine of `self * PI`.",66,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",66,[[]]],[11,"sqrt","","",66,[[]]],[11,"sqrte","","Square-root estimate.",66,[[]]],[11,"tanh","","Tanh.",66,[[]]],[11,"eq","","Lane-wise equality comparison.",66,[[],["m64x4",6]]],[11,"ne","","Lane-wise inequality comparison.",66,[[],["m64x4",6]]],[11,"lt","","Lane-wise less-than comparison.",66,[[],["m64x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",66,[[],["m64x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",66,[[],["m64x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",66,[[],["m64x4",6]]],[11,"new","","Creates a new instance with each vector elements…",67,[[]]],[11,"lanes","","Returns the number of vector lanes.",67,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",67,[[]]],[11,"extract","","Extracts the value at `index`.",67,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",67,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",67,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",67,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",67,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",67,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",67,[[]]],[11,"all","","Are `all` vector lanes `true`?",67,[[]]],[11,"any","","Is `any` vector lane `true`?",67,[[]]],[11,"none","","Are `all` vector lanes `false`?",67,[[]]],[11,"eq","","Lane-wise equality comparison.",67,[[],["m64x4",6]]],[11,"ne","","Lane-wise inequality comparison.",67,[[],["m64x4",6]]],[11,"lt","","Lane-wise less-than comparison.",67,[[],["m64x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",67,[[],["m64x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",67,[[],["m64x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",67,[[],["m64x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",67,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",67,[[],[["lexicographicallyordered",3],["m64x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",67,[[],[["lexicographicallyordered",3],["m64x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",67,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",67,[[]]],[11,"new","","Creates a new instance with each vector elements…",68,[[]]],[11,"lanes","","Returns the number of vector lanes.",68,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",68,[[]]],[11,"extract","","Extracts the value at `index`.",68,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",68,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",68,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",68,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",68,[[["i128x2",6]],["i128x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",68,[[["i128x2",6]],["i128x2",6]]],[11,"min","","Minimum of two vectors.",68,[[]]],[11,"max","","Maximum of two vectors.",68,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",68,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",68,[[]]],[11,"max_element","","Largest vector element value.",68,[[]]],[11,"min_element","","Smallest vector element value.",68,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",68,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",68,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",68,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",68,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",68,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",68,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",68,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",68,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",68,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",68,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",68,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",68,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",68,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",68,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",68,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",68,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",68,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",68,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",68,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",68,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",68,[[]]],[11,"eq","","Lane-wise equality comparison.",68,[[],["m128x2",6]]],[11,"ne","","Lane-wise inequality comparison.",68,[[],["m128x2",6]]],[11,"lt","","Lane-wise less-than comparison.",68,[[],["m128x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",68,[[],["m128x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",68,[[],["m128x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",68,[[],["m128x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",68,[[],[["lexicographicallyordered",3],["i128x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",68,[[],[["lexicographicallyordered",3],["i128x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",68,[[]]],[11,"new","","Creates a new instance with each vector elements…",69,[[]]],[11,"lanes","","Returns the number of vector lanes.",69,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",69,[[]]],[11,"extract","","Extracts the value at `index`.",69,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",69,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",69,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",69,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",69,[[["u128x2",6]],["u128x2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",69,[[["u128x2",6]],["u128x2",6]]],[11,"min","","Minimum of two vectors.",69,[[]]],[11,"max","","Maximum of two vectors.",69,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",69,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",69,[[]]],[11,"max_element","","Largest vector element value.",69,[[]]],[11,"min_element","","Smallest vector element value.",69,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",69,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",69,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",69,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",69,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",69,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",69,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",69,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",69,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",69,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",69,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",69,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",69,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",69,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",69,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",69,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",69,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",69,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",69,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",69,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",69,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",69,[[]]],[11,"eq","","Lane-wise equality comparison.",69,[[],["m128x2",6]]],[11,"ne","","Lane-wise inequality comparison.",69,[[],["m128x2",6]]],[11,"lt","","Lane-wise less-than comparison.",69,[[],["m128x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",69,[[],["m128x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",69,[[],["m128x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",69,[[],["m128x2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",69,[[],[["lexicographicallyordered",3],["u128x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",69,[[],[["lexicographicallyordered",3],["u128x2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",69,[[]]],[11,"new","","Creates a new instance with each vector elements…",70,[[]]],[11,"lanes","","Returns the number of vector lanes.",70,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",70,[[]]],[11,"extract","","Extracts the value at `index`.",70,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",70,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",70,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",70,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",70,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",70,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",70,[[]]],[11,"all","","Are `all` vector lanes `true`?",70,[[]]],[11,"any","","Is `any` vector lane `true`?",70,[[]]],[11,"none","","Are `all` vector lanes `false`?",70,[[]]],[11,"eq","","Lane-wise equality comparison.",70,[[],["m128x2",6]]],[11,"ne","","Lane-wise inequality comparison.",70,[[],["m128x2",6]]],[11,"lt","","Lane-wise less-than comparison.",70,[[],["m128x2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",70,[[],["m128x2",6]]],[11,"gt","","Lane-wise greater-than comparison.",70,[[],["m128x2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",70,[[],["m128x2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",70,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",70,[[],[["lexicographicallyordered",3],["m128x2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",70,[[],[["lexicographicallyordered",3],["m128x2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",70,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",70,[[]]],[11,"new","","Creates a new instance with each vector elements…",74,[[]]],[11,"lanes","","Returns the number of vector lanes.",74,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",74,[[]]],[11,"extract","","Extracts the value at `index`.",74,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",74,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",74,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",74,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",74,[[["i8x64",6]],["i8x64",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",74,[[["i8x64",6]],["i8x64",6]]],[11,"min","","Minimum of two vectors.",74,[[]]],[11,"max","","Maximum of two vectors.",74,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",74,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",74,[[]]],[11,"max_element","","Largest vector element value.",74,[[]]],[11,"min_element","","Smallest vector element value.",74,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",74,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",74,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",74,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",74,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",74,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",74,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",74,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",74,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",74,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",74,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",74,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",74,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",74,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",74,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",74,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",74,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",74,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",74,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",74,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",74,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",74,[[]]],[11,"eq","","Lane-wise equality comparison.",74,[[],["m8x64",6]]],[11,"ne","","Lane-wise inequality comparison.",74,[[],["m8x64",6]]],[11,"lt","","Lane-wise less-than comparison.",74,[[],["m8x64",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",74,[[],["m8x64",6]]],[11,"gt","","Lane-wise greater-than comparison.",74,[[],["m8x64",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",74,[[],["m8x64",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",74,[[],[["i8x64",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",74,[[],[["i8x64",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",74,[[]]],[11,"new","","Creates a new instance with each vector elements…",75,[[]]],[11,"lanes","","Returns the number of vector lanes.",75,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",75,[[]]],[11,"extract","","Extracts the value at `index`.",75,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",75,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",75,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",75,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",75,[[["u8x64",6]],["u8x64",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",75,[[["u8x64",6]],["u8x64",6]]],[11,"min","","Minimum of two vectors.",75,[[]]],[11,"max","","Maximum of two vectors.",75,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",75,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",75,[[]]],[11,"max_element","","Largest vector element value.",75,[[]]],[11,"min_element","","Smallest vector element value.",75,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",75,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",75,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",75,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",75,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",75,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",75,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",75,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",75,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",75,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",75,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",75,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",75,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",75,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",75,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",75,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",75,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",75,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",75,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",75,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",75,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",75,[[]]],[11,"eq","","Lane-wise equality comparison.",75,[[],["m8x64",6]]],[11,"ne","","Lane-wise inequality comparison.",75,[[],["m8x64",6]]],[11,"lt","","Lane-wise less-than comparison.",75,[[],["m8x64",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",75,[[],["m8x64",6]]],[11,"gt","","Lane-wise greater-than comparison.",75,[[],["m8x64",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",75,[[],["m8x64",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",75,[[],[["lexicographicallyordered",3],["u8x64",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",75,[[],[["lexicographicallyordered",3],["u8x64",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",75,[[]]],[11,"new","","Creates a new instance with each vector elements…",76,[[]]],[11,"lanes","","Returns the number of vector lanes.",76,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",76,[[]]],[11,"extract","","Extracts the value at `index`.",76,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",76,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",76,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",76,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",76,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",76,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",76,[[]]],[11,"all","","Are `all` vector lanes `true`?",76,[[]]],[11,"any","","Is `any` vector lane `true`?",76,[[]]],[11,"none","","Are `all` vector lanes `false`?",76,[[]]],[11,"eq","","Lane-wise equality comparison.",76,[[],["m8x64",6]]],[11,"ne","","Lane-wise inequality comparison.",76,[[],["m8x64",6]]],[11,"lt","","Lane-wise less-than comparison.",76,[[],["m8x64",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",76,[[],["m8x64",6]]],[11,"gt","","Lane-wise greater-than comparison.",76,[[],["m8x64",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",76,[[],["m8x64",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",76,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",76,[[],[["m8x64",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",76,[[],[["m8x64",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",76,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",76,[[]]],[11,"new","","Creates a new instance with each vector elements…",77,[[]]],[11,"lanes","","Returns the number of vector lanes.",77,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",77,[[]]],[11,"extract","","Extracts the value at `index`.",77,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",77,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",77,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",77,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",77,[[["i16x32",6]],["i16x32",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",77,[[["i16x32",6]],["i16x32",6]]],[11,"min","","Minimum of two vectors.",77,[[]]],[11,"max","","Maximum of two vectors.",77,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",77,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",77,[[]]],[11,"max_element","","Largest vector element value.",77,[[]]],[11,"min_element","","Smallest vector element value.",77,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",77,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",77,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",77,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",77,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",77,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",77,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",77,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",77,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",77,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",77,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",77,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",77,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",77,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",77,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",77,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",77,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",77,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",77,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",77,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",77,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",77,[[]]],[11,"eq","","Lane-wise equality comparison.",77,[[],["m16x32",6]]],[11,"ne","","Lane-wise inequality comparison.",77,[[],["m16x32",6]]],[11,"lt","","Lane-wise less-than comparison.",77,[[],["m16x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",77,[[],["m16x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",77,[[],["m16x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",77,[[],["m16x32",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",77,[[],[["i16x32",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",77,[[],[["i16x32",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",77,[[]]],[11,"new","","Creates a new instance with each vector elements…",78,[[]]],[11,"lanes","","Returns the number of vector lanes.",78,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",78,[[]]],[11,"extract","","Extracts the value at `index`.",78,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",78,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",78,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",78,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",78,[[["u16x32",6]],["u16x32",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",78,[[["u16x32",6]],["u16x32",6]]],[11,"min","","Minimum of two vectors.",78,[[]]],[11,"max","","Maximum of two vectors.",78,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",78,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",78,[[]]],[11,"max_element","","Largest vector element value.",78,[[]]],[11,"min_element","","Smallest vector element value.",78,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",78,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",78,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",78,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",78,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",78,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",78,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",78,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",78,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",78,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",78,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",78,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",78,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",78,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",78,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",78,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",78,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",78,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",78,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",78,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",78,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",78,[[]]],[11,"eq","","Lane-wise equality comparison.",78,[[],["m16x32",6]]],[11,"ne","","Lane-wise inequality comparison.",78,[[],["m16x32",6]]],[11,"lt","","Lane-wise less-than comparison.",78,[[],["m16x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",78,[[],["m16x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",78,[[],["m16x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",78,[[],["m16x32",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",78,[[],[["lexicographicallyordered",3],["u16x32",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",78,[[],[["lexicographicallyordered",3],["u16x32",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",78,[[]]],[11,"new","","Creates a new instance with each vector elements…",79,[[]]],[11,"lanes","","Returns the number of vector lanes.",79,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",79,[[]]],[11,"extract","","Extracts the value at `index`.",79,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",79,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",79,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",79,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",79,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",79,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",79,[[]]],[11,"all","","Are `all` vector lanes `true`?",79,[[]]],[11,"any","","Is `any` vector lane `true`?",79,[[]]],[11,"none","","Are `all` vector lanes `false`?",79,[[]]],[11,"eq","","Lane-wise equality comparison.",79,[[],["m16x32",6]]],[11,"ne","","Lane-wise inequality comparison.",79,[[],["m16x32",6]]],[11,"lt","","Lane-wise less-than comparison.",79,[[],["m16x32",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",79,[[],["m16x32",6]]],[11,"gt","","Lane-wise greater-than comparison.",79,[[],["m16x32",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",79,[[],["m16x32",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",79,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",79,[[],[["lexicographicallyordered",3],["m16x32",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",79,[[],[["lexicographicallyordered",3],["m16x32",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",79,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",79,[[]]],[11,"new","","Creates a new instance with each vector elements…",80,[[]]],[11,"lanes","","Returns the number of vector lanes.",80,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",80,[[]]],[11,"extract","","Extracts the value at `index`.",80,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",80,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",80,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",80,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",80,[[["i32x16",6]],["i32x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",80,[[["i32x16",6]],["i32x16",6]]],[11,"min","","Minimum of two vectors.",80,[[]]],[11,"max","","Maximum of two vectors.",80,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",80,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",80,[[]]],[11,"max_element","","Largest vector element value.",80,[[]]],[11,"min_element","","Smallest vector element value.",80,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",80,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",80,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",80,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",80,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",80,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",80,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",80,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",80,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",80,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",80,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",80,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",80,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",80,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",80,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",80,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",80,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",80,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",80,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",80,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",80,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",80,[[]]],[11,"eq","","Lane-wise equality comparison.",80,[[],["m32x16",6]]],[11,"ne","","Lane-wise inequality comparison.",80,[[],["m32x16",6]]],[11,"lt","","Lane-wise less-than comparison.",80,[[],["m32x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",80,[[],["m32x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",80,[[],["m32x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",80,[[],["m32x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",80,[[],[["i32x16",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",80,[[],[["i32x16",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",80,[[]]],[11,"new","","Creates a new instance with each vector elements…",81,[[]]],[11,"lanes","","Returns the number of vector lanes.",81,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",81,[[]]],[11,"extract","","Extracts the value at `index`.",81,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",81,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",81,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",81,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",81,[[["u32x16",6]],["u32x16",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",81,[[["u32x16",6]],["u32x16",6]]],[11,"min","","Minimum of two vectors.",81,[[]]],[11,"max","","Maximum of two vectors.",81,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",81,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",81,[[]]],[11,"max_element","","Largest vector element value.",81,[[]]],[11,"min_element","","Smallest vector element value.",81,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",81,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",81,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",81,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",81,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",81,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",81,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",81,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",81,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",81,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",81,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",81,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",81,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",81,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",81,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",81,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",81,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",81,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",81,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",81,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",81,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",81,[[]]],[11,"eq","","Lane-wise equality comparison.",81,[[],["m32x16",6]]],[11,"ne","","Lane-wise inequality comparison.",81,[[],["m32x16",6]]],[11,"lt","","Lane-wise less-than comparison.",81,[[],["m32x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",81,[[],["m32x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",81,[[],["m32x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",81,[[],["m32x16",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",81,[[],[["lexicographicallyordered",3],["u32x16",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",81,[[],[["lexicographicallyordered",3],["u32x16",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",81,[[]]],[11,"new","","Creates a new instance with each vector elements…",82,[[]]],[11,"lanes","","Returns the number of vector lanes.",82,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",82,[[]]],[11,"extract","","Extracts the value at `index`.",82,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",82,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",82,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",82,[[]]],[11,"min","","Minimum of two vectors.",82,[[]]],[11,"max","","Maximum of two vectors.",82,[[]]],[11,"sum","","Horizontal sum of the vector elements.",82,[[]]],[11,"product","","Horizontal product of the vector elements.",82,[[]]],[11,"max_element","","Largest vector element value.",82,[[]]],[11,"min_element","","Smallest vector element value.",82,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",82,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",82,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",82,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",82,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",82,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",82,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",82,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",82,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",82,[[]]],[18,"EPSILON","","Machine epsilon value.",82,null],[18,"MIN","","Smallest finite value.",82,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",82,null],[18,"MAX","","Largest finite value.",82,null],[18,"NAN","","Not a Number (NaN).",82,null],[18,"INFINITY","","Infinity (∞).",82,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",82,null],[18,"PI","","Archimedes\' constant (π)",82,null],[18,"FRAC_PI_2","","π/2",82,null],[18,"FRAC_PI_3","","π/3",82,null],[18,"FRAC_PI_4","","π/4",82,null],[18,"FRAC_PI_6","","π/6",82,null],[18,"FRAC_PI_8","","π/8",82,null],[18,"FRAC_1_PI","","1/π",82,null],[18,"FRAC_2_PI","","2/π",82,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",82,null],[18,"SQRT_2","","sqrt(2)",82,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",82,null],[18,"E","","Euler\'s number (e)",82,null],[18,"LOG2_E","","log2(e)",82,null],[18,"LOG10_E","","log10(e)",82,null],[18,"LN_2","","ln(2)",82,null],[18,"LN_10","","ln(10)",82,null],[11,"is_nan","","",82,[[],["m32x16",6]]],[11,"is_infinite","","",82,[[],["m32x16",6]]],[11,"is_finite","","",82,[[],["m32x16",6]]],[11,"abs","","Absolute value.",82,[[]]],[11,"cos","","Cosine.",82,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",82,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",82,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",82,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",82,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",82,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",82,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",82,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",82,[[]]],[11,"sin","","Sine.",82,[[]]],[11,"sin_pi","","Sine of `self * PI`.",82,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",82,[[]]],[11,"sqrt","","",82,[[]]],[11,"sqrte","","Square-root estimate.",82,[[]]],[11,"tanh","","Tanh.",82,[[]]],[11,"eq","","Lane-wise equality comparison.",82,[[],["m32x16",6]]],[11,"ne","","Lane-wise inequality comparison.",82,[[],["m32x16",6]]],[11,"lt","","Lane-wise less-than comparison.",82,[[],["m32x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",82,[[],["m32x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",82,[[],["m32x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",82,[[],["m32x16",6]]],[11,"new","","Creates a new instance with each vector elements…",83,[[]]],[11,"lanes","","Returns the number of vector lanes.",83,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",83,[[]]],[11,"extract","","Extracts the value at `index`.",83,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",83,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",83,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",83,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",83,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",83,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",83,[[]]],[11,"all","","Are `all` vector lanes `true`?",83,[[]]],[11,"any","","Is `any` vector lane `true`?",83,[[]]],[11,"none","","Are `all` vector lanes `false`?",83,[[]]],[11,"eq","","Lane-wise equality comparison.",83,[[],["m32x16",6]]],[11,"ne","","Lane-wise inequality comparison.",83,[[],["m32x16",6]]],[11,"lt","","Lane-wise less-than comparison.",83,[[],["m32x16",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",83,[[],["m32x16",6]]],[11,"gt","","Lane-wise greater-than comparison.",83,[[],["m32x16",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",83,[[],["m32x16",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",83,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",83,[[],[["lexicographicallyordered",3],["m32x16",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",83,[[],[["lexicographicallyordered",3],["m32x16",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",83,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",83,[[]]],[11,"new","","Creates a new instance with each vector elements…",84,[[]]],[11,"lanes","","Returns the number of vector lanes.",84,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",84,[[]]],[11,"extract","","Extracts the value at `index`.",84,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",84,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",84,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",84,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",84,[[["i64x8",6]],["i64x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",84,[[["i64x8",6]],["i64x8",6]]],[11,"min","","Minimum of two vectors.",84,[[]]],[11,"max","","Maximum of two vectors.",84,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",84,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",84,[[]]],[11,"max_element","","Largest vector element value.",84,[[]]],[11,"min_element","","Smallest vector element value.",84,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",84,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",84,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",84,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",84,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",84,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",84,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",84,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",84,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",84,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",84,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",84,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",84,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",84,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",84,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",84,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",84,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",84,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",84,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",84,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",84,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",84,[[]]],[11,"eq","","Lane-wise equality comparison.",84,[[],["m64x8",6]]],[11,"ne","","Lane-wise inequality comparison.",84,[[],["m64x8",6]]],[11,"lt","","Lane-wise less-than comparison.",84,[[],["m64x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",84,[[],["m64x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",84,[[],["m64x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",84,[[],["m64x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",84,[[],[["lexicographicallyordered",3],["i64x8",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",84,[[],[["lexicographicallyordered",3],["i64x8",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",84,[[]]],[11,"new","","Creates a new instance with each vector elements…",85,[[]]],[11,"lanes","","Returns the number of vector lanes.",85,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",85,[[]]],[11,"extract","","Extracts the value at `index`.",85,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",85,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",85,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",85,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",85,[[["u64x8",6]],["u64x8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",85,[[["u64x8",6]],["u64x8",6]]],[11,"min","","Minimum of two vectors.",85,[[]]],[11,"max","","Maximum of two vectors.",85,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",85,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",85,[[]]],[11,"max_element","","Largest vector element value.",85,[[]]],[11,"min_element","","Smallest vector element value.",85,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",85,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",85,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",85,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",85,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",85,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",85,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",85,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",85,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",85,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",85,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",85,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",85,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",85,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",85,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",85,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",85,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",85,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",85,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",85,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",85,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",85,[[]]],[11,"eq","","Lane-wise equality comparison.",85,[[],["m64x8",6]]],[11,"ne","","Lane-wise inequality comparison.",85,[[],["m64x8",6]]],[11,"lt","","Lane-wise less-than comparison.",85,[[],["m64x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",85,[[],["m64x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",85,[[],["m64x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",85,[[],["m64x8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",85,[[],[["u64x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",85,[[],[["u64x8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",85,[[]]],[11,"new","","Creates a new instance with each vector elements…",86,[[]]],[11,"lanes","","Returns the number of vector lanes.",86,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",86,[[]]],[11,"extract","","Extracts the value at `index`.",86,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",86,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",86,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",86,[[]]],[11,"min","","Minimum of two vectors.",86,[[]]],[11,"max","","Maximum of two vectors.",86,[[]]],[11,"sum","","Horizontal sum of the vector elements.",86,[[]]],[11,"product","","Horizontal product of the vector elements.",86,[[]]],[11,"max_element","","Largest vector element value.",86,[[]]],[11,"min_element","","Smallest vector element value.",86,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",86,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",86,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",86,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",86,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",86,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",86,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",86,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",86,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",86,[[]]],[18,"EPSILON","","Machine epsilon value.",86,null],[18,"MIN","","Smallest finite value.",86,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",86,null],[18,"MAX","","Largest finite value.",86,null],[18,"NAN","","Not a Number (NaN).",86,null],[18,"INFINITY","","Infinity (∞).",86,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",86,null],[18,"PI","","Archimedes\' constant (π)",86,null],[18,"FRAC_PI_2","","π/2",86,null],[18,"FRAC_PI_3","","π/3",86,null],[18,"FRAC_PI_4","","π/4",86,null],[18,"FRAC_PI_6","","π/6",86,null],[18,"FRAC_PI_8","","π/8",86,null],[18,"FRAC_1_PI","","1/π",86,null],[18,"FRAC_2_PI","","2/π",86,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",86,null],[18,"SQRT_2","","sqrt(2)",86,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",86,null],[18,"E","","Euler\'s number (e)",86,null],[18,"LOG2_E","","log2(e)",86,null],[18,"LOG10_E","","log10(e)",86,null],[18,"LN_2","","ln(2)",86,null],[18,"LN_10","","ln(10)",86,null],[11,"is_nan","","",86,[[],["m64x8",6]]],[11,"is_infinite","","",86,[[],["m64x8",6]]],[11,"is_finite","","",86,[[],["m64x8",6]]],[11,"abs","","Absolute value.",86,[[]]],[11,"cos","","Cosine.",86,[[]]],[11,"cos_pi","","Cosine of `self * PI`.",86,[[]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",86,[[]]],[11,"ln","","Returns the natural logarithm of `self`.",86,[[]]],[11,"mul_add","","Fused multiply add: `self * y + z`",86,[[]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",86,[[]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",86,[[]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",86,[[]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",86,[[]]],[11,"sin","","Sine.",86,[[]]],[11,"sin_pi","","Sine of `self * PI`.",86,[[]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",86,[[]]],[11,"sqrt","","",86,[[]]],[11,"sqrte","","Square-root estimate.",86,[[]]],[11,"tanh","","Tanh.",86,[[]]],[11,"eq","","Lane-wise equality comparison.",86,[[],["m64x8",6]]],[11,"ne","","Lane-wise inequality comparison.",86,[[],["m64x8",6]]],[11,"lt","","Lane-wise less-than comparison.",86,[[],["m64x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",86,[[],["m64x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",86,[[],["m64x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",86,[[],["m64x8",6]]],[11,"new","","Creates a new instance with each vector elements…",87,[[]]],[11,"lanes","","Returns the number of vector lanes.",87,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",87,[[]]],[11,"extract","","Extracts the value at `index`.",87,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",87,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",87,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",87,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",87,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",87,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",87,[[]]],[11,"all","","Are `all` vector lanes `true`?",87,[[]]],[11,"any","","Is `any` vector lane `true`?",87,[[]]],[11,"none","","Are `all` vector lanes `false`?",87,[[]]],[11,"eq","","Lane-wise equality comparison.",87,[[],["m64x8",6]]],[11,"ne","","Lane-wise inequality comparison.",87,[[],["m64x8",6]]],[11,"lt","","Lane-wise less-than comparison.",87,[[],["m64x8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",87,[[],["m64x8",6]]],[11,"gt","","Lane-wise greater-than comparison.",87,[[],["m64x8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",87,[[],["m64x8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",87,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",87,[[],[["m64x8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",87,[[],[["m64x8",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",87,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",87,[[]]],[11,"new","","Creates a new instance with each vector elements…",88,[[]]],[11,"lanes","","Returns the number of vector lanes.",88,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",88,[[]]],[11,"extract","","Extracts the value at `index`.",88,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",88,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",88,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",88,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",88,[[["i128x4",6]],["i128x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",88,[[["i128x4",6]],["i128x4",6]]],[11,"min","","Minimum of two vectors.",88,[[]]],[11,"max","","Maximum of two vectors.",88,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",88,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",88,[[]]],[11,"max_element","","Largest vector element value.",88,[[]]],[11,"min_element","","Smallest vector element value.",88,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",88,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",88,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",88,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",88,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",88,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",88,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",88,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",88,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",88,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",88,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",88,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",88,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",88,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",88,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",88,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",88,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",88,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",88,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",88,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",88,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",88,[[]]],[11,"eq","","Lane-wise equality comparison.",88,[[],["m128x4",6]]],[11,"ne","","Lane-wise inequality comparison.",88,[[],["m128x4",6]]],[11,"lt","","Lane-wise less-than comparison.",88,[[],["m128x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",88,[[],["m128x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",88,[[],["m128x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",88,[[],["m128x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",88,[[],[["i128x4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",88,[[],[["i128x4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",88,[[]]],[11,"new","","Creates a new instance with each vector elements…",89,[[]]],[11,"lanes","","Returns the number of vector lanes.",89,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",89,[[]]],[11,"extract","","Extracts the value at `index`.",89,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",89,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",89,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",89,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",89,[[["u128x4",6]],["u128x4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",89,[[["u128x4",6]],["u128x4",6]]],[11,"min","","Minimum of two vectors.",89,[[]]],[11,"max","","Maximum of two vectors.",89,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",89,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",89,[[]]],[11,"max_element","","Largest vector element value.",89,[[]]],[11,"min_element","","Smallest vector element value.",89,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",89,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",89,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",89,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",89,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",89,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",89,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",89,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",89,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",89,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",89,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",89,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",89,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",89,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",89,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",89,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",89,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",89,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",89,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",89,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",89,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",89,[[]]],[11,"eq","","Lane-wise equality comparison.",89,[[],["m128x4",6]]],[11,"ne","","Lane-wise inequality comparison.",89,[[],["m128x4",6]]],[11,"lt","","Lane-wise less-than comparison.",89,[[],["m128x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",89,[[],["m128x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",89,[[],["m128x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",89,[[],["m128x4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",89,[[],[["lexicographicallyordered",3],["u128x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",89,[[],[["lexicographicallyordered",3],["u128x4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",89,[[]]],[11,"new","","Creates a new instance with each vector elements…",90,[[]]],[11,"lanes","","Returns the number of vector lanes.",90,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",90,[[]]],[11,"extract","","Extracts the value at `index`.",90,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",90,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",90,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",90,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",90,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",90,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",90,[[]]],[11,"all","","Are `all` vector lanes `true`?",90,[[]]],[11,"any","","Is `any` vector lane `true`?",90,[[]]],[11,"none","","Are `all` vector lanes `false`?",90,[[]]],[11,"eq","","Lane-wise equality comparison.",90,[[],["m128x4",6]]],[11,"ne","","Lane-wise inequality comparison.",90,[[],["m128x4",6]]],[11,"lt","","Lane-wise less-than comparison.",90,[[],["m128x4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",90,[[],["m128x4",6]]],[11,"gt","","Lane-wise greater-than comparison.",90,[[],["m128x4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",90,[[],["m128x4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",90,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",90,[[],[["lexicographicallyordered",3],["m128x4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",90,[[],[["lexicographicallyordered",3],["m128x4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",90,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",90,[[]]],[11,"new","","Creates a new instance with each vector elements…",48,[[]]],[11,"lanes","","Returns the number of vector lanes.",48,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",48,[[]]],[11,"extract","","Extracts the value at `index`.",48,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",48,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",48,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",48,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",48,[[["isizex2",6]],["isizex2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",48,[[["isizex2",6]],["isizex2",6]]],[11,"min","","Minimum of two vectors.",48,[[]]],[11,"max","","Maximum of two vectors.",48,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",48,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",48,[[]]],[11,"max_element","","Largest vector element value.",48,[[]]],[11,"min_element","","Smallest vector element value.",48,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",48,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",48,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",48,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",48,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",48,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",48,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",48,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",48,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",48,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",48,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",48,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",48,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",48,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",48,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",48,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",48,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",48,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",48,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",48,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",48,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",48,[[]]],[11,"eq","","Lane-wise equality comparison.",48,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",48,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",48,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",48,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",48,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",48,[[],["msizex2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",48,[[],[["lexicographicallyordered",3],["isizex2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",48,[[],[["lexicographicallyordered",3],["isizex2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",48,[[]]],[11,"new","","Creates a new instance with each vector elements…",49,[[]]],[11,"lanes","","Returns the number of vector lanes.",49,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",49,[[]]],[11,"extract","","Extracts the value at `index`.",49,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",49,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",49,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",49,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",49,[[["usizex2",6]],["usizex2",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",49,[[["usizex2",6]],["usizex2",6]]],[11,"min","","Minimum of two vectors.",49,[[]]],[11,"max","","Maximum of two vectors.",49,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",49,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",49,[[]]],[11,"max_element","","Largest vector element value.",49,[[]]],[11,"min_element","","Smallest vector element value.",49,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",49,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",49,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",49,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",49,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",49,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",49,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",49,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",49,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",49,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",49,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",49,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",49,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",49,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",49,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",49,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",49,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",49,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",49,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",49,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",49,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",49,[[]]],[11,"eq","","Lane-wise equality comparison.",49,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",49,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",49,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",49,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",49,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",49,[[],["msizex2",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",49,[[],[["lexicographicallyordered",3],["usizex2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",49,[[],[["lexicographicallyordered",3],["usizex2",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",49,[[]]],[11,"new","","Creates a new instance with each vector elements…",50,[[]]],[11,"lanes","","Returns the number of vector lanes.",50,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",50,[[]]],[11,"extract","","Extracts the value at `index`.",50,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",50,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",50,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",50,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",50,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",50,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",50,[[]]],[11,"all","","Are `all` vector lanes `true`?",50,[[]]],[11,"any","","Is `any` vector lane `true`?",50,[[]]],[11,"none","","Are `all` vector lanes `false`?",50,[[]]],[11,"eq","","Lane-wise equality comparison.",50,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",50,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",50,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",50,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",50,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",50,[[],["msizex2",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",50,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",50,[[],[["lexicographicallyordered",3],["msizex2",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",50,[[],[["lexicographicallyordered",3],["msizex2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",50,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",50,[[]]],[11,"new","","Creates a new instance with each vector elements…",71,[[]]],[11,"lanes","","Returns the number of vector lanes.",71,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",71,[[]]],[11,"extract","","Extracts the value at `index`.",71,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",71,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",71,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",71,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",71,[[["isizex4",6]],["isizex4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",71,[[["isizex4",6]],["isizex4",6]]],[11,"min","","Minimum of two vectors.",71,[[]]],[11,"max","","Maximum of two vectors.",71,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",71,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",71,[[]]],[11,"max_element","","Largest vector element value.",71,[[]]],[11,"min_element","","Smallest vector element value.",71,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",71,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",71,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",71,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",71,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",71,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",71,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",71,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",71,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",71,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",71,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",71,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",71,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",71,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",71,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",71,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",71,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",71,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",71,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",71,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",71,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",71,[[]]],[11,"eq","","Lane-wise equality comparison.",71,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",71,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",71,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",71,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",71,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",71,[[],["msizex4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",71,[[],[["isizex4",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",71,[[],[["isizex4",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",71,[[]]],[11,"new","","Creates a new instance with each vector elements…",72,[[]]],[11,"lanes","","Returns the number of vector lanes.",72,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",72,[[]]],[11,"extract","","Extracts the value at `index`.",72,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",72,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",72,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",72,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",72,[[["usizex4",6]],["usizex4",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",72,[[["usizex4",6]],["usizex4",6]]],[11,"min","","Minimum of two vectors.",72,[[]]],[11,"max","","Maximum of two vectors.",72,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",72,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",72,[[]]],[11,"max_element","","Largest vector element value.",72,[[]]],[11,"min_element","","Smallest vector element value.",72,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",72,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",72,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",72,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",72,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",72,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",72,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",72,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",72,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",72,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",72,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",72,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",72,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",72,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",72,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",72,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",72,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",72,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",72,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",72,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",72,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",72,[[]]],[11,"eq","","Lane-wise equality comparison.",72,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",72,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",72,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",72,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",72,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",72,[[],["msizex4",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",72,[[],[["lexicographicallyordered",3],["usizex4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",72,[[],[["lexicographicallyordered",3],["usizex4",6]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",72,[[]]],[11,"new","","Creates a new instance with each vector elements…",73,[[]]],[11,"lanes","","Returns the number of vector lanes.",73,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",73,[[]]],[11,"extract","","Extracts the value at `index`.",73,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",73,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",73,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",73,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",73,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",73,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",73,[[]]],[11,"all","","Are `all` vector lanes `true`?",73,[[]]],[11,"any","","Is `any` vector lane `true`?",73,[[]]],[11,"none","","Are `all` vector lanes `false`?",73,[[]]],[11,"eq","","Lane-wise equality comparison.",73,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",73,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",73,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",73,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",73,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",73,[[],["msizex4",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",73,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",73,[[],[["lexicographicallyordered",3],["msizex4",6]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",73,[[],[["lexicographicallyordered",3],["msizex4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",73,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",73,[[]]],[11,"new","","Creates a new instance with each vector elements…",91,[[]]],[11,"lanes","","Returns the number of vector lanes.",91,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",91,[[]]],[11,"extract","","Extracts the value at `index`.",91,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",91,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",91,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",91,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",91,[[["isizex8",6]],["isizex8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",91,[[["isizex8",6]],["isizex8",6]]],[11,"min","","Minimum of two vectors.",91,[[]]],[11,"max","","Maximum of two vectors.",91,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",91,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",91,[[]]],[11,"max_element","","Largest vector element value.",91,[[]]],[11,"min_element","","Smallest vector element value.",91,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",91,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",91,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",91,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",91,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",91,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",91,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",91,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",91,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",91,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",91,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",91,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",91,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",91,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",91,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",91,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",91,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",91,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",91,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",91,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",91,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",91,[[]]],[11,"eq","","Lane-wise equality comparison.",91,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",91,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",91,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",91,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",91,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",91,[[],["msizex8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",91,[[],[["isizex8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",91,[[],[["isizex8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",91,[[]]],[11,"new","","Creates a new instance with each vector elements…",92,[[]]],[11,"lanes","","Returns the number of vector lanes.",92,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",92,[[]]],[11,"extract","","Extracts the value at `index`.",92,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",92,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",92,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",92,[[]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",92,[[["usizex8",6]],["usizex8",6]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",92,[[["usizex8",6]],["usizex8",6]]],[11,"min","","Minimum of two vectors.",92,[[]]],[11,"max","","Maximum of two vectors.",92,[[]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",92,[[]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",92,[[]]],[11,"max_element","","Largest vector element value.",92,[[]]],[11,"min_element","","Smallest vector element value.",92,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",92,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",92,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",92,[[]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",92,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",92,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",92,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",92,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",92,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",92,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",92,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",92,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",92,[[]]],[11,"to_le","","Converts self to little endian from the target\'s endianness.",92,[[]]],[11,"to_be","","Converts self to big endian from the target\'s endianness.",92,[[]]],[11,"from_le","","Converts a vector from little endian to the target\'s…",92,[[]]],[11,"from_be","","Converts a vector from big endian to the target\'s…",92,[[]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",92,[[]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",92,[[]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",92,[[]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",92,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",92,[[]]],[11,"eq","","Lane-wise equality comparison.",92,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",92,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",92,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",92,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",92,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",92,[[],["msizex8",6]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",92,[[],[["usizex8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",92,[[],[["usizex8",6],["lexicographicallyordered",3]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",92,[[]]],[11,"new","","Creates a new instance with each vector elements…",93,[[]]],[11,"lanes","","Returns the number of vector lanes.",93,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",93,[[]]],[11,"extract","","Extracts the value at `index`.",93,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",93,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",93,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",93,[[]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",93,[[]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",93,[[]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",93,[[]]],[11,"all","","Are `all` vector lanes `true`?",93,[[]]],[11,"any","","Is `any` vector lane `true`?",93,[[]]],[11,"none","","Are `all` vector lanes `false`?",93,[[]]],[11,"eq","","Lane-wise equality comparison.",93,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",93,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",93,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",93,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",93,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",93,[[],["msizex8",6]]],[11,"select","","Selects elements of `a` and `b` using mask.",93,[[["simd",3]],["simd",3]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",93,[[],[["msizex8",6],["lexicographicallyordered",3]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",93,[[],[["msizex8",6],["lexicographicallyordered",3]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",93,[[]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",93,[[]]],[11,"new","","Creates a new instance with each vector elements…",94,[[]]],[11,"lanes","","Returns the number of vector lanes.",94,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",94,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",94,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",94,[[],["msizex2",6]]],[11,"extract","","Extracts the value at `index`.",94,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",94,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",94,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",94,[[]]],[11,"eq","","Lane-wise equality comparison.",94,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",94,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",94,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",94,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",94,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",94,[[],["msizex2",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",94,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",94,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",94,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",94,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",94,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",94,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",94,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",94,[[]]],[11,"offset","","Calculates the offset from a pointer.",94,[[["isizex2",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",94,[[["isizex2",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",94,[[],["isizex2",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",94,[[],["isizex2",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",94,[[["usizex2",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",94,[[["usizex2",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",94,[[["usizex2",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",94,[[["usizex2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",94,[[]]],[11,"read","","Reads selected vector elements from memory.",94,[[["simd",3],["simd",3]],["simd",3]]],[11,"new","","Creates a new instance with each vector elements…",95,[[]]],[11,"lanes","","Returns the number of vector lanes.",95,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",95,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",95,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",95,[[],["msizex2",6]]],[11,"extract","","Extracts the value at `index`.",95,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",95,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",95,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",95,[[]]],[11,"eq","","Lane-wise equality comparison.",95,[[],["msizex2",6]]],[11,"ne","","Lane-wise inequality comparison.",95,[[],["msizex2",6]]],[11,"lt","","Lane-wise less-than comparison.",95,[[],["msizex2",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",95,[[],["msizex2",6]]],[11,"gt","","Lane-wise greater-than comparison.",95,[[],["msizex2",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",95,[[],["msizex2",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",95,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",95,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",95,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",95,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",95,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",95,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",95,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",95,[[]]],[11,"offset","","Calculates the offset from a pointer.",95,[[["isizex2",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",95,[[["isizex2",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",95,[[],["isizex2",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",95,[[],["isizex2",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",95,[[["usizex2",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",95,[[["usizex2",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",95,[[["usizex2",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",95,[[["usizex2",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",95,[[]]],[11,"read","","Reads selected vector elements from memory.",95,[[["simd",3],["simd",3]],["simd",3]]],[11,"write","","Writes selected vector elements to memory.",95,[[["simd",3],["simd",3]]]],[11,"new","","Creates a new instance with each vector elements…",96,[[]]],[11,"lanes","","Returns the number of vector lanes.",96,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",96,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",96,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",96,[[],["msizex4",6]]],[11,"extract","","Extracts the value at `index`.",96,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",96,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",96,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",96,[[]]],[11,"eq","","Lane-wise equality comparison.",96,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",96,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",96,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",96,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",96,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",96,[[],["msizex4",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",96,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",96,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",96,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",96,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",96,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",96,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",96,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",96,[[]]],[11,"offset","","Calculates the offset from a pointer.",96,[[["isizex4",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",96,[[["isizex4",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",96,[[],["isizex4",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",96,[[],["isizex4",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",96,[[["usizex4",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",96,[[["usizex4",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",96,[[["usizex4",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",96,[[["usizex4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",96,[[]]],[11,"read","","Reads selected vector elements from memory.",96,[[["simd",3],["simd",3]],["simd",3]]],[11,"new","","Creates a new instance with each vector elements…",97,[[]]],[11,"lanes","","Returns the number of vector lanes.",97,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",97,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",97,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",97,[[],["msizex4",6]]],[11,"extract","","Extracts the value at `index`.",97,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",97,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",97,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",97,[[]]],[11,"eq","","Lane-wise equality comparison.",97,[[],["msizex4",6]]],[11,"ne","","Lane-wise inequality comparison.",97,[[],["msizex4",6]]],[11,"lt","","Lane-wise less-than comparison.",97,[[],["msizex4",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",97,[[],["msizex4",6]]],[11,"gt","","Lane-wise greater-than comparison.",97,[[],["msizex4",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",97,[[],["msizex4",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",97,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",97,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",97,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",97,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",97,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",97,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",97,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",97,[[]]],[11,"offset","","Calculates the offset from a pointer.",97,[[["isizex4",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",97,[[["isizex4",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",97,[[],["isizex4",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",97,[[],["isizex4",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",97,[[["usizex4",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",97,[[["usizex4",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",97,[[["usizex4",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",97,[[["usizex4",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",97,[[]]],[11,"read","","Reads selected vector elements from memory.",97,[[["simd",3],["simd",3]],["simd",3]]],[11,"write","","Writes selected vector elements to memory.",97,[[["simd",3],["simd",3]]]],[11,"new","","Creates a new instance with each vector elements…",98,[[]]],[11,"lanes","","Returns the number of vector lanes.",98,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",98,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",98,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",98,[[],["msizex8",6]]],[11,"extract","","Extracts the value at `index`.",98,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",98,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",98,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",98,[[]]],[11,"eq","","Lane-wise equality comparison.",98,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",98,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",98,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",98,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",98,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",98,[[],["msizex8",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",98,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",98,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",98,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",98,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",98,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",98,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",98,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",98,[[]]],[11,"offset","","Calculates the offset from a pointer.",98,[[["isizex8",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",98,[[["isizex8",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",98,[[],["isizex8",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",98,[[],["isizex8",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",98,[[["usizex8",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",98,[[["usizex8",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",98,[[["usizex8",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",98,[[["usizex8",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",98,[[]]],[11,"read","","Reads selected vector elements from memory.",98,[[["simd",3],["simd",3]],["simd",3]]],[11,"new","","Creates a new instance with each vector elements…",99,[[]]],[11,"lanes","","Returns the number of vector lanes.",99,[[]]],[11,"splat","","Constructs a new instance with each element initialized to…",99,[[]]],[11,"null","","Constructs a new instance with each element initialized to…",99,[[]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",99,[[],["msizex8",6]]],[11,"extract","","Extracts the value at `index`.",99,[[]]],[11,"extract_unchecked","","Extracts the value at `index`.",99,[[]]],[11,"replace","","Returns a new vector where the value at `index` is…",99,[[]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",99,[[]]],[11,"eq","","Lane-wise equality comparison.",99,[[],["msizex8",6]]],[11,"ne","","Lane-wise inequality comparison.",99,[[],["msizex8",6]]],[11,"lt","","Lane-wise less-than comparison.",99,[[],["msizex8",6]]],[11,"le","","Lane-wise less-than-or-equals comparison.",99,[[],["msizex8",6]]],[11,"gt","","Lane-wise greater-than comparison.",99,[[],["msizex8",6]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",99,[[],["msizex8",6]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",99,[[]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",99,[[]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",99,[[]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",99,[[]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",99,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",99,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",99,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",99,[[]]],[11,"offset","","Calculates the offset from a pointer.",99,[[["isizex8",6]]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",99,[[["isizex8",6]]]],[11,"offset_from","","Calculates the distance between two pointers.",99,[[],["isizex8",6]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",99,[[],["isizex8",6]]],[11,"add","","Calculates the offset from a pointer (convenience for…",99,[[["usizex8",6]]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",99,[[["usizex8",6]]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",99,[[["usizex8",6]]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",99,[[["usizex8",6]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",99,[[]]],[11,"read","","Reads selected vector elements from memory.",99,[[["simd",3],["simd",3]],["simd",3]]],[11,"write","","Writes selected vector elements to memory.",99,[[["simd",3],["simd",3]]]]],"p":[[3,"m8"],[3,"m16"],[3,"m32"],[3,"m64"],[3,"m128"],[3,"msize"],[3,"Simd"],[8,"SimdVector"],[8,"SimdArray"],[8,"Mask"],[8,"FromCast"],[8,"Cast"],[8,"FromBits"],[8,"IntoBits"],[3,"LexicographicallyOrdered"],[6,"i8x2"],[6,"u8x2"],[6,"m8x2"],[6,"i8x4"],[6,"u8x4"],[6,"m8x4"],[6,"i16x2"],[6,"u16x2"],[6,"m16x2"],[6,"i8x8"],[6,"u8x8"],[6,"m8x8"],[6,"i16x4"],[6,"u16x4"],[6,"m16x4"],[6,"i32x2"],[6,"u32x2"],[6,"f32x2"],[6,"m32x2"],[6,"i8x16"],[6,"u8x16"],[6,"m8x16"],[6,"i16x8"],[6,"u16x8"],[6,"m16x8"],[6,"i32x4"],[6,"u32x4"],[6,"f32x4"],[6,"m32x4"],[6,"i64x2"],[6,"u64x2"],[6,"f64x2"],[6,"m64x2"],[6,"isizex2"],[6,"usizex2"],[6,"msizex2"],[6,"i128x1"],[6,"u128x1"],[6,"m128x1"],[6,"i8x32"],[6,"u8x32"],[6,"m8x32"],[6,"i16x16"],[6,"u16x16"],[6,"m16x16"],[6,"i32x8"],[6,"u32x8"],[6,"f32x8"],[6,"m32x8"],[6,"i64x4"],[6,"u64x4"],[6,"f64x4"],[6,"m64x4"],[6,"i128x2"],[6,"u128x2"],[6,"m128x2"],[6,"isizex4"],[6,"usizex4"],[6,"msizex4"],[6,"i8x64"],[6,"u8x64"],[6,"m8x64"],[6,"i16x32"],[6,"u16x32"],[6,"m16x32"],[6,"i32x16"],[6,"u32x16"],[6,"f32x16"],[6,"m32x16"],[6,"i64x8"],[6,"u64x8"],[6,"f64x8"],[6,"m64x8"],[6,"i128x4"],[6,"u128x4"],[6,"m128x4"],[6,"isizex8"],[6,"usizex8"],[6,"msizex8"],[6,"cptrx2"],[6,"mptrx2"],[6,"cptrx4"],[6,"mptrx4"],[6,"cptrx8"],[6,"mptrx8"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);